import type { VercelRequest, VercelResponse } from '@vercel/node';
import { createClerkClient, verifyToken } from '@clerk/backend';

// Database connection using Pool (more reliable in serverless)
async function getDb() {
  const pg = await import('pg');
  const Pool = pg.default?.Pool || pg.Pool;
  const pool = new (Pool as any)({ connectionString: process.env.DATABASE_URL });
  return pool;
}

// Verify user authentication from Clerk token
async function verifyAuth(req: VercelRequest): Promise<{ userId: string; email: string } | null> {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return null;
    }

    const token = authHeader.substring(7);
    const secretKey = process.env.CLERK_SECRET_KEY;

    if (!secretKey) {
      console.error('CLERK_SECRET_KEY not set');
      return null;
    }
    
    const payload = await verifyToken(token, { secretKey });

    if (!payload?.sub) {
      return null;
    }

    const clerk = createClerkClient({ secretKey });
    const user = await clerk.users.getUser(payload.sub);
    const email = user.emailAddresses[0]?.emailAddress || '';

    return { userId: payload.sub, email };
  } catch (error) {
    console.error('Auth verification failed:', error);
    return null;
  }
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PATCH,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const auth = await verifyAuth(req);
  if (!auth) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const { userId, email } = auth;
  let pool: any = null;

  try {
    pool = await getDb();

    // Get or create crypto user
    let userResult = await pool.query(
      'SELECT id FROM crypto_users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) {
      // Try by email
      userResult = await pool.query(
        'SELECT id FROM crypto_users WHERE email = $1',
        [email]
      );
    }

    if (userResult.rows.length === 0 && email) {
      // Create new user with Clerk ID
      await pool.query(
        'INSERT INTO crypto_users (id, email) VALUES ($1, $2) ON CONFLICT (id) DO NOTHING',
        [userId, email]
      );
      userResult = await pool.query('SELECT id FROM crypto_users WHERE id = $1', [userId]);
    }

    if (userResult.rows.length === 0) {
      return res.status(500).json({ error: 'Failed to get or create user' });
    }

    const cryptoUserId = userResult.rows[0].id;

    // Get subscription and check Elliott access
    const subResult = await pool.query(
      'SELECT tier, has_elliott_addon FROM crypto_subscriptions WHERE user_id = $1',
      [cryptoUserId]
    );

    const subscription = subResult.rows[0];
    const hasAccess = subscription?.tier === 'elite' || subscription?.has_elliott_addon === true;

    if (!hasAccess) {
      return res.status(403).json({ error: 'Elliott Wave features require Elite tier or Elliott Wave add-on' });
    }

    if (req.method === 'GET') {
      const { symbol, timeframe, allTimeframes } = req.query;
      
      if (!symbol) {
        return res.status(400).json({ error: 'Symbol is required' });
      }
      
      let labels;
      
      // If allTimeframes=true, fetch ALL labels for this symbol across all timeframes
      if (allTimeframes === 'true') {
        labels = await pool.query(
          `SELECT * FROM elliott_wave_labels 
           WHERE user_id = $1 AND symbol = $2
           ORDER BY created_at ASC`,
          [cryptoUserId, symbol]
        );
      } else {
        // Standard query: filter by symbol AND timeframe
        if (!timeframe) {
          return res.status(400).json({ error: 'Timeframe is required (or use allTimeframes=true)' });
        }
        
        labels = await pool.query(
          `SELECT * FROM elliott_wave_labels 
           WHERE user_id = $1 AND symbol = $2 AND timeframe = $3
           ORDER BY created_at DESC`,
          [cryptoUserId, symbol, timeframe]
        );
      }
      
      // Map field names for frontend compatibility
      const mappedLabels = labels.rows.map((label: any) => ({
        ...label,
        userId: label.user_id,
        patternType: label.pattern_type,
        fibonacciMode: label.fib_mode,
        isComplete: label.is_confirmed,
        validationStatus: label.validation_status,
        validationErrors: label.validation_errors,
        isAutoGenerated: label.is_auto_generated,
        createdAt: label.created_at,
        updatedAt: label.updated_at,
      }));
      
      return res.json(mappedLabels);
    }
    
    if (req.method === 'POST') {
      const { symbol, timeframe, degree, patternType, points, isComplete, fibonacciMode, validationResult, metadata } = req.body;
      
      if (!symbol || !timeframe || !degree || !patternType || !points) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      const validationStatus = validationResult?.isValid !== false ? 'valid' : 'warning';
      const validationErrors: string[] = validationResult?.errors || [];
      
      const result = await pool.query(
        `INSERT INTO elliott_wave_labels 
         (user_id, symbol, timeframe, degree, pattern_type, points, fib_mode, validation_status, validation_errors, is_auto_generated, is_confirmed, metadata)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
         RETURNING *`,
        [
          cryptoUserId,
          symbol,
          timeframe,
          degree,
          patternType,
          JSON.stringify(points),
          fibonacciMode || 'measured',
          validationStatus,
          validationErrors,
          false,
          isComplete ?? false,
          metadata ? JSON.stringify(metadata) : null
        ]
      );
      
      const newLabel = result.rows[0];
      
      // Return with mapped field names for frontend compatibility
      return res.json({
        ...newLabel,
        userId: newLabel.user_id,
        patternType: newLabel.pattern_type,
        fibonacciMode: newLabel.fib_mode,
        isComplete: newLabel.is_confirmed,
        validationStatus: newLabel.validation_status,
        validationErrors: newLabel.validation_errors,
        isAutoGenerated: newLabel.is_auto_generated,
        createdAt: newLabel.created_at,
        updatedAt: newLabel.updated_at,
      });
    }
    
    // FALLBACK: Handle DELETE and PATCH if ID was passed in URL
    // This can happen if Vercel routing doesn't properly distinguish index.ts from [id].ts
    const pathParts = req.url?.split('/').filter(Boolean) || [];
    const possibleId = pathParts[pathParts.length - 1];
    const hasId = possibleId && possibleId !== 'labels' && !possibleId.includes('?');
    
    if (hasId && req.method === 'DELETE') {
      console.log(`Fallback DELETE handler for ID: ${possibleId}`);
      
      // Verify ownership
      const existing = await pool.query(
        'SELECT user_id FROM elliott_wave_labels WHERE id = $1',
        [possibleId]
      );
      
      if (existing.rows.length === 0) {
        return res.status(404).json({ error: 'Label not found' });
      }
      if (existing.rows[0].user_id !== cryptoUserId) {
        return res.status(403).json({ error: 'Not authorized' });
      }
      
      await pool.query('DELETE FROM elliott_wave_labels WHERE id = $1', [possibleId]);
      return res.json({ success: true });
    }
    
    if (hasId && req.method === 'PATCH') {
      console.log(`Fallback PATCH handler for ID: ${possibleId}`);
      
      // Verify ownership
      const existing = await pool.query(
        'SELECT user_id FROM elliott_wave_labels WHERE id = $1',
        [possibleId]
      );
      
      if (existing.rows.length === 0) {
        return res.status(404).json({ error: 'Label not found' });
      }
      if (existing.rows[0].user_id !== cryptoUserId) {
        return res.status(403).json({ error: 'Not authorized' });
      }
      
      const { points, fibonacciMode, validationResult, isComplete } = req.body;
      
      const updates: string[] = ['updated_at = NOW()'];
      const values: any[] = [];
      let paramIndex = 1;
      
      if (points !== undefined) {
        updates.push(`points = $${paramIndex++}`);
        values.push(JSON.stringify(points));
      }
      if (fibonacciMode !== undefined) {
        updates.push(`fib_mode = $${paramIndex++}`);
        values.push(fibonacciMode);
      }
      if (isComplete !== undefined) {
        updates.push(`is_confirmed = $${paramIndex++}`);
        values.push(isComplete);
      }
      if (validationResult !== undefined) {
        updates.push(`validation_status = $${paramIndex++}`);
        values.push(validationResult?.isValid !== false ? 'valid' : 'warning');
        updates.push(`validation_errors = $${paramIndex++}`);
        values.push(validationResult?.errors || []);
      }
      
      values.push(possibleId);
      
      const result = await pool.query(
        `UPDATE elliott_wave_labels SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
        values
      );
      
      const updated = result.rows[0];
      return res.json({
        ...updated,
        userId: updated.user_id,
        patternType: updated.pattern_type,
        fibonacciMode: updated.fib_mode,
        isComplete: updated.is_confirmed,
        validationStatus: updated.validation_status,
        validationErrors: updated.validation_errors,
        isAutoGenerated: updated.is_auto_generated,
        createdAt: updated.created_at,
        updatedAt: updated.updated_at,
      });
    }
    
    // PATCH and DELETE are handled by [id].ts, but if we got here without an ID, reject
    return res.status(405).json({ error: 'Method not allowed - use GET or POST' });

  } catch (error: any) {
    console.error('Error with Elliott Wave labels:', error);
    return res.status(500).json({ error: error.message });
  } finally {
    if (pool) {
      try {
        await pool.end();
      } catch (e) {
        console.error('Error closing db connection:', e);
      }
    }
  }
}
