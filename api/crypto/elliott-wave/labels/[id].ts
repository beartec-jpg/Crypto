import type { VercelRequest, VercelResponse } from '@vercel/node';
import { createClerkClient, verifyToken } from '@clerk/backend';

// Database connection using Pool (more reliable in serverless)
async function getDb() {
  const pg = await import('pg');
  const Pool = pg.default?.Pool || pg.Pool;
  const pool = new (Pool as any)({ connectionString: process.env.DATABASE_URL });
  return pool;
}

// Verify user authentication from Clerk token
async function verifyAuth(req: VercelRequest): Promise<{ userId: string; email: string } | null> {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return null;
    }

    const token = authHeader.substring(7);
    const secretKey = process.env.CLERK_SECRET_KEY;

    if (!secretKey) {
      console.error('CLERK_SECRET_KEY not set');
      return null;
    }
    
    const payload = await verifyToken(token, { secretKey });

    if (!payload?.sub) {
      return null;
    }

    const clerk = createClerkClient({ secretKey });
    const user = await clerk.users.getUser(payload.sub);
    const email = user.emailAddresses[0]?.emailAddress || '';

    return { userId: payload.sub, email };
  } catch (error) {
    console.error('Auth verification failed:', error);
    return null;
  }
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,PATCH,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  // Get label ID from query params (Vercel dynamic routes)
  const { id } = req.query;
  
  if (!id || typeof id !== 'string') {
    return res.status(400).json({ error: 'Label ID required' });
  }

  const auth = await verifyAuth(req);
  if (!auth) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const { userId, email } = auth;
  let pool: any = null;

  try {
    pool = await getDb();

    // Get user ID
    let userResult = await pool.query(
      'SELECT id FROM crypto_users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) {
      userResult = await pool.query(
        'SELECT id FROM crypto_users WHERE email = $1',
        [email]
      );
    }

    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const cryptoUserId = userResult.rows[0].id;

    // Get subscription and check Elliott access
    const subResult = await pool.query(
      'SELECT tier, has_elliott_addon FROM crypto_subscriptions WHERE user_id = $1',
      [cryptoUserId]
    );

    const subscription = subResult.rows[0];
    const hasAccess = subscription?.tier === 'elite' || subscription?.has_elliott_addon === true;

    if (!hasAccess) {
      return res.status(403).json({ error: 'Elliott Wave features require Elite tier or Elliott Wave add-on' });
    }

    // Verify ownership of the label
    const existing = await pool.query(
      'SELECT user_id FROM elliott_wave_labels WHERE id = $1',
      [id]
    );

    if (existing.rows.length === 0) {
      return res.status(404).json({ error: 'Label not found' });
    }
    if (existing.rows[0].user_id !== cryptoUserId) {
      return res.status(403).json({ error: 'Not authorized' });
    }

    if (req.method === 'GET') {
      const result = await pool.query(
        'SELECT * FROM elliott_wave_labels WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Label not found' });
      }
      
      const label = result.rows[0];
      return res.json({
        ...label,
        userId: label.user_id,
        patternType: label.pattern_type,
        fibonacciMode: label.fib_mode,
        isComplete: label.is_confirmed,
        validationStatus: label.validation_status,
        validationErrors: label.validation_errors,
        isAutoGenerated: label.is_auto_generated,
        createdAt: label.created_at,
        updatedAt: label.updated_at,
      });
    }

    if (req.method === 'PATCH') {
      const { points, fibonacciMode, validationResult, isComplete, degree } = req.body;
      
      // Build update query dynamically
      const updates: string[] = ['updated_at = NOW()'];
      const values: any[] = [];
      let paramIndex = 1;
      
      if (points !== undefined) {
        updates.push(`points = $${paramIndex++}`);
        values.push(JSON.stringify(points));
      }
      if (fibonacciMode !== undefined) {
        updates.push(`fib_mode = $${paramIndex++}`);
        values.push(fibonacciMode);
      }
      if (isComplete !== undefined) {
        updates.push(`is_confirmed = $${paramIndex++}`);
        values.push(isComplete);
      }
      if (degree !== undefined) {
        updates.push(`degree = $${paramIndex++}`);
        values.push(degree);
      }
      if (validationResult !== undefined) {
        updates.push(`validation_status = $${paramIndex++}`);
        values.push(validationResult?.isValid !== false ? 'valid' : 'warning');
        updates.push(`validation_errors = $${paramIndex++}`);
        values.push(validationResult?.errors || []);
      }
      
      values.push(id);
      
      const result = await pool.query(
        `UPDATE elliott_wave_labels SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
        values
      );
      
      const updated = result.rows[0];
      return res.json({
        ...updated,
        userId: updated.user_id,
        patternType: updated.pattern_type,
        fibonacciMode: updated.fib_mode,
        isComplete: updated.is_confirmed,
        validationStatus: updated.validation_status,
        validationErrors: updated.validation_errors,
        isAutoGenerated: updated.is_auto_generated,
        createdAt: updated.created_at,
        updatedAt: updated.updated_at,
      });
    }

    if (req.method === 'DELETE') {
      await pool.query('DELETE FROM elliott_wave_labels WHERE id = $1', [id]);
      return res.json({ success: true });
    }

    return res.status(405).json({ error: 'Method not allowed' });

  } catch (error: any) {
    console.error('Error with Elliott Wave label:', error);
    return res.status(500).json({ error: error.message });
  } finally {
    if (pool) {
      try {
        await pool.end();
      } catch (e) {
        console.error('Error closing db connection:', e);
      }
    }
  }
}
