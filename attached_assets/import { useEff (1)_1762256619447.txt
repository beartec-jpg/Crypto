import { useEffect, useRef, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { createChart, ColorType, CrosshairMode, IChartApi, CandlestickSeries, LineSeries, HistogramSeries } from 'lightweight-charts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Loader2, Lock, TrendingUp } from "lucide-react";
import { Link } from 'wouter';
import { useAuth } from '@/hooks/useAuth';

interface MultiEMAData {
  symbol: string;
  period: string;
  interval: string;
  trend: 'bull' | 'bear' | 'neutral';
  candlestick: Array<{
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
  }>;
  volume: Array<{
    time: number;
    value: number;
  }>;
  short: {
    length: number;
    score: number;
    bull_touches: number;
    bear_touches: number;
    ema: Array<{
      time: number;
      value: number;
    }>;
  };
  medium: {
    length: number;
    score: number;
    bull_touches: number;
    bear_touches: number;
    ema: Array<{
      time: number;
      value: number;
    }>;
  };
  long: {
    length: number;
    score: number;
    bull_touches: number;
    bear_touches: number;
    ema: Array<{
      time: number;
      value: number;
    }>;
  };
  adaptive: {
    short: {
      length: number;
      score: number;
      bull_touches: number;
      bear_touches: number;
      ema: Array<{
        time: number;
        value: number;
      }>;
    };
    medium: {
      length: number;
      score: number;
      bull_touches: number;
      bear_touches: number;
      ema: Array<{
        time: number;
        value: number;
      }>;
    };
    long: {
      length: number;
      score: number;
      bull_touches: number;
      bear_touches: number;
      ema: Array<{
        time: number;
        value: number;
      }>;
    };
  };
}

interface MarketStructureData {
  symbol: string;
  period: string;
  interval: string;
  mode: 'present' | 'historical';
  swing_highs: Array<{
    index: number;
    time: number;
    price: number;
  }>;
  swing_lows: Array<{
    index: number;
    time: number;
    price: number;
  }>;
  market_structure: Array<{
    type: 'HH' | 'HL' | 'LH' | 'LL';
    time: number;
    price: number;
    index: number;
  }>;
  fvgs: Array<{
    type: 'bullish' | 'bearish';
    top: number;
    bottom: number;
    start_time: number;
    end_time: number;
    current_time: number;
    mitigated?: boolean;
    size?: number;
  }>;
  bos_choch: Array<{
    type: 'BOS' | 'ChoCh';
    direction: 'bullish' | 'bearish';
    time: number;
    price: number;
    broken_level: number;
  }>;
  stats?: {
    total_structure_points: number;
    total_bos_choch: number;
    total_fvgs: number;
    active_fvgs: number;
    bullish_fvgs: number;
    bearish_fvgs: number;
  };
}

interface OrderflowData {
  symbol: string;
  period: string;
  interval: string;
  footprint: Array<{
    time: number;
    bidVol: number[];
    askVol: number[];
    prices: number[];
    delta: number;
  }>;
  cvd: Array<{
    time: number;
    value: number;
    color: 'green' | 'red';
  }>;
  vrvp: {
    poc: number;
    vah: number;
    val: number;
    profile: Array<{
      price: number;
      volume: number;
    }>;
  };
  vwap: Array<{
    time: number;
    value: number;
    upperBand: number;
    lowerBand: number;
  }>;
  divergences: Array<{
    time: number;
    type: 'bullish' | 'bearish';
    poi: number;
  }>;
}

export default function CryptoChart() {
  const { user, isLoading: authLoading, isAuthenticated } = useAuth();
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);

  const [symbol, setSymbol] = useState('XRP-USD');
  const [period, setPeriod] = useState('1mo');
  const [interval, setInterval] = useState('15m');
  
  // Pattern visibility toggles
  const [showStructure, setShowStructure] = useState(true);
  const [showFVG, setShowFVG] = useState(true);
  const [showBOS, setShowBOS] = useState(true);
  const [showFootprint, setShowFootprint] = useState(true);
  const [showCVD, setShowCVD] = useState(true);
  const [showVRVP, setShowVRVP] = useState(true);
  const [showVWAP, setShowVWAP] = useState(true);
  const [showDivergences, setShowDivergences] = useState(true);
  
  // Market structure filtering options
  const [structureMode, setStructureMode] = useState<'present' | 'historical'>('present');
  const [minBosPercent, setMinBosPercent] = useState(1.0);
  const [fvgFilter, setFvgFilter] = useState(true);

  // Validation helper for period/interval combinations
  const isValidCombination = (p: string, i: string): boolean => {
    if (i === '1m' || i === '5m') {
      return p === '1d' || p === '5d';
    }
    if (i === '15m' || i === '1h') {
      return p === '1d' || p === '5d' || p === '1mo';
    }
    return true;
  };

  const getValidationMessage = (): string | null => {
    if (!isValidCombination(period, interval)) {
      if (interval === '1m' || interval === '5m') {
        return `${interval} intervals only work with 1 Day or 5 Days periods`;
      }
      if (interval === '15m' || interval === '1h') {
        return `${interval} intervals only work with periods up to 1 Month (Yahoo Finance limitation)`;
      }
    }
    return null;
  };

  const validationMessage = getValidationMessage();

  // Fetch multi-EMA data
  const { data, isLoading, error, refetch } = useQuery<MultiEMAData>({
    queryKey: ['/api/crypto/multi-ema', symbol, period, interval],
    queryFn: async () => {
      const params = new URLSearchParams({ symbol, period, interval });
      const res = await fetch(`/api/crypto/multi-ema?${params}`, {
        credentials: 'include',
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`${res.status}: ${text}`);
      }
      return res.json();
    },
    enabled: validationMessage === null && isAuthenticated,
    retry: false,
  });

  // Fetch market structure data
  const { data: structureData, isLoading: structureLoading } = useQuery<MarketStructureData>({
    queryKey: ['/api/crypto/market-structure', symbol, period, interval, structureMode, minBosPercent, fvgFilter],
    queryFn: async () => {
      const params = new URLSearchParams({ 
        symbol, 
        period, 
        interval,
        mode: structureMode,
        minBosPercent: minBosPercent.toString(),
        fvgFilter: fvgFilter.toString()
      });
      const res = await fetch(`/api/crypto/market-structure?${params}`, {
        credentials: 'include',
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`${res.status}: ${text}`);
      }
      return res.json();
    },
    enabled: validationMessage === null && isAuthenticated,
    retry: false,
  });

  // Fetch orderflow data
  const { data: orderflowData, isLoading: orderflowLoading } = useQuery<OrderflowData>({
    queryKey: ['/api/crypto/orderflow', symbol, period, interval],
    queryFn: async () => {
      const params = new URLSearchParams({ symbol, period, interval });
      const res = await fetch(`/api/crypto/orderflow?${params}`, {
        credentials: 'include',
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`${res.status}: ${text}`);
      }
      return res.json();
    },
    enabled: validationMessage === null && isAuthenticated,
    retry: false,
  });

  // Check for 403 Forbidden error
  const isForbidden = error && (error as any).message?.includes('403');

  // Render chart effect
  useEffect(() => {
    if (!chartContainerRef.current || !data) return;

    const chart = createChart(chartContainerRef.current, {
      layout: {
        background: { type: ColorType.Solid, color: '#1E293B' },
        textColor: '#D1D5DB',
      },
      grid: {
        vertLines: { color: '#334155' },
        horzLines: { color: '#334155' },
      },
      rightPriceScale: {
        borderColor: '#334155',
      },
      timeScale: {
        borderColor: '#334155',
        timeVisible: true,
        secondsVisible: false,
      },
      crosshair: {
        mode: CrosshairMode.Normal,
      },
      width: chartContainerRef.current.clientWidth,
      height: 500,
    });

    chartRef.current = chart;

    // Candlestick
    const candlestickSeries = chart.addSeries(CandlestickSeries, {
      upColor: '#10B981',
      downColor: '#EF4444',
      borderUpColor: '#10B981',
      borderDownColor: '#EF4444',
      wickUpColor: '#10B981',
      wickDownColor: '#EF4444',
    });
    candlestickSeries.setData(data.candlestick);

    // EMAs...
    // (Keep existing EMA code)

    // Market Structure...
    // (Keep existing structure code)

    // Orderflow visualization if data available
    if (orderflowData) {
      // CVD Histogram
      if (showCVD) {
        const cvdSeries = chart.addSeries(HistogramSeries, {
          color: '#FFFFFF',
          priceFormat: { type: 'volume' },
          priceScaleId: 'cvd', // Separate scale if needed
        });
        cvdSeries.setData(orderflowData.cvd.map(item => ({
          time: item.time,
          value: item.value,
          color: item.color === 'green' ? '#10B981' : '#EF4444'
        })));
      }

      // VRVP Profile (side histogram)
      if (showVRVP) {
        const vrvpSeries = chart.addSeries(HistogramSeries, {
          priceScaleId: 'right',
          color: '#FFD700', // Yellow for POC
        });
        vrvpSeries.setData(orderflowData.vrvp.profile.map(p => ({
          time: data.candlestick[data.candlestick.length - 1].time, // Right side
          value: p.volume,
          color: p.price === orderflowData.vrvp.poc ? '#FFD700' : '#808080'
        })));

        // VA lines
        const vahLine = chart.addSeries(LineSeries, { color: '#FF69B4' });
        vahLine.setData([{ time: data.candlestick[0].time, value: orderflowData.vrvp.vah }, { time: data.candlestick[data.candlestick.length - 1].time, value: orderflowData.vrvp.vah }]);

        const valLine = chart.addSeries(LineSeries, { color: '#FF69B4' });
        valLine.setData([{ time: data.candlestick[0].time, value: orderflowData.vrvp.val }, { time: data.candlestick[data.candlestick.length - 1].time, value: orderflowData.vrvp.val }]);
      }

      // VWAP
      if (showVWAP) {
        const vwapSeries = chart.addSeries(LineSeries, { color: '#00BFFF' });
        vwapSeries.setData(orderflowData.vwap.map(item => ({ time: item.time, value: item.value })));

        const upperBand = chart.addSeries(LineSeries, { color: '#00BFFF', lineStyle: 2 });
        upperBand.setData(orderflowData.vwap.map(item => ({ time: item.time, value: item.upperBand })));

        const lowerBand = chart.addSeries(LineSeries, { color: '#00BFFF', lineStyle: 2 });
        lowerBand.setData(orderflowData.vwap.map(item => ({ time: item.time, value: item.lowerBand })));
      }

      // Footprint - Use custom rendering or histogram per bar (simplified)
      if (showFootprint) {
        orderflowData.footprint.forEach(fp => {
          const bidHist = chart.addSeries(HistogramSeries, { priceScaleId: 'left', color: '#EF4444' });
          bidHist.setData(fp.prices.map((p, i) => ({ time: fp.time, value: fp.bidVol[i], color: '#EF4444' })));

          const askHist = chart.addSeries(HistogramSeries, { priceScaleId: 'left', color: '#10B981' });
          askHist.setData(fp.prices.map((p, i) => ({ time: fp.time, value: fp.askVol[i], color: '#10B981' })));
        });
      }

      // Divergences markers
      if (showDivergences) {
        orderflowData.divergences.forEach(div => {
          candlestickSeries.setMarkers([{
            time: div.time,
            position: div.type === 'bullish' ? 'belowBar' : 'aboveBar',
            color: div.type === 'bullish' ? '#10B981' : '#EF4444',
            shape: 'circle',
            text: div.type.charAt(0).toUpperCase()
          }]);
        });
      }
    }

    chart.timeScale().fitContent();

    const handleResize = () => {
      if (chartContainerRef.current && chartRef.current) {
        chartRef.current.applyOptions({ width: chartContainerRef.current.clientWidth });
      }
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      try {
        chart.remove();
      } catch (e) {}
    };
  }, [data, structureData, orderflowData, showStructure, showFVG, showBOS, showFootprint, showCVD, showVRVP, showVWAP, showDivergences]);

  // ... (Keep existing auth/loading/error renders)

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 py-8">
      <div className="container mx-auto px-4">
        {/* Header */}
        <div className="mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-4xl font-bold text-white mb-2 flex items-center gap-2">
                <TrendingUp className="h-8 w-8" />
                Multi-Timeframe EMA Analysis with Orderflow
              </h1>
              <p className="text-gray-300">
                Find optimal EMAs and orderflow signals
              </p>
            </div>
            <Link href="/">
              <Button variant="outline">
                ‚Üê Back to Home
              </Button>
            </Link>
          </div>
        </div>

        {/* Controls - Add orderflow toggles */}
        <Card className="mb-6 bg-slate-800 border-slate-700">
          <CardHeader>
            <CardTitle className="text-white">Chart Settings</CardTitle>
          </CardHeader>
          <CardContent className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Existing selects */}
            {/* ... */}

            {/* Orderflow toggles */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label className="text-gray-300">Footprint</Label>
                <Switch checked={showFootprint} onCheckedChange={setShowFootprint} />
              </div>
              <div className="flex items-center justify-between">
                <Label className="text-gray-300">CVD</Label>
                <Switch checked={showCVD} onCheckedChange={setShowCVD} />
              </div>
              <div className="flex items-center justify-between">
                <Label className="text-gray-300">VRVP</Label>
                <Switch checked={showVRVP} onCheckedChange={setShowVRVP} />
              </div>
              <div className="flex items-center justify-between">
                <Label className="text-gray-300">VWAP</Label>
                <Switch checked={showVWAP} onCheckedChange={setShowVWAP} />
              </div>
              <div className="flex items-center justify-between">
                <Label className="text-gray-300">Divergences</Label>
                <Switch checked={showDivergences} onCheckedChange={setShowDivergences} />
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Chart Container */}
        <Card className="bg-slate-800 border-slate-700 overflow-hidden">
          <div ref={chartContainerRef} className="w-full h-[500px]" />
        </Card>

        {/* Loading/Error States */}
        {isLoading || structureLoading || orderflowLoading ? (
          <div className="text-center mt-4">
            <Loader2 className="h-8 w-8 animate-spin text-blue-500 mx-auto" />
            <p className="text-gray-300 mt-2">Analyzing data...</p>
          </div>
        ) : null}

        {/* EMA Results Table */}
        {data && (
          <Card className="mt-6 bg-slate-800 border-slate-700">
            <CardHeader>
              <CardTitle className="text-white">Optimal EMA Analysis</CardTitle>
            </CardHeader>
            <CardContent>
              {/* Existing EMA table */}
              {/* Add orderflow summary table */}
              {orderflowData && (
                <div className="mt-4">
                  <h3 className="text-lg font-semibold text-white mb-2">Orderflow Summary</h3>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className="p-4 bg-slate-700 rounded-lg">
                      <p className="text-gray-300">VRVP POC: {orderflowData.vrvp.poc.toFixed(4)}</p>
                      <p className="text-gray-300">VAH: {orderflowData.vrvp.vah.toFixed(4)}</p>
                      <p className="text-gray-300">VAL: {orderflowData.vrvp.val.toFixed(4)}</p>
                    </div>
                    <div className="p-4 bg-slate-700 rounded-lg">
                      <p className="text-gray-300">Divergences Detected: {orderflowData.divergences.length}</p>
                      <p className="text-gray-300">Bullish: {orderflowData.divergences.filter(d => d.type === 'bullish').length}</p>
                      <p className="text-gray-300">Bearish: {orderflowData.divergences.filter(d => d.type === 'bearish').length}</p>
                    </div>
                    {/* Add more if needed */}
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
}