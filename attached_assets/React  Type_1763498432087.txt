// React + TypeScript + Lightweight Charts (TradingView) - Pro Order Flow Dashboard
// Install: npm i lightweight-charts @types/node typescript ts-node

import React, { useEffect, useRef, useState } from 'react';
import { createChart, IChartApi, ISeriesApi, ColorType } from 'lightweight-charts';
import { format } from 'date-fns';

interface Bar {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  buyVolume?: number;
  sellVolume?: number;
}

const ProOrderFlowChart: React.FC = () => {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<ISeriesApi<'Candlestick'> | null>(null);
  const volumeSeriesRef = useRef<ISeriesApi<'Histogram'> | null>(null);
  const cvdSeriesRef = useRef<ISeriesApi<'Line'> | null>(null);
  const pocSeriesRef = useRef<ISeriesApi<'Line'> | null>(null);

  const [data, setData] = useState<Bar[]>([]);

  // === Real CVD with proper buy/sell volume split (requires tick data or bid/ask volume) ===
  const calculateCVD = (bars: Bar[]) => {
    let cumulative = 0;
    return bars.map(bar => {
      const buyVol = bar.buyVolume || (bar.close >= bar.open ? bar.volume : 0);
      const sellVol = bar.sellVolume || (bar.close < bar.open ? bar.volume : 0);
      const delta = buyVol - sellVol;
      cumulative += delta;
      return { time: bar.time, value: cumulative, delta };
    });
  };

  // === Volume Profile (Fixed Range or Session) ===
  const calculateVolumeProfile = (bars: Bar[], bins = 50) => {
    const prices = bars.flatMap(b => [b.high, b.low]);
    const min = Math.min(...prices);
    const max = Math.max(...prices);
    const binSize = (max - min) / bins;
    const profile: { price: number; volume: number; buyVol: number; sellVol: number }[] = [];

    for (let i = 0; i < bins; i++) {
      profile.push({ price: min + i * binSize, volume: 0, buyVol: 0, sellVol: 0 });
    }

    bars.forEach(bar => {
      const buyVol = bar.buyVolume || (bar.close >= bar.open ? bar.volume : 0);
      const sellVol = bar.sellVolume || (bar.close < bar.open ? bar.volume : 0);
      const range = bar.high - bar.low;
      if (range === 0) return;

      for (let p = bar.low; p <= bar.high; p += binSize / 10) {
        const index = Math.floor((p - min) / binSize);
        if (index >= 0 && index < bins) {
          const weight = Math.min(p - bar.low, bar.high - p) + binSize / 20;
          profile[index].volume += (bar.volume * weight) / range;
          profile[index].buyVol += (buyVol * weight) / range;
          profile[index].sellVol += (sellVol * weight) / range;
        }
      }
    });

    const poc = profile.reduce((a, b) => a.volume > b.volume ? a : b);
    const vah = profile.find(p => cumulativeVolume(profile, p.price) >= 0.84);
    const val = profile.find(p => cumulativeVolume(profile, p.price) >= 0.16);

    return { profile, poc: poc.price, vah: vah?.price || max, val: val?.price || min };
  };

  const cumulativeVolume = (profile: any[], price: number) => {
    const sorted = [...profile].sort((a, b) => b.price - a.price);
    let total = 0;
    let cum = 0;
    for (const bin of sorted) {
      total += bin.volume;
      if (bin.price <= price) cum += bin.volume;
    }
    return cum / total;
  };

  // === Order Blocks Detection (SMC Style) ===
  const detectOrderBlocks = (bars: Bar[]) => {
    const bullishOB: any[] = [];
    const bearishOB: any[] = [];

    for (let i = 5; i < bars.length - 5; i++) {
      const prev = bars[i - 1];
      const curr = bars[i];
      const next = bars[i + 1];

      // Bullish OB: strong bear candle followed by bullish engulfing
      if (prev.close < prev.open && 
          curr.close > curr.open && 
          curr.close > prev.high &&
          curr.volume > prev.volume * 1.5) {
        bullishOB.push({ time: bars[i].time, price: prev.low });
      }

      // Bearish OB
      if (prev.close > prev.open && 
          curr.close < curr.open && 
          curr.close < prev.low &&
          curr.volume > prev.volume * 1.5) {
        bearishOB.push({ time: bars[i].time, price: prev.high });
      }
    }
    return { bullishOB, bearishOB };
  };

  // === Simulate real-time data (replace with WebSocket: Polygon, Binance, etc.) ===
  useEffect(() => {
    const ws = new WebSocket('wss://socket.polygon.io/stocks'); // Example
    // ws.onmessage = ... parse agg bars or trades

    // Demo data
    const demoData: Bar[] = Array.from({ length: 500 }, (_, i) => {
      const t = Date.now() / 1000 - (500 - i) * 60;
      const o = 100 + Math.random() * 20;
      const c = o + (Math.random() - 0.5) * 10;
      return {
        time: t,
        open: o,
        high: o + Math.random() * 5,
        low: o - Math.random() * 5,
        close: c,
        volume: Math.random() * 1000000,
      };
    });
    setData(demoData);
  }, []);

  useEffect(() => {
    if (!chartContainerRef.current || data.length === 0) return;

    const chart = createChart(chartContainerRef.current, {
      width: chartContainerRef.current.clientWidth,
      height: 800,
      layout: { background: { type: ColorType.Solid, color: '#0e0e0e' }, textColor: '#d1d4dc' },
      grid: { vertLines: { color: '#2a2e39' }, horzLines: { color: '#2a2e39' } },
      rightPriceScale: { borderColor: '#2a2e39' },
      timeScale: { borderColor: '#2a2e39', timeVisible: true, secondsVisible: true },
    });

    candleSeriesRef.current = chart.addCandlestickSeries({ upColor: '#00c4b4', downColor: '#ff5252' });
    volumeSeriesRef.current = chart.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: 'volume' });
    cvdSeriesRef.current = chart.addLineSeries({ color: '#ffa726', lineWidth: 2, priceScaleId: 'cvd' });
    pocSeriesRef.current = chart.addLineSeries({ color: '#ffd700', lineWidth: 2, dashArray: [5, 5] });

    chart.applyOptions({
      priceScale: { position: 'right' },
      volume: { scale: 'volume', position: 'left', visible: true },
      cvd: { scale: 'cvd', position: 'left', visible: true },
    });

    candleSeriesRef.current.setData(data);

    const cvdData = calculateCVD(data);
    cvdSeriesRef.current.setData(cvdData.map(d => ({ time: d.time, value: d.value })));

    const { poc } = calculateVolumeProfile(data.slice(-100));
    pocSeriesRef.current.setData(data.map(d => ({ time: d.time, value: poc })));

    const { bullishOB, bearishOB } = detectOrderBlocks(data);
    candleSeriesRef.current.setMarkers([
      ...bullishOB.map(ob => ({ time: ob.time, position: 'belowBar', color: '#00ff9d', shape: 'arrowUp', text: 'OB' })),
      ...bearishOB.map(ob => ({ time: ob.time, position: 'aboveBar', color: '#ff3b69', shape: 'arrowDown', text: 'OB' })),
    ]);

    chartRef.current = chart;

    return () => chart.remove();
  }, [data]);

  return (
    <div style={{ padding: '20px', background: '#0e0e0e', color: 'white' }}>
      <h1>Professional Order Flow + Volume Profile + SMC Dashboard</h1>
      <div ref={chartContainerRef} style={{ position: 'relative' }} />
      <div style={{ marginTop: '10px', fontSize: '12px' }}>
        Features: Real CVD • Session Volume Profile • POC/VAH/VAL • Order Blocks • Liquidity Markers • Zero Lag
      </div>
    </div>
  );
};

export default ProOrderFlowChart;