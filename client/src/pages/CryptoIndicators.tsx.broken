import { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { createChart, ColorType, IChartApi, CandlestickSeries, LineSeries, HistogramSeries, ISeriesApi } from 'lightweight-charts';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { TrendingUp, TrendingDown, Activity, DollarSign, Loader2, Bell, ChevronDown, ChevronUp, Zap } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import bearTecLogo from '@assets/Screenshot_20250823-074823_1755931718570-jLy5P9_5_1762781446275.png';
import cryptoStamp from '@assets/20251111_235227_0000_1762905164353.png';
import grokLogo from '@assets/Grok_Full_Logomark_Light_1763287603908.png';

interface CandleData {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface VWAPData {
  time: number;
  value: number;
}

interface FVG {
  time: number;
  lower: number;
  upper: number;
  type: 'bullish' | 'bearish';
  volumeScore?: number;
  deltaScore?: number;
  isHighValue?: boolean;
}

interface FootprintData {
  time: number;
  bidVol: number[];
  askVol: number[];
  prices: number[];
  delta: number;
}

interface BOS {
  swingTime: number;
  swingPrice: number;
  breakTime: number;
  breakIndex: number;
  type: 'bullish' | 'bearish';
  isLiquidityGrab?: boolean;
  sweptLevel?: 'high' | 'low'; // Track which level was swept for reversals
}

interface CHoCH {
  swingTime: number;
  swingPrice: number;
  breakTime: number;
  breakIndex: number;
  type: 'bullish' | 'bearish';
  isLiquidityGrab?: boolean;
  sweptLevel?: 'high' | 'low'; // Track which level was swept for reversals
}

// Bot-specific TP/SL Configuration Types
type TPType = 'structure' | 'trailing' | 'atr' | 'fixed_rr' | 'vwap' | 'ema';
type SLType = 'structure' | 'fixed' | 'atr';

interface TradeSignal {
  id: string;
  time: number;
  type: 'LONG' | 'SHORT';
  strategy: 'liquidity_grab' | 'choch_fvg' | 'vwap_rejection' | 'structure_break' | 'rs_flip' | 'bos_trend';
  entry: number;
  stopLoss: number;
  tp1: number;
  tp2: number;
  tp3: number;
  tp1Type: TPType;
  tp2Type: TPType;
  tp3Type: TPType;
  tp1Config?: TPConfig; // Full TP1 configuration (for exit modes and EMA settings)
  tp2Config?: TPConfig; // Full TP2 configuration
  tp3Config?: TPConfig; // Full TP3 configuration
  riskReward1: number;
  riskReward2: number;
  riskReward3: number;
  quantity: number;
  reason: string;
  active: boolean;
  trailingActive?: boolean; // Track if trailing TP is activated
  entryEMAState?: 'fast_above_slow' | 'fast_below_slow'; // Track EMA relationship at entry for crossover detection
}

interface Position {
  type: 'long' | 'short';
  entry: number;
  stopLoss: number;
  tp1: number;
  tp2: number;
  tp3: number;
  quantity: number;
  signalId: string;
}

interface MarketAlert {
  id: string;
  time: number;
  type: 'BOS' | 'CHoCH' | 'Liquidity Sweep' | 'FVG' | 'FVG Entry' | 'VWAP Bounce' | 'VWAP Cross' | 'Trendline Breakout' | 'Trendline Rejection';
  direction: 'bullish' | 'bearish';
  price: number;
  description: string;
}

interface BacktestTrade {
  id: string;
  entryTime: number;
  exitTime: number;
  direction: 'long' | 'short';
  strategy: string;
  entry: number;
  exit: number;
  stopLoss: number;
  tp1: number;
  tp2: number;
  tp3: number;
  outcome: 'TP1' | 'TP2' | 'TP3' | 'SL' | 'Breakeven' | 'EMA Exit';
  rr: number;
  profitLoss: number;
  winner: boolean;
}

interface BacktestResults {
  trades: BacktestTrade[];
  totalTrades: number;
  winners: number;
  losers: number;
  winRate: number;
  avgRR: number;
  totalPL: number;
  profitFactor: number;
  accountSize: number;
  riskPerTrade: number;
  avgPositionSize: number;
  finalBalance: number;
  returnPercent: number;
}

interface TPConfig {
  type: TPType;
  atrMultiplier?: number;        // For ATR-based
  fixedRR?: number;              // For fixed R:R
  vwapPeriod?: 'session' | 'daily' | 'weekly' | 'monthly' | 'rolling10' | 'rolling20' | 'rolling50'; // For VWAP exit
  vwapOffset?: number;           // % offset from VWAP
  vwapExitMode?: 'touch' | 'cross'; // VWAP exit mode: touch = price touches VWAP, cross = price crosses VWAP
  projectionMultiplier?: number; // For projection-based
  emaFast?: number;              // For EMA exit (fast period) - strategy-specific
  emaSlow?: number;              // For EMA exit (slow period) - strategy-specific
  emaExitMode?: 'touch' | 'crossover'; // EMA exit mode: touch = price touches EMA, crossover = EMAs cross each other
  swingLength?: number;          // For structure-based TP
  trailingSwingLength?: number;  // For trailing TP - which swing to trail
  positionPercent: number;       // % of position to close at this TP
}

interface SLConfig {
  type: SLType;
  atrMultiplier?: number;        // For ATR-based
  fixedDistance?: number;        // For fixed distance
  swingLength?: number;          // For structure-based SL swing length
  useNearestSwing?: boolean;     // For structure-based
}

interface BotTPSLConfig {
  numTPs: 1 | 2 | 3;
  tp1: TPConfig;
  tp2?: TPConfig;
  tp3?: TPConfig;
  sl: SLConfig;
}

interface AutoBacktestResult {
  config: BotTPSLConfig;
  results: BacktestResults;
  configDescription: string;
  swingLength: number;
  wickRatio: number;
  confirmCandles: number;
  useWickFilter: boolean;
  useConfirmCandles: boolean;
  trendFilter: 'ema' | 'structure' | 'both' | 'none';
  allowedDirections: 'both' | 'long' | 'short';
}

interface AutoBacktestTestParams {
  testTP1Types: TPType[];
  testTP2Types: TPType[];
  testTP3Types: TPType[];
  testSLTypes: SLType[];
  testATRMultipliers: number[];
  testRRRatios: number[];
  testProjectionMultipliers: number[];
}

export default function CryptoIndicators() {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<ISeriesApi<'Candlestick'> | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const { toast } = useToast();

  const [symbol, setSymbol] = useState('XRPUSDT');
  const [interval, setInterval] = useState('15m');
  const [candles, setCandles] = useState<CandleData[]>([]);
  const [loading, setLoading] = useState(true);
  const [chartReady, setChartReady] = useState(false);

  // VWAP toggles
  const [showVWAPSession, setShowVWAPSession] = useState(false);
  const [showVWAPDaily, setShowVWAPDaily] = useState(false);
  const [showVWAPWeekly, setShowVWAPWeekly] = useState(true);
  const [showVWAPMonthly, setShowVWAPMonthly] = useState(false);
  const [showVWAPRolling10, setShowVWAPRolling10] = useState(false);
  const [showVWAPRolling20, setShowVWAPRolling20] = useState(false);
  const [showVWAPRolling50, setShowVWAPRolling50] = useState(false);

  // Indicator toggles
  const [showFVG, setShowFVG] = useState(false);
  const [showBOS, setShowBOS] = useState(true);
  const [showCHoCH, setShowCHoCH] = useState(true);
  const [showSwingPivots, setShowSwingPivots] = useState(false);
  const [swingPivotLength, setSwingPivotLength] = useState(10);
  const [swingPivotLengthInput, setSwingPivotLengthInput] = useState('10');
  const [showHighValueOnly, setShowHighValueOnly] = useState(false);
  const [showChartLabels, setShowChartLabels] = useState(false);
  const [showAutoTrendlines, setShowAutoTrendlines] = useState(false);
  const [trendlineMinTouches, setTrendlineMinTouches] = useState(2);
  const [trendlineMinTouchesInput, setTrendlineMinTouchesInput] = useState('2');
  const [trendlineTolerance, setTrendlineTolerance] = useState(0.002); // 0.2% tolerance
  const [trendlineToleranceInput, setTrendlineToleranceInput] = useState('0.2');
  const [trendlinePivotLength, setTrendlinePivotLength] = useState(10);
  const [trendlinePivotLengthInput, setTrendlinePivotLengthInput] = useState('10');
  
  // EMA settings
  const [showEMA, setShowEMA] = useState(true);
  const [emaFastPeriod, setEmaFastPeriod] = useState(10);
  const [emaSlowPeriod, setEmaSlowPeriod] = useState(40);
  const [emaFastInput, setEmaFastInput] = useState('10');
  const [emaSlowInput, setEmaSlowInput] = useState('40');
  
  // ========== CHART DISPLAY SETTINGS (independent from strategy settings) ==========
  // BOS swing length: 5 for tighter swing detection, CHoCH swing length: 20 for broader trend changes
  const [chartBosSwingLength, setChartBosSwingLength] = useState(5);
  const [chartBosSwingLengthInput, setChartBosSwingLengthInput] = useState('5');
  const [chartChochSwingLength, setChartChochSwingLength] = useState(20);
  const [chartChochSwingLengthInput, setChartChochSwingLengthInput] = useState('20');
  const [chartLiquiditySweepSwingLength, setChartLiquiditySweepSwingLength] = useState(20);
  const [chartLiquiditySweepSwingLengthInput, setChartLiquiditySweepSwingLengthInput] = useState('20');
  const [chartWickRatio, setChartWickRatio] = useState(150);
  const [chartWickRatioInput, setChartWickRatioInput] = useState('150');
  // FIXED ISSUE 5: Set to 0 for immediate BOS detection (no confirmation delay)
  const [chartConfirmCandles, setChartConfirmCandles] = useState(0);
  const [chartConfirmCandlesInput, setChartConfirmCandlesInput] = useState('0');
  const [chartUseWickFilter, setChartUseWickFilter] = useState(false);
  const [chartUseConfirmCandles, setChartUseConfirmCandles] = useState(false);  // FALSE = immediate detection
  
  // Legacy SMC Settings (deprecated - use chart settings or strategy settings instead)
  const [swingLength, setSwingLength] = useState(15);
  const [liqGrabCandles, setLiqGrabCandles] = useState(2);
  const [wickToBodyRatio, setWickToBodyRatio] = useState(150); // Wick must be 150% of body (1.5x)
  const [swingLengthInput, setSwingLengthInput] = useState('15');
  const [liqGrabInput, setLiqGrabInput] = useState('2');
  const [wickRatioInput, setWickRatioInput] = useState('150');
  const [fvgVolumeThreshold, setFvgVolumeThreshold] = useState(1.5); // 1.5x average volume

  // Bot state
  const [botEnabled, setBotEnabled] = useState(false);
  const [bias, setBias] = useState<'bullish' | 'bearish' | null>(null);
  const [structureTrend, setStructureTrend] = useState<'uptrend' | 'downtrend' | 'ranging' | null>(null);
  const [position, setPosition] = useState<Position | null>(null);
  const [signals, setSignals] = useState<TradeSignal[]>([]);
  const [tradeSignals, setTradeSignals] = useState<TradeSignal[]>([]);
  const [backtestResults, setBacktestResults] = useState<BacktestResults | null>(null);
  const [backtesting, setBacktesting] = useState(false);
  const [currentDelta, setCurrentDelta] = useState(0);
  const [cumDelta, setCumDelta] = useState(0);
  const [deltaHistory, setDeltaHistory] = useState<Array<{ time: string; delta: number; cumDelta: number; isBull: boolean; volume: number; exchanges?: number; confidence?: number; divergence?: boolean }>>([]);

  // AI Market Analysis state
  const [aiAnalysis, setAiAnalysis] = useState<string | null>(null);
  const [aiAnalysisLoading, setAiAnalysisLoading] = useState(false);
  const [aiAnalysisTimestamp, setAiAnalysisTimestamp] = useState<number | null>(null);
  const [aiAnalysisCost, setAiAnalysisCost] = useState<number>(0);
  const [aiAnalysisExpanded, setAiAnalysisExpanded] = useState(false);
  const [lastAnalysisCheck, setLastAnalysisCheck] = useState<number>(0);
  const [footprintData, setFootprintData] = useState<FootprintData[]>([]);
  const [marketAlerts, setMarketAlerts] = useState<MarketAlert[]>([]);
  
  // Multi-exchange orderflow state (always enabled)
  const [useMultiExchange, setUseMultiExchange] = useState(true);
  const [multiExchangeData, setMultiExchangeData] = useState<any>(null);
  const [multiExchangeLoading, setMultiExchangeLoading] = useState(false);
  
  // Refs to ensure auto-refresh always uses current values
  const symbolRef = useRef(symbol);
  const intervalRef = useRef(interval);
  
  useEffect(() => {
    symbolRef.current = symbol;
    intervalRef.current = interval;
  }, [symbol, interval]);
  
  // ========== LIQUIDITY GRAB STRATEGY SETTINGS ==========
  const [stratLiquidityGrab, setStratLiquidityGrab] = useState(false);
  const [liqGrabTrendFilter, setLiqGrabTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('structure');
  const [liqGrabDirectionFilter, setLiqGrabDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  const [liqGrabSwingLength, setLiqGrabSwingLength] = useState(15);
  const [liqGrabSwingLengthInput, setLiqGrabSwingLengthInput] = useState('15');
  const [liqGrabConfirmCandles, setLiqGrabConfirmCandles] = useState(2);
  const [liqGrabConfirmCandlesInput, setLiqGrabConfirmCandlesInput] = useState('2');
  const [liqGrabWickRatio, setLiqGrabWickRatio] = useState(150);
  const [liqGrabWickRatioInput, setLiqGrabWickRatioInput] = useState('150');
  const [liqGrabUseWickFilter, setLiqGrabUseWickFilter] = useState(false);
  const [liqGrabUseConfirmCandles, setLiqGrabUseConfirmCandles] = useState(false);
  const [liqGrabTPSwingLength, setLiqGrabTPSwingLength] = useState(15);
  const [liqGrabTPSwingLengthInput, setLiqGrabTPSwingLengthInput] = useState('15');
  const [liqGrabSLSwingLength, setLiqGrabSLSwingLength] = useState(5);
  const [liqGrabSLSwingLengthInput, setLiqGrabSLSwingLengthInput] = useState('5');
  
  // ========== BOS STRUCTURE STRATEGY SETTINGS ==========
  const [stratBOSTrend, setStratBOSTrend] = useState(false);
  const [bosTrendFilter, setBosTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('none');
  const [bosDirectionFilter, setBosDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  const [bosSwingLength, setBosSwingLength] = useState(5);
  const [bosSwingLengthInput, setBosSwingLengthInput] = useState('5');
  const [bosConfirmCandles, setBosConfirmCandles] = useState(2);
  const [bosConfirmCandlesInput, setBosConfirmCandlesInput] = useState('2');
  const [bosWickRatio, setBosWickRatio] = useState(150);
  const [bosWickRatioInput, setBosWickRatioInput] = useState('150');
  const [bosUseWickFilter, setBosUseWickFilter] = useState(false);
  const [bosUseConfirmCandles, setBosUseConfirmCandles] = useState(false);
  const [bosTPSwingLength, setBosTPSwingLength] = useState(15);
  const [bosTPSwingLengthInput, setBosTPSwingLengthInput] = useState('15');
  const [bosSLSwingLength, setBosSLSwingLength] = useState(5);
  const [bosSLSwingLengthInput, setBosSLSwingLengthInput] = useState('5');
  
  // ========== CHoCH + FVG STRATEGY SETTINGS ==========
  const [stratChochFVG, setStratChochFVG] = useState(false);
  const [chochStructureType, setChochStructureType] = useState<'bos' | 'choch' | 'both'>('bos');
  const [chochTrendFilter, setChochTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('none');
  const [chochDirectionFilter, setChochDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  const [chochSwingLength, setChochSwingLength] = useState(10);
  const [chochSwingLengthInput, setChochSwingLengthInput] = useState('10');
  const [chochFVGVolumeThreshold, setChochFVGVolumeThreshold] = useState(1.0);
  const [chochTPSwingLength, setChochTPSwingLength] = useState(10);
  const [chochTPSwingLengthInput, setChochTPSwingLengthInput] = useState('10');
  const [chochSLSwingLength, setChochSLSwingLength] = useState(5);
  const [chochSLSwingLengthInput, setChochSLSwingLengthInput] = useState('5');
  const [chochUseFVGSizeFilter, setChochUseFVGSizeFilter] = useState(false);
  const [chochFVGMinSizeATR, setChochFVGMinSizeATR] = useState(10); // Percentage of ATR (0-50)
  
  // ========== VWAP REJECTION STRATEGY SETTINGS ==========
  const [stratVWAPRejection, setStratVWAPRejection] = useState(false);
  const [vwapTrendFilter, setVwapTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('structure');
  const [vwapDirectionFilter, setVwapDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  const [vwapType, setVwapType] = useState<'session' | 'daily' | 'weekly' | 'monthly' | 'rolling10' | 'rolling20' | 'rolling50'>('weekly');
  const [vwapThreshold, setVwapThreshold] = useState(0.3);
  const [vwapThresholdInput, setVwapThresholdInput] = useState('0.3');
  const [vwapEntryCandles, setVwapEntryCandles] = useState<'single' | 'double'>('single');
  const [vwapTPSwingLength, setVwapTPSwingLength] = useState(15);
  const [vwapTPSwingLengthInput, setVwapTPSwingLengthInput] = useState('15');
  const [vwapSLSwingLength, setVwapSLSwingLength] = useState(5);
  const [vwapSLSwingLengthInput, setVwapSLSwingLengthInput] = useState('5');
  
  // ========== STRUCTURE BREAK STRATEGY SETTINGS ==========
  const [stratStructureBreak, setStratStructureBreak] = useState(false);
  const [structureTrendFilter, setStructureTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('structure');
  const [structureDirectionFilter, setStructureDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  
  // ========== R/S FLIP STRATEGY SETTINGS ==========
  const [stratRSFlip, setStratRSFlip] = useState(false);
  const [rsFlipTrendFilter, setRsFlipTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('none');
  const [rsFlipDirectionFilter, setRsFlipDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  const [rsFlipRetestCandles, setRsFlipRetestCandles] = useState(20);
  const [rsFlipRetestCandlesInput, setRsFlipRetestCandlesInput] = useState('20');
  const [rsFlipTPSwingLength, setRsFlipTPSwingLength] = useState(15);
  const [rsFlipTPSwingLengthInput, setRsFlipTPSwingLengthInput] = useState('15');
  const [rsFlipSLSwingLength, setRsFlipSLSwingLength] = useState(5);
  const [rsFlipSLSwingLengthInput, setRsFlipSLSwingLengthInput] = useState('5');
  
  // ========== EMA TRADING STRATEGY SETTINGS ==========
  const [stratEMATrading, setStratEMATrading] = useState(false);
  const [emaEntryMode, setEmaEntryMode] = useState<'bounce' | 'cross' | 'trend_trade'>('trend_trade');
  const [emaSinglePeriod, setEmaSinglePeriod] = useState(50);
  const [emaSinglePeriodInput, setEmaSinglePeriodInput] = useState('50');
  const [emaThreshold, setEmaThreshold] = useState(0.3);
  const [emaTradingTPSwingLength, setEmaTradingTPSwingLength] = useState(15);
  const [emaTradingTPSwingLengthInput, setEmaTradingTPSwingLengthInput] = useState('15');
  const [emaTradingSLSwingLength, setEmaTradingSLSwingLength] = useState(5);
  const [emaTradingSLSwingLengthInput, setEmaTradingSLSwingLengthInput] = useState('5');
  const [emaTradingTrendFilter, setEmaTradingTrendFilter] = useState<'ema' | 'structure' | 'both' | 'none'>('none');
  const [emaTradingDirectionFilter, setEmaTradingDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  
  // Legacy global settings (deprecated - keeping for backward compatibility)
  const [trendFilter, setTrendFilter] = useState<'ema' | 'structure' | 'both'>('structure');
  const [trendFilterType, setTrendFilterType] = useState<'ema' | 'structure' | 'both' | 'none'>('structure');
  const [directionFilter, setDirectionFilter] = useState<'bull' | 'bear' | 'both'>('both');
  
  // Risk management (global settings)
  const [accountSize, setAccountSize] = useState(10000);
  const [riskPercent, setRiskPercent] = useState(1);
  
  // ========== BOT-SPECIFIC TP/SL CONFIGURATIONS ==========
  // Liquidity Grab Bot Configuration
  const [liqGrabTPSL, setLiqGrabTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'atr', atrMultiplier: 1.5, positionPercent: 100 },
    tp2: { type: 'structure', positionPercent: 30 },
    tp3: { type: 'atr', atrMultiplier: 2.5, positionPercent: 20 },
    sl: { type: 'atr', atrMultiplier: 1.5 }
  });

  // Auto-Backtest Mode for Liquidity Grab
  const [liqGrabAutoTestMode, setLiqGrabAutoTestMode] = useState(false);
  const [liqGrabAutoTestRunning, setLiqGrabAutoTestRunning] = useState(false);
  const [liqGrabAutoTestProgress, setLiqGrabAutoTestProgress] = useState(0);
  const [liqGrabAutoTestResults, setLiqGrabAutoTestResults] = useState<AutoBacktestResult[]>([]);
  const [liqGrabAutoTestDurations, setLiqGrabAutoTestDurations] = useState<{duration: number, combos: number}[]>([]);
  const [liqGrabAutoTestSortBy, setLiqGrabAutoTestSortBy] = useState<'profit' | 'winRate' | 'trades' | 'avgRR'>('profit');
  
  // Parameter checkboxes for auto-test (Liquidity Grab: Structure, Trailing, EMA, Fixed R:R)
  const [testTP1Structure, setTestTP1Structure] = useState(true);
  const [testTP1Trailing, setTestTP1Trailing] = useState(false);
  const [testTP1EMA, setTestTP1EMA] = useState(false);
  const [testTP1FixedRR, setTestTP1FixedRR] = useState(true);
  
  const [testTP2Structure, setTestTP2Structure] = useState(true);
  const [testTP2Trailing, setTestTP2Trailing] = useState(false);
  const [testTP2EMA, setTestTP2EMA] = useState(false);
  const [testTP2FixedRR, setTestTP2FixedRR] = useState(false);
  
  const [testTP3Structure, setTestTP3Structure] = useState(true);
  const [testTP3Trailing, setTestTP3Trailing] = useState(false);
  const [testTP3EMA, setTestTP3EMA] = useState(false);
  const [testTP3FixedRR, setTestTP3FixedRR] = useState(false);
  
  const [testSLATR, setTestSLATR] = useState(true);
  const [testSLStructure, setTestSLStructure] = useState(true);
  const [testSLFixedDistance, setTestSLFixedDistance] = useState(false);
  
  // Strategy parameter test options
  const [testTrendFilters, setTestTrendFilters] = useState<('ema' | 'structure' | 'both' | 'none')[]>(['structure', 'both']);
  const [testDirections, setTestDirections] = useState<('bull' | 'bear' | 'both')[]>(['both']);
  const [testUseWickFilter, setTestUseWickFilter] = useState<boolean>(true);
  const [testUseConfirmCandles, setTestUseConfirmCandles] = useState<boolean>(true);
  
  // Range inputs for numeric parameters (min, max, step)
  const [swingLengthRange, setSwingLengthRange] = useState({ min: 10, max: 20, step: 5 });
  const [wickRatioRange, setWickRatioRange] = useState({ min: 100, max: 200, step: 50 });
  const [confirmCandlesRange, setConfirmCandlesRange] = useState({ min: 1, max: 3, step: 1 });
  
  // TP/SL parameter ranges
  const [tp1RRRange, setTp1RRRange] = useState({ min: 1.5, max: 3.0, step: 0.5 });
  const [tp1SwingLengthRange, setTp1SwingLengthRange] = useState({ min: 10, max: 20, step: 5 });
  const [tp1TrailingSwingRange, setTp1TrailingSwingRange] = useState({ min: 3, max: 10, step: 2 });
  const [tp1EMAFastRange, setTp1EMAFastRange] = useState({ min: 10, max: 30, step: 10 });
  const [tp1EMASlowRange, setTp1EMASlowRange] = useState({ min: 50, max: 200, step: 50 });
  
  const [tp2RRRange, setTp2RRRange] = useState({ min: 2.0, max: 4.0, step: 0.5 });
  const [tp2SwingLengthRange, setTp2SwingLengthRange] = useState({ min: 15, max: 25, step: 5 });
  const [tp2TrailingSwingRange, setTp2TrailingSwingRange] = useState({ min: 5, max: 15, step: 5 });
  const [tp2EMAFastRange, setTp2EMAFastRange] = useState({ min: 10, max: 30, step: 10 });
  const [tp2EMASlowRange, setTp2EMASlowRange] = useState({ min: 50, max: 200, step: 50 });
  
  const [tp3RRRange, setTp3RRRange] = useState({ min: 3.0, max: 5.0, step: 1.0 });
  const [tp3SwingLengthRange, setTp3SwingLengthRange] = useState({ min: 20, max: 30, step: 5 });
  const [tp3TrailingSwingRange, setTp3TrailingSwingRange] = useState({ min: 10, max: 20, step: 5 });
  const [tp3EMAFastRange, setTp3EMAFastRange] = useState({ min: 10, max: 30, step: 10 });
  const [tp3EMASlowRange, setTp3EMASlowRange] = useState({ min: 50, max: 200, step: 50 });
  
  const [slATRRange, setSlATRRange] = useState({ min: 1.0, max: 2.0, step: 0.5 });
  const [slSwingLengthRange, setSlSwingLengthRange] = useState({ min: 3, max: 10, step: 2 });
  const [slFixedDistanceRange, setSlFixedDistanceRange] = useState({ min: 1.0, max: 3.0, step: 0.5 });
  
  // BOS Structure Bot Configuration
  const [bosTPSL, setBosTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'atr', atrMultiplier: 1.5, positionPercent: 100 },
    tp2: { type: 'structure', positionPercent: 30 },
    tp3: { type: 'atr', atrMultiplier: 2.5, positionPercent: 20 },
    sl: { type: 'atr', atrMultiplier: 1.5 }
  });
  
  // CHoCH + FVG Bot Configuration
  const [chochTPSL, setChochTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'structure', positionPercent: 100 },
    tp2: { type: 'vwap', vwapPeriod: 'weekly', vwapOffset: 0, positionPercent: 30 },
    tp3: { type: 'structure', positionPercent: 20 },
    sl: { type: 'structure' }
  });
  
  // VWAP Trading Bot Configuration
  const [vwapTPSL, setVwapTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'ema', emaFast: 10, emaSlow: 40, emaExitMode: 'crossover', positionPercent: 100 },
    tp2: { type: 'structure', positionPercent: 30 },
    tp3: { type: 'atr', atrMultiplier: 2.5, positionPercent: 20 },
    sl: { type: 'fixed_distance', distancePercent: 2.0 }
  });
  
  // R/S Flip Bot Configuration
  const [rsFlipTPSL, setRsFlipTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'fixed_rr', fixedRR: 2.0, positionPercent: 100 },
    tp2: { type: 'structure', positionPercent: 30 },
    sl: { type: 'structure' } // Use broken trendline as SL by default
  });
  
  // EMA Trading Bot Configuration
  const [emaTradingTPSL, setEmaTradingTPSL] = useState<BotTPSLConfig>({
    numTPs: 1,
    tp1: { type: 'fixed_rr', fixedRR: 2.0, positionPercent: 100 },
    tp2: { type: 'structure', positionPercent: 30 },
    sl: { type: 'atr', atrMultiplier: 1.5 }
  });

  // ========== REPLAY MODE SETTINGS ==========
  const [isReplayMode, setIsReplayMode] = useState(false);
  const [replayIndex, setReplayIndex] = useState(100); // Start with 100 candles visible
  const [replaySpeed, setReplaySpeed] = useState(1); // 1x, 2x, 5x, 10x
  const [isReplayPlaying, setIsReplayPlaying] = useState(false);
  const [fullCandleData, setFullCandleData] = useState<CandleData[]>([]);
  const replayIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // VWAP series refs
  const vwapSeriesRefs = useRef<{
    session?: ISeriesApi<'Line'>;
    daily?: ISeriesApi<'Line'>;
    weekly?: ISeriesApi<'Line'>;
    monthly?: ISeriesApi<'Line'>;
    rolling10?: ISeriesApi<'Line'>;
    rolling20?: ISeriesApi<'Line'>;
    rolling50?: ISeriesApi<'Line'>;
  }>({});

  // EMA series refs
  const emaSeriesRefs = useRef<{
    fast?: ISeriesApi<'Line'>;
    slow?: ISeriesApi<'Line'>;
  }>({});

  // FVG series refs
  const fvgSeriesRefs = useRef<Array<{ upper: ISeriesApi<'Line'>; lower: ISeriesApi<'Line'>; fill: ISeriesApi<'Histogram'>; fvg: FVG }>>([]);

  // BOS and CHoCH line series refs
  const bosSeriesRefs = useRef<Array<ISeriesApi<'Line'>>>([]);
  const chochSeriesRefs = useRef<Array<ISeriesApi<'Line'>>>([]);
  const swingPivotSeriesRefs = useRef<Array<ISeriesApi<'Line'>>>([]);
  const liquiditySweepSeriesRefs = useRef<Array<ISeriesApi<'Line'>>>([]);
  const trendlineSeriesRefs = useRef<Array<ISeriesApi<'Line'>>>([]);
  const tradeMarkerRefs = useRef<Array<any>>([]);
  const structureLabelsRef = useRef<HTMLDivElement | null>(null);

  // Order flow series
  const orderFlowSeriesRef = useRef<ISeriesApi<'Histogram'> | null>(null);
  const cumDeltaSeriesRef = useRef<ISeriesApi<'Line'> | null>(null);

  // Store real delta data from orderflow API
  const [realDeltaData, setRealDeltaData] = useState<Map<number, number>>(new Map());

  // Sync EMA Trading input values to numeric state
  useEffect(() => {
    const val = parseInt(emaSinglePeriodInput);
    if (!isNaN(val) && val >= 5 && val <= 500) {
      setEmaSinglePeriod(val);
    }
  }, [emaSinglePeriodInput]);
  
  // Sync VWAP threshold input to numeric state
  useEffect(() => {
    const val = parseFloat(vwapThresholdInput);
    if (!isNaN(val) && val >= 0.1 && val <= 5) {
      setVwapThreshold(val);
    }
  }, [vwapThresholdInput]);

  useEffect(() => {
    const val = parseInt(emaFastInput);
    if (!isNaN(val) && val >= 5 && val <= 200) {
      setEmaFastPeriod(val);
    }
  }, [emaFastInput]);

  useEffect(() => {
    const val = parseInt(emaSlowInput);
    if (!isNaN(val) && val >= 20 && val <= 500) {
      setEmaSlowPeriod(val);
    }
  }, [emaSlowInput]);

  useEffect(() => {
    const val = parseInt(emaTradingTPSwingLengthInput);
    if (!isNaN(val) && val >= 5 && val <= 50) {
      setEmaTradingTPSwingLength(val);
    }
  }, [emaTradingTPSwingLengthInput]);

  useEffect(() => {
    const val = parseInt(emaTradingSLSwingLengthInput);
    if (!isNaN(val) && val >= 3 && val <= 30) {
      setEmaTradingSLSwingLength(val);
    }
  }, [emaTradingSLSwingLengthInput]);

  // Calculate total combinations for auto-backtest
  const totalCombinations = useMemo(() => {
    if (!liqGrabAutoTestMode) return 0;

    const getRangeCount = (min: number, max: number, step: number) => {
      if (step <= 0 || min > max) return 0;
      return Math.floor((max - min) / step) + 1;
    };

    let count = 1;

    // Strategy parameters
    count *= testTrendFilters.length || 1;
    count *= testDirections.length || 1;
    count *= getRangeCount(swingLengthRange.min, swingLengthRange.max, swingLengthRange.step);
    // Only test wick ratios when wick filter is enabled
    if (testUseWickFilter) {
      count *= getRangeCount(wickRatioRange.min, wickRatioRange.max, wickRatioRange.step);
    }
    // Only test confirm candles when confirm candles is enabled
    if (testUseConfirmCandles) {
      count *= getRangeCount(confirmCandlesRange.min, confirmCandlesRange.max, confirmCandlesRange.step);
    }

    // TP1 parameters (always active if numTPs >= 1)
    if (liqGrabTPSL.numTPs >= 1) {
      let tp1Count = 0;
      if (testTP1Structure) tp1Count += getRangeCount(tp1SwingLengthRange.min, tp1SwingLengthRange.max, tp1SwingLengthRange.step);
      if (testTP1Trailing) tp1Count += getRangeCount(tp1TrailingSwingRange.min, tp1TrailingSwingRange.max, tp1TrailingSwingRange.step);
      if (testTP1EMA) tp1Count += getRangeCount(tp1EMAFastRange.min, tp1EMAFastRange.max, tp1EMAFastRange.step) * getRangeCount(tp1EMASlowRange.min, tp1EMASlowRange.max, tp1EMASlowRange.step);
      if (testTP1FixedRR) tp1Count += getRangeCount(tp1RRRange.min, tp1RRRange.max, tp1RRRange.step);
      count *= tp1Count || 1;
    }

    // TP2 parameters (only if numTPs >= 2)
    if (liqGrabTPSL.numTPs >= 2) {
      let tp2Count = 0;
      if (testTP2Structure) tp2Count += getRangeCount(tp2SwingLengthRange.min, tp2SwingLengthRange.max, tp2SwingLengthRange.step);
      if (testTP2Trailing) tp2Count += getRangeCount(tp2TrailingSwingRange.min, tp2TrailingSwingRange.max, tp2TrailingSwingRange.step);
      if (testTP2EMA) tp2Count += getRangeCount(tp2EMAFastRange.min, tp2EMAFastRange.max, tp2EMAFastRange.step) * getRangeCount(tp2EMASlowRange.min, tp2EMASlowRange.max, tp2EMASlowRange.step);
      if (testTP2FixedRR) tp2Count += getRangeCount(tp2RRRange.min, tp2RRRange.max, tp2RRRange.step);
      count *= tp2Count || 1;
    }

    // TP3 parameters (only if numTPs >= 3)
    if (liqGrabTPSL.numTPs >= 3) {
      let tp3Count = 0;
      if (testTP3Structure) tp3Count += getRangeCount(tp3SwingLengthRange.min, tp3SwingLengthRange.max, tp3SwingLengthRange.step);
      if (testTP3Trailing) tp3Count += getRangeCount(tp3TrailingSwingRange.min, tp3TrailingSwingRange.max, tp3TrailingSwingRange.step);
      if (testTP3EMA) tp3Count += getRangeCount(tp3EMAFastRange.min, tp3EMAFastRange.max, tp3EMAFastRange.step) * getRangeCount(tp3EMASlowRange.min, tp3EMASlowRange.max, tp3EMASlowRange.step);
      if (testTP3FixedRR) tp3Count += getRangeCount(tp3RRRange.min, tp3RRRange.max, tp3RRRange.step);
      count *= tp3Count || 1;
    }

    // SL parameters
    let slCount = 0;
    if (testSLATR) slCount += getRangeCount(slATRRange.min, slATRRange.max, slATRRange.step);
    if (testSLStructure) slCount += getRangeCount(slSwingLengthRange.min, slSwingLengthRange.max, slSwingLengthRange.step);
    if (testSLFixedDistance) slCount += getRangeCount(slFixedDistanceRange.min, slFixedDistanceRange.max, slFixedDistanceRange.step);
    count *= slCount || 1;

    return count;
  }, [
    liqGrabAutoTestMode,
    testTrendFilters,
    testDirections,
    swingLengthRange,
    wickRatioRange,
    confirmCandlesRange,
    testUseWickFilter,
    testUseConfirmCandles,
    liqGrabTPSL.numTPs,
    testTP1Structure, testTP1Trailing, testTP1EMA, testTP1FixedRR,
    tp1SwingLengthRange, tp1TrailingSwingRange, tp1EMAFastRange, tp1EMASlowRange, tp1RRRange,
    testTP2Structure, testTP2Trailing, testTP2EMA, testTP2FixedRR,
    tp2SwingLengthRange, tp2TrailingSwingRange, tp2EMAFastRange, tp2EMASlowRange, tp2RRRange,
    testTP3Structure, testTP3Trailing, testTP3EMA, testTP3FixedRR,
    tp3SwingLengthRange, tp3TrailingSwingRange, tp3EMAFastRange, tp3EMASlowRange, tp3RRRange,
    testSLATR, testSLStructure, testSLFixedDistance,
    slATRRange, slSwingLengthRange, slFixedDistanceRange
  ]);

  // Calculate estimated completion time using actual performance data
  const estimatedTime = useMemo(() => {
    let msPerTest = 100; // Default fallback
    
    // If we have historical data, use average ms-per-test from last 5 runs
    if (liqGrabAutoTestDurations.length > 0) {
      const recentRuns = liqGrabAutoTestDurations.slice(-5);
      // Calculate ms-per-test for each run, then average
      const msPerTestValues = recentRuns.map(run => run.duration / run.combos);
      msPerTest = msPerTestValues.reduce((sum, v) => sum + v, 0) / msPerTestValues.length;
    }
    
    const seconds = Math.ceil((totalCombinations * msPerTest) / 1000);
    if (seconds < 60) return `~${seconds}s`;
    if (seconds < 3600) return `~${Math.ceil(seconds / 60)}min`;
    return `~${Math.ceil(seconds / 3600)}h ${Math.ceil((seconds % 3600) / 60)}min`;
  }, [totalCombinations, liqGrabAutoTestDurations]);

  // Fetch initial candle data from Binance via backend proxy
  const fetchInitialData = useCallback(async () => {
    try {
      setLoading(true);
      const url = `/api/binance/klines?symbol=${symbol}&interval=${interval}&limit=1000`;
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch candles: ${response.statusText}`);
      }
      
      const klines = await response.json();
      
      const candleData: CandleData[] = klines.map((k: any[]) => ({
        time: k[0] / 1000,
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
      }));

      console.log('âœ… Fetched candle data:', candleData.length, 'candles');
      setCandles(candleData);
      
      // Fetch REAL delta data from Binance aggTrades via orderflow API
      // SKIP if using multi-exchange mode (multi-exchange provides its own table data)
      if (!useMultiExchange) {
        try {
          const yahooSymbol = symbol.replace('USDT', '-USD');
          const footprintUrl = `/api/crypto/orderflow?symbol=${yahooSymbol}&period=1mo&interval=${interval}`;
          const fpResponse = await fetch(footprintUrl);
          if (fpResponse.ok) {
            const fpData = await fpResponse.json();
            
            // Store footprint data for FVG analysis
            if (fpData.footprint) {
              setFootprintData(fpData.footprint);
              
              // Create a map of timestamp -> real delta
              const deltaMap = new Map<number, number>();
              fpData.footprint.forEach((fp: any) => {
                deltaMap.set(fp.time, fp.delta);
              });
              setRealDeltaData(deltaMap);
              
              // Calculate delta history using REAL delta values
              let runningCVD = 0;
              const history = candleData.slice(-20).map(candle => {
                const delta = deltaMap.get(candle.time) || 0;
                runningCVD += delta;
                return {
                  time: new Date(candle.time * 1000).toLocaleTimeString(),
                  delta,
                  cumDelta: runningCVD,
                  isBull: candle.close >= candle.open,
                  volume: candle.volume
                };
              });
              
              setDeltaHistory(history);
              setCumDelta(runningCVD);
              
              console.log('âœ… Loaded REAL delta data from Binance aggTrades:', fpData.footprint.length, 'candles');
              console.log('ðŸ“Š Delta match rate:', (fpData.footprint.filter((fp: any) => candleData.some(c => c.time === fp.time)).length / candleData.length * 100).toFixed(1) + '%');
            }
          }
        } catch (fpError) {
          console.warn('Could not fetch footprint data:', fpError);
        }
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error fetching initial data:', error);
      setLoading(false);
    }
  }, [symbol, interval, useMultiExchange]);

  // Fetch multi-exchange orderflow data
  // Fetch AI Market Analysis
  const fetchAIAnalysis = useCallback(async (force = false) => {
    if (aiAnalysisLoading || candles.length < 100) return;
    
    // Skip if we've checked in the last 60 minutes (unless forced)
    const now = Date.now();
    if (!force && lastAnalysisCheck && (now - lastAnalysisCheck) < 60 * 60 * 1000) {
      return;
    }
    
    setAiAnalysisLoading(true);
    setLastAnalysisCheck(now);
    
    try {
      // For AI analysis, we'll just send basic candle data and let the backend handle structure detection
      // This avoids circular dependency issues with calculateBOSandCHoCH
      const response = await fetch('/api/crypto/market-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          candles: candles.slice(-200), // Send last 200 candles
          symbol: symbol.replace('USDT', '/USD'),
          timeframe: interval
        })
      });
      
      if (!response.ok) {
        throw new Error(`Analysis failed: ${response.statusText}`);
      }
      
      const data = await response.json();
      setAiAnalysis(data.analysis);
      setAiAnalysisTimestamp(now);
      setAiAnalysisCost(data.estimatedCost || 0);
      
      console.log('ðŸ¤– AI Analysis received', {
        cached: data.cached,
        cost: data.estimatedCost,
        tokens: data.tokens
      });
    } catch (error: any) {
      console.error('âŒ Error fetching AI analysis:', error);
      setAiAnalysis(`Error: ${error.message}`);
    } finally {
      setAiAnalysisLoading(false);
    }
  }, [candles, symbol, interval, aiAnalysisLoading, lastAnalysisCheck]);

  // Hourly AI Market Analysis auto-refresh
  useEffect(() => {
    if (candles.length < 100) return;
    
    // Fetch on mount when chart data is available
    if (!aiAnalysis) {
      fetchAIAnalysis(false);
    }
    
    // Set up hourly refresh
    const intervalId = setInterval(() => {
      console.log('â° Hourly AI analysis refresh triggered');
      fetchAIAnalysis(false);
    }, 60 * 60 * 1000); // Every hour
    
    return () => clearInterval(intervalId);
  }, [candles.length, aiAnalysis, fetchAIAnalysis]);

  const fetchMultiExchangeData = useCallback(async () => {
    if (!useMultiExchange) return;
    
    setMultiExchangeLoading(true);
    try {
      const binanceSymbol = symbol.replace('USDT', '');
      const multiUrl = `/api/crypto/multi-exchange-orderflow?symbol=${binanceSymbol}USDT&period=1mo&interval=${interval}`;
      
      console.log('ðŸŒ Fetching multi-exchange orderflow data...');
      const response = await fetch(multiUrl);
      
      if (response.ok) {
        const data = await response.json();
        setMultiExchangeData(data);
        
        // Use orderflowTable directly - it's separate from the chart
        if (data.orderflowTable && data.orderflowTable.length > 0) {
          console.log('ðŸ“Š Raw orderflowTable data:', data.orderflowTable);
          
          let runningCVD = 0;
          const history = data.orderflowTable.map((row: any) => {
            runningCVD += row.delta;
            return {
              time: new Date(row.time * 1000).toLocaleTimeString(),
              delta: row.delta,
              cumDelta: runningCVD,
              isBull: row.delta >= 0,
              volume: row.volume,
              exchanges: row.exchanges,
              confidence: row.confidence,
              divergence: false // Will be set from divergences array if needed
            };
          });
          
          setDeltaHistory(history);
          setCumDelta(runningCVD);
          
          console.log('âœ… Multi-exchange table loaded:', {
            rows: history.length,
            exchanges: data.metadata?.exchanges?.filter((e: any) => e.success).length || 0,
            successRate: `${(data.metadata?.success_rate * 100 || 0).toFixed(0)}%`,
            avgConfidence: `${(history.reduce((sum: number, h: any) => sum + h.confidence, 0) / history.length * 100).toFixed(0)}%`,
            sampleRow: history[0]
          });
        }
      } else {
        console.error('Failed to fetch multi-exchange data:', response.statusText);
      }
    } catch (error) {
      console.error('Error fetching multi-exchange data:', error);
    } finally {
      setMultiExchangeLoading(false);
    }
  }, [useMultiExchange, symbol, interval]);

  // Effect to fetch multi-exchange data when toggle changes
  useEffect(() => {
    if (useMultiExchange && candles.length > 0) {
      fetchMultiExchangeData();
    }
  }, [useMultiExchange, fetchMultiExchangeData, candles.length]);

  // Auto-refresh multi-exchange data every 5 seconds
  useEffect(() => {
    if (!useMultiExchange || candles.length === 0) return;

    console.log('ðŸ”„ Auto-refresh started for multi-exchange data (every 5s)');
    
    const refreshInterval = setInterval(() => {
      console.log('â° Auto-refresh tick - fetching multi-exchange data...');
      fetchMultiExchangeData();
    }, 5000);

    return () => {
      console.log('ðŸ›‘ Auto-refresh stopped');
      clearInterval(refreshInterval);
    };
  }, [useMultiExchange, candles.length, fetchMultiExchangeData]);

  // Calculate rolling VWAP
  const calculateRollingVWAP = useCallback((data: CandleData[], count: number): VWAPData[] => {
    const result: VWAPData[] = [];
    for (let i = count - 1; i < data.length; i++) {
      const slice = data.slice(i - count + 1, i + 1);
      let sumPV = 0, sumV = 0;
      slice.forEach(bar => {
        const typical = (bar.high + bar.low + bar.close) / 3;
        sumPV += typical * bar.volume;
        sumV += bar.volume;
      });
      result.push({ time: data[i].time, value: sumPV / sumV });
    }
    return result;
  }, []);

  // Get period key for anchored VWAP
  const getPeriodKey = useCallback((time: number, period: string): string => {
    const date = new Date(time * 1000);
    if (period === 'daily') {
      return date.toISOString().slice(0, 10);
    } else if (period === 'weekly') {
      const startOfWeek = new Date(date);
      startOfWeek.setUTCDate(date.getUTCDate() - date.getUTCDay());
      return startOfWeek.toISOString().slice(0, 10);
    } else if (period === 'monthly') {
      return date.getUTCFullYear() + '-' + String(date.getUTCMonth() + 1).padStart(2, '0');
    }
    return '';
  }, []);

  // Calculate periodic (anchored) VWAP with currentOnly option
  const calculatePeriodicVWAP = useCallback((data: CandleData[], period: string, currentOnly: boolean): VWAPData[] => {
    if (data.length === 0) return [];
    const result: VWAPData[] = [];
    let sumPV = 0, sumV = 0;
    let lastPeriodKey = getPeriodKey(data[0].time, period);
    const currentPeriodKey = getPeriodKey(data[data.length - 1].time, period);
    
    data.forEach(bar => {
      const periodKey = getPeriodKey(bar.time, period);
      if (periodKey !== lastPeriodKey) {
        sumPV = 0;
        sumV = 0;
      }
      lastPeriodKey = periodKey;
      const typical = (bar.high + bar.low + bar.close) / 3;
      sumPV += typical * bar.volume;
      sumV += bar.volume;
      if (sumV > 0 && (!currentOnly || periodKey === currentPeriodKey)) {
        result.push({ time: bar.time, value: sumPV / sumV });
      }
    });
    return result;
  }, [getPeriodKey]);

  // Calculate ATR
  const calculateATR = useCallback((data: CandleData[], period: number = 14): number[] => {
    const tr: number[] = [];
    for (let i = 1; i < data.length; i++) {
      const highLow = data[i].high - data[i].low;
      const highClose = Math.abs(data[i].high - data[i - 1].close);
      const lowClose = Math.abs(data[i].low - data[i - 1].close);
      tr.push(Math.max(highLow, highClose, lowClose));
    }
    const atr: number[] = [];
    let sum = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
    atr.push(sum);
    for (let i = period; i < tr.length; i++) {
      sum = (atr[atr.length - 1] * (period - 1) + tr[i]) / period;
      atr.push(sum);
    }
    return atr;
  }, []);

  // Analyze FVG volume/delta scores
  const analyzeFVGValue = useCallback((fvg: FVG, candles: CandleData[], footprint: FootprintData[]): { volumeScore: number; deltaScore: number; isHighValue: boolean } => {
    // Find all candles that overlap with the FVG zone
    let totalVolume = 0;
    let totalDelta = 0;
    let count = 0;

    for (let i = 0; i < candles.length; i++) {
      const candle = candles[i];
      // Check if this candle's price range overlaps with the FVG
      if (candle.low <= fvg.upper && candle.high >= fvg.lower) {
        totalVolume += candle.volume;
        
        // Get footprint data for this candle if available
        const fp = footprint.find(f => f.time === candle.time);
        if (fp) {
          totalDelta += Math.abs(fp.delta);
        }
        count++;
      }
    }

    // Calculate average volume across all candles for comparison
    const avgCandleVolume = candles.reduce((sum, c) => sum + c.volume, 0) / candles.length;
    
    // Volume score: total volume in FVG zone relative to average
    const volumeScore = count > 0 ? totalVolume / (avgCandleVolume * count) : 0;
    
    // Delta score: average delta imbalance in the zone
    const deltaScore = count > 0 ? totalDelta / count : 0;
    
    // High value if volume score exceeds threshold
    const isHighValue = volumeScore >= fvgVolumeThreshold;

    return { volumeScore, deltaScore, isHighValue };
  }, [fvgVolumeThreshold]);

  // Calculate FVGs with volume analysis
  const calculateFVGs = useCallback((data: CandleData[], useAtrFilter: boolean = true, atrFactor: number = 1): FVG[] => {
    const atr = calculateATR(data);
    const fvgs: FVG[] = [];
    for (let i = 2; i < data.length; i++) {
      let minGap = 0;
      if (useAtrFilter) minGap = atr[i - 2] * atrFactor;
      if (data[i].low > data[i - 2].high) {
        const lower = data[i - 2].high;
        const upper = data[i].low;
        if (upper - lower >= minGap) {
          const fvg: FVG = { time: data[i].time, lower, upper, type: 'bullish' };
          const analysis = analyzeFVGValue(fvg, data, footprintData);
          fvg.volumeScore = analysis.volumeScore;
          fvg.deltaScore = analysis.deltaScore;
          fvg.isHighValue = analysis.isHighValue;
          fvgs.push(fvg);
        }
      } else if (data[i].high < data[i - 2].low) {
        const lower = data[i].high;
        const upper = data[i - 2].low;
        if (upper - lower >= minGap) {
          const fvg: FVG = { time: data[i].time, lower, upper, type: 'bearish' };
          const analysis = analyzeFVGValue(fvg, data, footprintData);
          fvg.volumeScore = analysis.volumeScore;
          fvg.deltaScore = analysis.deltaScore;
          fvg.isHighValue = analysis.isHighValue;
          fvgs.push(fvg);
        }
      }
    }
    return fvgs;
  }, [calculateATR, analyzeFVGValue, footprintData]);

  // Check if FVG is still active (not filled)
  const isActiveFVG = useCallback((fvg: FVG, data: CandleData[]): boolean => {
    const startIdx = data.findIndex(d => d.time === fvg.time);
    
    // Check if FVG has been filled (price went through it completely)
    for (let i = startIdx + 1; i < data.length; i++) {
      // For bullish FVG, it's filled if price went below the lower boundary
      if (fvg.type === 'bullish' && data[i].low <= fvg.lower) {
        return false; // FVG is filled
      }
      // For bearish FVG, it's filled if price went above the upper boundary
      if (fvg.type === 'bearish' && data[i].high >= fvg.upper) {
        return false; // FVG is filled
      }
    }
    
    return true; // FVG is still unfilled
  }, []);

  // Get the time when FVG was filled (or null if still active)
  const getFVGFillTime = useCallback((fvg: FVG, data: CandleData[]): number | null => {
    const startIdx = data.findIndex(d => d.time === fvg.time);
    
    // Find the first candle that filled the FVG
    for (let i = startIdx + 1; i < data.length; i++) {
      // For bullish FVG, it's filled if price went below the lower boundary
      if (fvg.type === 'bullish' && data[i].low <= fvg.lower) {
        return data[i].time; // Return the time it was filled
      }
      // For bearish FVG, it's filled if price went above the upper boundary
      if (fvg.type === 'bearish' && data[i].high >= fvg.upper) {
        return data[i].time; // Return the time it was filled
      }
    }
    
    return null; // FVG is still unfilled
  }, []);

  // Calculate swing points (highs and lows)
  const calculateSwings = useCallback((data: CandleData[], swingLength: number = 5) => {
    const swings: Array<{ time: number; value: number; type: 'high' | 'low'; index: number }> = [];
    
    for (let i = swingLength; i < data.length - swingLength; i++) {
      const leftHighs = data.slice(i - swingLength, i).map(b => b.high);
      const rightHighs = data.slice(i + 1, i + swingLength + 1).map(b => b.high);
      if (data[i].high >= Math.max(...leftHighs) && data[i].high >= Math.max(...rightHighs)) {
        swings.push({ time: data[i].time, value: data[i].high, type: 'high', index: i });
      }
      
      const leftLows = data.slice(i - swingLength, i).map(b => b.low);
      const rightLows = data.slice(i + 1, i + swingLength + 1).map(b => b.low);
      if (data[i].low <= Math.min(...leftLows) && data[i].low <= Math.min(...rightLows)) {
        swings.push({ time: data[i].time, value: data[i].low, type: 'low', index: i });
      }
    }
    
    return swings.sort((a, b) => a.index - b.index);
  }, []);

  // Detect auto trendlines from swing points
  const detectTrendlines = useCallback((data: CandleData[], minTouches: number = 3, tolerance: number = 0.002, pivotLength: number = 10) => {
    interface Trendline {
      points: Array<{ time: number; price: number; index: number }>;
      slope: number;
      intercept: number;
      type: 'resistance' | 'support';
      strength: number;
      span: number;
    }
    
    const swings = calculateSwings(data, pivotLength);
    const swingHighs = swings.filter(s => s.type === 'high');
    const swingLows = swings.filter(s => s.type === 'low');
    
    // SMART APPROACH: Try multiple starting pivots near extremity, pick cleanest line
    const findTrendlineFromExtremity = (pivots: typeof swings, type: 'resistance' | 'support'): Trendline | null => {
      if (pivots.length < 2) return null;
      
      // Find absolute extremity
      const absoluteExtremity = type === 'resistance' 
        ? pivots.reduce((max, p) => p.value > max.value ? p : max)
        : pivots.reduce((min, p) => p.value < min.value ? p : min);
      
      // Find top candidate starting pivots near the extremity (within 3% price range)
      const candidateStarters = type === 'resistance'
        ? pivots
            .filter(p => p.value >= absoluteExtremity.value * 0.97) // Top 3% for resistance
            .sort((a, b) => b.value - a.value) // Highest first
            .slice(0, 5) // Top 5 candidates
        : pivots
            .filter(p => p.value <= absoluteExtremity.value * 1.03) // Bottom 3% for support
            .sort((a, b) => a.value - b.value) // Lowest first
            .slice(0, 5); // Top 5 candidates
      
      // Try building lines from each candidate starter
      const allCandidateLines: Array<Trendline & { violationRate: number }> = [];
      
      for (const starter of candidateStarters) {
        // Find pivots after this starter
        const pivotsAfterStarter = pivots.filter(p => p.index > starter.index);
        if (pivotsAfterStarter.length === 0) continue;
        
        // Try connecting to each subsequent pivot
        for (const secondPoint of pivotsAfterStarter) {
          const slope = (secondPoint.value - starter.value) / (secondPoint.index - starter.index);
          const intercept = starter.value - slope * starter.index;
          
          // Find all pivots that align with this line
          const alignedPoints: Array<{ time: number; price: number; index: number }> = [
            { time: starter.time, price: starter.value, index: starter.index },
            { time: secondPoint.time, price: secondPoint.value, index: secondPoint.index }
          ];
          
          for (const pivot of pivots) {
            if (pivot.index === starter.index || pivot.index === secondPoint.index) continue;
            
            const expectedPrice = slope * pivot.index + intercept;
            const priceDeviation = Math.abs(pivot.value - expectedPrice) / pivot.value;
            
            if (priceDeviation <= tolerance) {
              alignedPoints.push({ time: pivot.time, price: pivot.value, index: pivot.index });
            }
          }
          
          if (alignedPoints.length >= minTouches) {
            alignedPoints.sort((a, b) => a.index - b.index);
            
            // Calculate violation rate for this line
            const firstIdx = alignedPoints[0].index;
            const lastIdx = alignedPoints[alignedPoints.length - 1].index;
            let violations = 0;
            let totalCandles = 0;
            
            for (let i = firstIdx; i <= lastIdx; i++) {
              const candle = data[i];
              const expectedPrice = slope * i + intercept;
              
              if (type === 'resistance') {
                if (candle.close > expectedPrice * 1.01) violations++;
              } else {
                if (candle.close < expectedPrice * 0.99) violations++;
              }
              totalCandles++;
            }
            
            const violationRate = totalCandles > 0 ? violations / totalCandles : 1;
            
            allCandidateLines.push({
              points: alignedPoints,
              slope,
              intercept,
              type,
              strength: alignedPoints.length,
              span: alignedPoints[alignedPoints.length - 1].index - alignedPoints[0].index,
              violationRate
            });
          }
        }
      }
      
      if (allCandidateLines.length === 0) return null;
      
      // Pick the BEST line: lowest violation rate, then most touches, then most recent
      return allCandidateLines.reduce((best, current) => {
        // Strongly prefer cleaner lines (lower violation rate)
        if (current.violationRate < best.violationRate - 0.03) return current;
        if (best.violationRate < current.violationRate - 0.03) return best;
        
        // If similar cleanliness, prefer more touches
        if (current.strength > best.strength + 1) return current;
        if (best.strength > current.strength + 1) return best;
        
        // If similar strength, prefer more recent last pivot
        const bestLastPivot = best.points[best.points.length - 1].index;
        const currentLastPivot = current.points[current.points.length - 1].index;
        return currentLastPivot > bestLastPivot ? current : best;
      });
    };
    
    // Validate trendlines - check price respects line through the trend
    const validateTrendline = (line: Trendline): boolean => {
      const firstIdx = line.points[0].index;
      const lastPivotIdx = line.points[line.points.length - 1].index;
      
      let violations = 0;
      let totalCandles = 0;
      
      // Check candles from first pivot to last pivot (not to current price)
      // This validates the trend was respected during its formation
      for (let i = firstIdx; i <= lastPivotIdx; i++) {
        const candle = data[i];
        const expectedPrice = line.slope * i + line.intercept;
        
        // For resistance: VIOLATION = closing significantly ABOVE the line
        // For support: VIOLATION = closing significantly BELOW the line
        // Price can break THROUGH the line later (that's a breakout, not a violation)
        if (line.type === 'resistance') {
          // Only count violations when price is ABOVE resistance
          if (candle.close > expectedPrice * 1.01) { // 1% tolerance
            violations++;
          }
        } else { // support
          // Only count violations when price is BELOW support
          if (candle.close < expectedPrice * 0.99) { // 1% tolerance
            violations++;
          }
        }
        totalCandles++;
      }
      
      // Reject if more than 15% of candles violate (very relaxed)
      const violationRate = violations / totalCandles;
      return violationRate <= 0.15;
    };
    
    // Find trendlines using new extremity-based approach
    const resistanceLine = findTrendlineFromExtremity(swingHighs, 'resistance');
    const supportLine = findTrendlineFromExtremity(swingLows, 'support');
    
    const result: Trendline[] = [];
    
    // Debug logging
    if (resistanceLine) {
      const isValid = validateTrendline(resistanceLine);
      const violationRate = (resistanceLine as any).violationRate || 0;
      console.log('âœ… Resistance line:', {
        startPrice: resistanceLine.points[0].price.toFixed(4),
        endPrice: resistanceLine.points[resistanceLine.points.length - 1].price.toFixed(4),
        touches: resistanceLine.points.length,
        violationRate: (violationRate * 100).toFixed(1) + '%',
        valid: isValid
      });
      if (isValid) {
        result.push(resistanceLine);
      }
    } else {
      console.log('âŒ No resistance line found');
    }
    
    // Validate and add support line
    if (supportLine) {
      const isValid = validateTrendline(supportLine);
      const violationRate = (supportLine as any).violationRate || 0;
      console.log('âœ… Support line:', {
        startPrice: supportLine.points[0].price.toFixed(4),
        endPrice: supportLine.points[supportLine.points.length - 1].price.toFixed(4),
        touches: supportLine.points.length,
        violationRate: (violationRate * 100).toFixed(1) + '%',
        valid: isValid
      });
      if (isValid) {
        result.push(supportLine);
      }
    } else {
      console.log('âŒ No support line found');
    }
    
    return result;
  }, [calculateSwings]);

  // Calculate BOS and CHoCH with liquidity grab detection using CORRECT SMC logic
  const calculateBOSandCHoCH = useCallback((
    data: CandleData[], 
    swingLength: number = 5, 
    liqGrabLength: number = 2, 
    wickRatioThreshold: number = 150,
    useWickFilter: boolean = false,
    useConfirmCandles: boolean = false
  ) => {
    const swings = calculateSwings(data, swingLength);
    const bosArray: BOS[] = [];
    const chochArray: CHoCH[] = [];
    
    if (swings.length < 3) return { bos: bosArray, choch: chochArray };
    
    // Store arrays of swing highs and lows as they form chronologically
    const swingHighs: typeof swings = [];
    const swingLows: typeof swings = [];
    
    // Track current trend: 'bullish', 'bearish', or null (no trend yet)
    let currentTrend: 'bullish' | 'bearish' | null = null;
    
    // Process swings chronologically and detect breaks
    for (let i = 0; i < swings.length; i++) {
      const swing = swings[i];
      
      if (swing.type === 'high') {
        swingHighs.push(swing);
        
        // Check if this high breaks previous swing HIGH
        if (swingHighs.length >= 2) {
          const previousHigh = swingHighs[swingHighs.length - 2];
          
          if (swing.value > previousHigh.value) {
            // This is a higher high - could be BOS or CHoCH
            const breakIdx = data.findIndex((c, idx) => 
              idx > previousHigh.index && idx <= swing.index && c.high > previousHigh.value
            );
            
            if (breakIdx !== -1) {
              const breakCandle = data[breakIdx];
              const closeReversed = breakCandle.close < previousHigh.value;
              
              let wickLargeEnough = true;
              if (useWickFilter) {
                const bodySize = Math.abs(breakCandle.close - breakCandle.open);
                const upperWick = breakCandle.high - Math.max(breakCandle.open, breakCandle.close);
                wickLargeEnough = upperWick >= (bodySize * wickRatioThreshold / 100);
              }
              
              const isLiqGrab = closeReversed && wickLargeEnough;
              
              // If we were in a bearish trend, this is CHoCH (reversal to bullish)
              // Otherwise it's BOS (continuation)
              if (currentTrend === 'bearish') {
                chochArray.push({
                  swingTime: previousHigh.time,
                  swingPrice: previousHigh.value,
                  breakTime: breakCandle.time,
                  breakIndex: breakIdx,
                  type: 'bullish',
                  sweptLevel: 'high',
                  isLiquidityGrab: isLiqGrab
                });
                currentTrend = 'bullish'; // Trend reversed
              } else {
                bosArray.push({
                  swingTime: previousHigh.time,
                  swingPrice: previousHigh.value,
                  breakTime: breakCandle.time,
                  breakIndex: breakIdx,
                  type: 'bullish',
                  sweptLevel: 'high',
                  isLiquidityGrab: isLiqGrab
                });
                currentTrend = 'bullish'; // Trend continuing or starting
              }
            }
          }
        }
        
      } else {
        // Swing low
        swingLows.push(swing);
        
        // Check if this low breaks previous swing LOW
        if (swingLows.length >= 2) {
          const previousLow = swingLows[swingLows.length - 2];
          
          if (swing.value < previousLow.value) {
            // This is a lower low - could be BOS or CHoCH
            const breakIdx = data.findIndex((c, idx) => 
              idx > previousLow.index && idx <= swing.index && c.low < previousLow.value
            );
            
            if (breakIdx !== -1) {
              const breakCandle = data[breakIdx];
              const closeReversed = breakCandle.close > previousLow.value;
              
              let wickLargeEnough = true;
              if (useWickFilter) {
                const bodySize = Math.abs(breakCandle.close - breakCandle.open);
                const lowerWick = Math.min(breakCandle.open, breakCandle.close) - breakCandle.low;
                wickLargeEnough = lowerWick >= (bodySize * wickRatioThreshold / 100);
              }
              
              const isLiqGrab = closeReversed && wickLargeEnough;
              
              // If we were in a bullish trend, this is CHoCH (reversal to bearish)
              // Otherwise it's BOS (continuation)
              if (currentTrend === 'bullish') {
                chochArray.push({
                  swingTime: previousLow.time,
                  swingPrice: previousLow.value,
                  breakTime: breakCandle.time,
                  breakIndex: breakIdx,
                  type: 'bearish',
                  sweptLevel: 'low',
                  isLiquidityGrab: isLiqGrab
                });
                currentTrend = 'bearish'; // Trend reversed
              } else {
                bosArray.push({
                  swingTime: previousLow.time,
                  swingPrice: previousLow.value,
                  breakTime: breakCandle.time,
                  breakIndex: breakIdx,
                  type: 'bearish',
                  sweptLevel: 'low',
                  isLiquidityGrab: isLiqGrab
                });
                currentTrend = 'bearish'; // Trend continuing or starting
              }
            }
          }
        }
      }
    }
    
    console.log(`ðŸ“Š BOS/CHoCH Detection: ${bosArray.length} BOS, ${chochArray.length} CHoCH from ${swings.length} swings`);
    
    return { bos: bosArray, choch: chochArray };
  }, [calculateSwings]);

  // Calculate EMA
  const calculateEMA = useCallback((data: number[], period: number): number[] => {
    const ema: number[] = [];
    const k = 2 / (period + 1);
    ema[0] = data[0];
    for (let i = 1; i < data.length; i++) {
      ema[i] = data[i] * k + ema[i - 1] * (1 - k);
    }
    return ema;
  }, []);

  // Determine market bias (EMA-based) using configurable periods
  const determineBias = useCallback((data: CandleData[]) => {
    const closes = data.map(c => c.close);
    const emaFast = calculateEMA(closes, emaFastPeriod);
    const emaSlow = calculateEMA(closes, emaSlowPeriod);
    const newBias = emaFast[emaFast.length - 1] > emaSlow[emaSlow.length - 1] ? 'bullish' : 'bearish';
    setBias(newBias);
  }, [calculateEMA, emaFastPeriod, emaSlowPeriod]);

  // Determine structure-based trend (HH/HL vs LH/LL)
  const determineStructureTrend = useCallback((data: CandleData[]) => {
    const swings = calculateSwings(data, chartBosSwingLength);
    if (swings.length < 4) {
      setStructureTrend('ranging');
      return 'ranging';
    }

    const highs = swings.filter(s => s.type === 'high');
    const lows = swings.filter(s => s.type === 'low');

    if (highs.length < 2 || lows.length < 2) {
      setStructureTrend('ranging');
      return 'ranging';
    }

    // Check last 3 highs and lows for trend
    const recentHighs = highs.slice(-3);
    const recentLows = lows.slice(-3);

    const higherHighs = recentHighs.length >= 2 && recentHighs[recentHighs.length - 1].value > recentHighs[recentHighs.length - 2].value;
    const higherLows = recentLows.length >= 2 && recentLows[recentLows.length - 1].value > recentLows[recentLows.length - 2].value;
    const lowerHighs = recentHighs.length >= 2 && recentHighs[recentHighs.length - 1].value < recentHighs[recentHighs.length - 2].value;
    const lowerLows = recentLows.length >= 2 && recentLows[recentLows.length - 1].value < recentLows[recentLows.length - 2].value;

    if (higherHighs && higherLows) {
      setStructureTrend('uptrend');
      return 'uptrend';
    } else if (lowerHighs && lowerLows) {
      setStructureTrend('downtrend');
      return 'downtrend';
    } else {
      setStructureTrend('ranging');
      return 'ranging';
    }
  }, [calculateSwings, chartBosSwingLength]);

  // Get current ATR value for stop loss placement
  const getCurrentATR = useCallback((data: CandleData[], period: number = 14): number => {
    if (data.length < period) return 0;
    
    const trueRanges: number[] = [];
    for (let i = 1; i < data.length; i++) {
      const high = data[i].high;
      const low = data[i].low;
      const prevClose = data[i - 1].close;
      const tr = Math.max(
        high - low,
        Math.abs(high - prevClose),
        Math.abs(low - prevClose)
      );
      trueRanges.push(tr);
    }
    
    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
    return atr;
  }, []);

  // Find stop loss level based on swing structure
  const findStopLossLevel = useCallback((data: CandleData[], entry: number, direction: 'long' | 'short', customSwingLength?: number): number => {
    const swingLengthToUse = customSwingLength ?? swingLength;
    const swings = calculateSwings(data, swingLengthToUse);
    
    if (direction === 'long') {
      // For LONG: Find swing low BELOW entry (for stop loss protection)
      const lows = swings.filter(s => s.type === 'low' && s.value < entry).sort((a, b) => b.value - a.value);
      return lows.length > 0 ? lows[0].value : entry * 0.99;
    } else {
      // For SHORT: Find swing high ABOVE entry (for stop loss protection)
      const highs = swings.filter(s => s.type === 'high' && s.value > entry).sort((a, b) => a.value - b.value);
      return highs.length > 0 ? highs[0].value : entry * 1.01;
    }
  }, [calculateSwings, swingLength]);

  // Find next swing high/low for TP targets (FUTURE PIVOTS - for strategies waiting for new pivots to form)
  const findNextSwingLevels = useCallback((data: CandleData[], currentPrice: number, direction: 'long' | 'short', customSwingLength?: number) => {
    const swingLengthToUse = customSwingLength ?? swingLength;
    const swings = calculateSwings(data, swingLengthToUse);
    
    if (direction === 'long') {
      // Find next swing high above current price
      const highs = swings.filter(s => s.type === 'high' && s.value > currentPrice).sort((a, b) => a.value - b.value);
      return {
        tp2: highs.length > 0 ? highs[0].value : currentPrice * 1.02,
        tp3: highs.length > 1 ? highs[1].value : currentPrice * 1.03,
      };
    } else {
      // Find next swing low below current price
      const lows = swings.filter(s => s.type === 'low' && s.value < currentPrice).sort((a, b) => b.value - a.value);
      return {
        tp2: lows.length > 0 ? lows[0].value : currentPrice * 0.98,
        tp3: lows.length > 1 ? lows[1].value : currentPrice * 0.97,
      };
    }
  }, [calculateSwings, swingLength]);

  // Find PREVIOUS swing high/low for TP targets (PAST PIVOTS - for quick scalps back to last resistance/support)
  const findPreviousSwingLevels = useCallback((data: CandleData[], currentPrice: number, direction: 'long' | 'short', customSwingLength?: number, endIndex?: number) => {
    const swingLengthToUse = customSwingLength ?? swingLength;
    
    // DEBUG: Log exactly what swing length we're using
    console.log('ðŸ” findPreviousSwingLevels CALLED:', {
      receivedSwingLength: customSwingLength,
      defaultSwingLength: swingLength,
      actuallyUsing: swingLengthToUse,
      direction: direction.toUpperCase(),
      backtestMode: endIndex !== undefined ? `YES (candle ${endIndex + 1}/${data.length})` : 'NO (live)',
    });
    
    // If endIndex provided, only use data up to that point (for backtest accuracy)
    const dataToUse = endIndex !== undefined ? data.slice(0, endIndex + 1) : data;
    const swings = calculateSwings(dataToUse, swingLengthToUse);
    
    console.log('ðŸ” Calculated Swings:', {
      totalSwings: swings.length,
      swingLength: swingLengthToUse,
      highs: swings.filter(s => s.type === 'high').length,
      lows: swings.filter(s => s.type === 'low').length,
    });
    
    if (direction === 'long') {
      // Find previous swing highs ABOVE current price (scalp back UP to last resistance)
      const highs = swings
        .filter(s => s.type === 'high' && s.value > currentPrice)
        .sort((a, b) => a.value - b.value); // Ascending: closest above us first
      
      console.log('ðŸ“Š Previous Swing Levels (LONG):', {
        entry: currentPrice.toFixed(4),
        candlesUsed: endIndex !== undefined ? `${endIndex + 1}/${data.length}` : `${data.length} (live)`,
        swingsAbove: highs.length,
        tp1: highs.length > 0 ? highs[0].value.toFixed(4) : 'NO SWING FOUND',
        tp2: highs.length > 1 ? highs[1].value.toFixed(4) : 'NO SWING FOUND',
        tp3: highs.length > 2 ? highs[2].value.toFixed(4) : 'NO SWING FOUND',
        allSwingHighs: highs.map(h => h.value.toFixed(4)).join(', '),
      });
      
      return {
        tp1: highs.length > 0 ? highs[0].value : currentPrice,
        tp2: highs.length > 1 ? highs[1].value : currentPrice,
        tp3: highs.length > 2 ? highs[2].value : currentPrice,
      };
    } else {
      // Find previous swing lows BELOW current price (scalp back DOWN to last support)
      const lows = swings
        .filter(s => s.type === 'low' && s.value < currentPrice)
        .sort((a, b) => b.value - a.value); // Descending: closest below us first
      
      console.log('ðŸ“Š Previous Swing Levels (SHORT):', {
        entry: currentPrice.toFixed(4),
        candlesUsed: endIndex !== undefined ? `${endIndex + 1}/${data.length}` : `${data.length} (live)`,
        swingsBelow: lows.length,
        tp1: lows.length > 0 ? lows[0].value.toFixed(4) : 'NO SWING FOUND',
        tp2: lows.length > 1 ? lows[1].value.toFixed(4) : 'NO SWING FOUND',
        tp3: lows.length > 2 ? lows[2].value.toFixed(4) : 'NO SWING FOUND',
        allSwingLows: lows.map(l => l.value.toFixed(4)).join(', '),
      });
      
      return {
        tp1: lows.length > 0 ? lows[0].value : currentPrice,
        tp2: lows.length > 1 ? lows[1].value : currentPrice,
        tp3: lows.length > 2 ? lows[2].value : currentPrice,
      };
    }
  }, [calculateSwings, swingLength]);

  // Get closest VWAP value
  const getClosestVWAP = useCallback((currentPrice: number): number | null => {
    if (!chartRef.current) return null;
    
    // Check which VWAPs are enabled and get their current values
    const vwaps: number[] = [];
    
    if (showVWAPDaily) {
      const dailyVWAP = calculatePeriodicVWAP(candles, 'daily', true);
      if (dailyVWAP.length > 0) vwaps.push(dailyVWAP[dailyVWAP.length - 1].value);
    }
    
    if (showVWAPWeekly) {
      const weeklyVWAP = calculatePeriodicVWAP(candles, 'weekly', true);
      if (weeklyVWAP.length > 0) vwaps.push(weeklyVWAP[weeklyVWAP.length - 1].value);
    }
    
    if (showVWAPRolling20) {
      const rolling20 = calculateRollingVWAP(candles, 20);
      if (rolling20.length > 0) vwaps.push(rolling20[rolling20.length - 1].value);
    }
    
    if (vwaps.length === 0) return null;
    
    // Find closest VWAP to current price
    return vwaps.reduce((closest, vwap) => {
      return Math.abs(vwap - currentPrice) < Math.abs(closest - currentPrice) ? vwap : closest;
    });
  }, [candles, showVWAPDaily, showVWAPWeekly, showVWAPRolling20, calculatePeriodicVWAP, calculateRollingVWAP]);

  // Calculate position size based on account percentage
  // Position size = (accountSize * percent) / entry price
  // Risk is then determined by how far the SL is from entry
  const calculatePositionSize = useCallback((entry: number, stopLoss: number): number => {
    const positionValue = accountSize * (riskPercent / 100);
    if (entry === 0) return 0;
    return positionValue / entry;
  }, [accountSize, riskPercent]);

  // Check if trend filter passes
  const checkTrendFilter = useCallback((): boolean => {
    if (trendFilter === 'ema') {
      return bias !== null;
    } else if (trendFilter === 'structure') {
      return structureTrend !== null && structureTrend !== 'ranging';
    } else { // both
      const emaBullish = bias === 'bullish';
      const structureBullish = structureTrend === 'uptrend';
      const emaBearish = bias === 'bearish';
      const structureBearish = structureTrend === 'downtrend';
      return (emaBullish && structureBullish) || (emaBearish && structureBearish);
    }
  }, [bias, structureTrend, trendFilter]);

  // Check if direction filter passes
  const checkDirectionFilter = useCallback((signalType: 'LONG' | 'SHORT'): boolean => {
    if (directionFilter === 'both') return true;
    if (directionFilter === 'bull') return signalType === 'LONG';
    if (directionFilter === 'bear') return signalType === 'SHORT';
    return false;
  }, [directionFilter]);

  // Generate liquidity grab signal
  const generateLiquidityGrabSignal = useCallback((
    data: CandleData[], 
    bypassToggle = false,
    overrideSettings?: {
      swingLength?: number;
      wickRatio?: number;
      confirmCandles?: number;
      useWickFilter?: boolean;
      useConfirmCandles?: boolean;
      trendFilter?: 'none' | 'ema' | 'structure' | 'both';
      directionFilter?: 'both' | 'bull' | 'bear';
      tpslConfig?: typeof liqGrabTPSL;
    }
  ): TradeSignal | null => {
    if ((!stratLiquidityGrab && !bypassToggle) || data.length < 50) return null;
    
    // Use override settings if provided, otherwise use state
    const swingLength = overrideSettings?.swingLength ?? liqGrabSwingLength;
    const wickRatio = overrideSettings?.wickRatio ?? liqGrabWickRatio;
    const confirmCandles = overrideSettings?.confirmCandles ?? liqGrabConfirmCandles;
    const useWickFilter = overrideSettings?.useWickFilter ?? liqGrabUseWickFilter;
    const useConfirmCandles = overrideSettings?.useConfirmCandles ?? liqGrabUseConfirmCandles;
    const trendFilter = overrideSettings?.trendFilter ?? liqGrabTrendFilter;
    const directionFilter = overrideSettings?.directionFilter ?? liqGrabDirectionFilter;
    const tpslConfig = overrideSettings?.tpslConfig ?? liqGrabTPSL;
    
    // Use strategy-specific settings with optional filters
    const { bos, choch } = calculateBOSandCHoCH(
      data, 
      swingLength, 
      confirmCandles, 
      wickRatio,
      useWickFilter,
      useConfirmCandles
    );
    const allEvents = [...bos, ...choch].filter(e => e.isLiquidityGrab);
    
    if (allEvents.length === 0) return null;
    
    // Get the most recent sweep (for backtesting, we want the last one in the data)
    const lastEvent = allEvents[allEvents.length - 1];
    const currentCandle = data[data.length - 1];
    const currentPrice = currentCandle.close;
    const atr = getCurrentATR(data);
    
    // Liquidity grab REVERSAL logic (independent of BOS/CHoCH structure):
    // Sweep LOW â†’ price reverses UP â†’ LONG
    // Sweep HIGH â†’ price reverses DOWN â†’ SHORT
    const isLong = lastEvent.sweptLevel === 'low';
    
    // Check strategy-specific direction filter
    if (directionFilter !== 'both') {
      if (directionFilter === 'bull' && !isLong) return null;
      if (directionFilter === 'bear' && isLong) return null;
    }
    
    // Check strategy-specific trend filter
    if (trendFilter !== 'none') {
      if (trendFilter === 'ema' && bias === null) return null;
      if (trendFilter === 'structure' && (structureTrend === null || structureTrend === 'ranging')) return null;
      if (trendFilter === 'both') {
        const emaBullish = bias === 'bullish';
        const structureBullish = structureTrend === 'uptrend';
        const emaBearish = bias === 'bearish';
        const structureBearish = structureTrend === 'downtrend';
        if (!((emaBullish && structureBullish) || (emaBearish && structureBearish))) return null;
      }
    }
    
    // Entry at the close price of the sweep candle (reversal entry)
    // Find the candle where the sweep occurred
    const sweepCandleIdx = data.findIndex(c => c.time === lastEvent.breakTime);
    const sweepCandle = sweepCandleIdx >= 0 ? data[sweepCandleIdx] : data[data.length - 1];
    const entry = sweepCandle.close;
    
    // Use bot-specific SL configuration
    const slConfig = tpslConfig.sl;
    let stopLoss: number;
    if (slConfig.type === 'atr') {
      // Place SL at ATR distance from entry
      stopLoss = isLong ? entry - (atr * (slConfig.atrMultiplier || 1.5)) : entry + (atr * (slConfig.atrMultiplier || 1.5));
    } else if (slConfig.type === 'structure') {
      // For structure SL, if swing length is provided, calculate proper swing level
      // Otherwise fall back to swept swing level (legacy behavior)
      if (slConfig.swingLength) {
        stopLoss = findStopLossLevel(data, entry, isLong ? 'long' : 'short', slConfig.swingLength);
      } else {
        // Place SL at the swept swing level (small buffer for slippage)
        const slBuffer = 0.0005; // 0.05% buffer
        stopLoss = isLong 
          ? lastEvent.swingPrice * (1 - slBuffer)  // SL below swept low
          : lastEvent.swingPrice * (1 + slBuffer); // SL above swept high
      }
    } else {
      // Fixed distance in percentage
      const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
      stopLoss = isLong ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
    }
    
    const riskAmount = Math.abs(entry - stopLoss);
    
    // Calculate TPs based on bot-specific configuration
    const { tp1: tp1Config, tp2: tp2Config, tp3: tp3Config } = tpslConfig;
    
    // For structure-based calculations, use TP1 swing length if configured, otherwise use default
    const structureSwingLength = tp1Config.type === 'structure' && tp1Config.swingLength 
      ? tp1Config.swingLength 
      : liqGrabTPSwingLength;
    
    const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, isLong ? 'long' : 'short', structureSwingLength);
    
    let tp1: number, tp2: number, tp3: number;
    let tp1Type: TPType;
    let tp2Type: TPType;
    let tp3Type: TPType;
    
    // TP1 calculation
    tp1Type = tp1Config.type;
    if (tp1Config.type === 'ema') {
      // EMA exits have no price target - only exit on signal
      tp1 = isLong ? Infinity : -Infinity;
    } else if (tp1Config.type === 'atr') {
      tp1 = isLong ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
    } else if (tp1Config.type === 'structure') {
      tp1 = structureTP2;
    } else if (tp1Config.type === 'fixed_rr') {
      tp1 = isLong ? entry + (riskAmount * (tp1Config.fixedRR || 2.0)) : entry - (riskAmount * (tp1Config.fixedRR || 2.0));
    } else if (tp1Config.type === 'vwap') {
      tp1 = getClosestVWAP(entry) || structureTP2;
    } else if (tp1Config.type === 'trailing') {
      // Trailing TP: Set far away initially, will activate once profitable + swing forms
      tp1 = isLong ? entry * 100 : entry * 0.01;
    } else {
      tp1 = isLong ? entry + (structureTP2 - entry) * (tp1Config.projectionMultiplier || 2.0) : entry - (entry - structureTP2) * (tp1Config.projectionMultiplier || 2.0);
    }
    
    // TP2 calculation
    tp2Type = tp2Config?.type || 'structure';
    if (tp2Config?.type === 'atr') {
      tp2 = isLong ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
    } else if (tp2Config?.type === 'fixed_rr') {
      tp2 = isLong ? entry + (riskAmount * (tp2Config.fixedRR || 3.0)) : entry - (riskAmount * (tp2Config.fixedRR || 3.0));
    } else if (tp2Config?.type === 'trailing') {
      // Trailing TP: Set far away initially, will activate once profitable + swing forms
      tp2 = isLong ? entry * 100 : entry * 0.01;
    } else {
      tp2 = structureTP3;
    }
    
    // TP3 calculation
    tp3Type = tp3Config?.type || 'projection';
    if (tp3Config?.type === 'projection') {
      tp3 = isLong ? entry + (structureTP2 - entry) * (tp3Config.projectionMultiplier || 3.0) : entry - (entry - structureTP2) * (tp3Config.projectionMultiplier || 3.0);
    } else if (tp3Config?.type === 'trailing') {
      // Trailing TP: Set far away initially, will activate once profitable + swing forms
      tp3 = isLong ? entry * 100 : entry * 0.01;
    } else {
      tp3 = isLong ? entry + (riskAmount * 5.0) : entry - (riskAmount * 5.0);
    }
    
    console.log(`ðŸŽ¯ Liquidity Grab TP calculation:`, {
      type: isLong ? 'LONG' : 'SHORT',
      entry: entry?.toFixed(4) || 'N/A',
      stopLoss: stopLoss?.toFixed(4) || 'N/A',
      tp1: tp1?.toFixed(4) || 'N/A',
      tp1Type,
      rr1: (entry && tp1 && riskAmount) ? (Math.abs(tp1 - entry) / riskAmount).toFixed(2) : 'N/A',
      numTPs: tpslConfig.numTPs
    });
    
    // Use stable ID based on the actual market event time, not current time
    // Set signal time to the sweep candle time for proper alignment on chart
    return {
      id: `liq_grab_${lastEvent.breakTime}`,
      time: lastEvent.breakTime, // Use sweep candle time, not current time
      type: isLong ? 'LONG' : 'SHORT',
      strategy: 'liquidity_grab',
      entry,
      stopLoss,
      tp1,
      tp2,
      tp3,
      tp1Type,
      tp2Type,
      tp3Type,
      riskReward1: Math.abs(tp1 - entry) / riskAmount,
      riskReward2: Math.abs(tp2 - entry) / riskAmount,
      riskReward3: Math.abs(tp3 - entry) / riskAmount,
      quantity: calculatePositionSize(entry, stopLoss),
      reason: `Liquidity sweep at ${lastEvent.swingPrice?.toFixed(4) || 'unknown'}`,
      active: true,
      trailingActive: tp1Config.type === 'trailing' ? false : undefined, // Start inactive for trailing TP
    };
  }, [stratLiquidityGrab, calculateBOSandCHoCH, liqGrabSwingLength, liqGrabConfirmCandles, liqGrabWickRatio, liqGrabUseWickFilter, liqGrabUseConfirmCandles, liqGrabDirectionFilter, liqGrabTrendFilter, bias, structureTrend, findStopLossLevel, findNextSwingLevels, calculatePositionSize, liqGrabTPSL, getCurrentATR, getClosestVWAP, liqGrabTPSwingLength]);

  // Generate BOS Trend Follow signal
  const generateBOSTrendSignal = useCallback((data: CandleData[]): TradeSignal | null => {
    if (!stratBOSTrend || data.length < 50) return null;
    
    const { bos } = calculateBOSandCHoCH(data, bosSwingLength, bosConfirmCandles, bosWickRatio, bosUseWickFilter, bosUseConfirmCandles);
    
    // Filter out liquidity grabs (same as chart display)
    const trendBOS = bos.filter(b => !b.isLiquidityGrab);
    if (trendBOS.length === 0) return null;
    
    // Get the most recent BOS event and enter the trade
    const lastBOS = trendBOS[trendBOS.length - 1];
    const currentCandle = data[data.length - 1];
    const isLong = lastBOS.type === 'bullish';
    
    // Check direction filter
    if (bosDirectionFilter !== 'both') {
      if (bosDirectionFilter === 'bull' && !isLong) return null;
      if (bosDirectionFilter === 'bear' && isLong) return null;
    }
    
    // Check trend filter
    if (bosTrendFilter !== 'none') {
      if (bosTrendFilter === 'ema' && bias === null) return null;
      if (bosTrendFilter === 'structure' && (structureTrend === null || structureTrend === 'ranging')) return null;
      if (bosTrendFilter === 'both') {
        const emaBullish = bias === 'bullish';
        const structureBullish = structureTrend === 'uptrend';
        const emaBearish = bias === 'bearish';
        const structureBearish = structureTrend === 'downtrend';
        if (!((emaBullish && structureBullish) || (emaBearish && structureBearish))) return null;
      }
    }
    
    const entry = currentCandle.close;
    const atr = getCurrentATR(data);
    
    // Use bot-specific SL configuration
    const slConfig = bosTPSL.sl;
    let stopLoss: number;
    if (slConfig.type === 'atr') {
      stopLoss = isLong ? entry - (atr * (slConfig.atrMultiplier || 1.5)) : entry + (atr * (slConfig.atrMultiplier || 1.5));
    } else if (slConfig.type === 'structure') {
      const swings = calculateSwings(data, bosSLSwingLength);
      if (isLong) {
        const lows = swings.filter(s => s.type === 'low' && s.value < entry).sort((a, b) => b.value - a.value);
        stopLoss = lows.length > 0 ? lows[0].value : entry * 0.99;
      } else {
        const highs = swings.filter(s => s.type === 'high' && s.value > entry).sort((a, b) => a.value - b.value);
        stopLoss = highs.length > 0 ? highs[0].value : entry * 1.01;
      }
    } else {
      // Fixed distance in percentage
      const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
      stopLoss = isLong ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
    }
    
    const riskAmount = Math.abs(entry - stopLoss);
    
    // Calculate TPs based on bot-specific configuration
    const { tp1: tp1Config, tp2: tp2Config, tp3: tp3Config } = bosTPSL;
    const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, isLong ? 'long' : 'short', bosTPSwingLength);
    
    let tp1: number, tp2: number, tp3: number;
    let tp1Type: TPType;
    let tp2Type: TPType;
    let tp3Type: TPType;
    
    // TP1 calculation
    tp1Type = tp1Config.type;
    if (tp1Config.type === 'atr') {
      tp1 = isLong ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
    } else if (tp1Config.type === 'structure') {
      tp1 = structureTP2;
    } else if (tp1Config.type === 'fixed_rr') {
      tp1 = isLong ? entry + (riskAmount * (tp1Config.fixedRR || 1.5)) : entry - (riskAmount * (tp1Config.fixedRR || 1.5));
    } else if (tp1Config.type === 'vwap') {
      tp1 = getClosestVWAP(entry) || structureTP2;
    } else {
      tp1 = isLong ? entry + (structureTP2 - entry) * (tp1Config.projectionMultiplier || 2.0) : entry - (entry - structureTP2) * (tp1Config.projectionMultiplier || 2.0);
    }
    
    // TP2 calculation
    tp2Type = tp2Config?.type || 'structure';
    if (tp2Config?.type === 'atr') {
      tp2 = isLong ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
    } else if (tp2Config?.type === 'fixed_rr') {
      tp2 = isLong ? entry + (riskAmount * (tp2Config.fixedRR || 2.5)) : entry - (riskAmount * (tp2Config.fixedRR || 2.5));
    } else {
      tp2 = structureTP3;
    }
    
    // TP3 calculation
    tp3Type = tp3Config?.type || 'projection';
    if (tp3Config?.type === 'projection') {
      tp3 = isLong ? entry + (structureTP2 - entry) * (tp3Config.projectionMultiplier || 3.0) : entry - (entry - structureTP2) * (tp3Config.projectionMultiplier || 3.0);
    } else {
      tp3 = isLong ? entry + (riskAmount * 4.0) : entry - (riskAmount * 4.0);
    }
    
    console.log(`ðŸŽ¯ BOS Trend TP calculation:`, {
      type: isLong ? 'LONG' : 'SHORT',
      entry: entry.toFixed(4),
      stopLoss: stopLoss.toFixed(4),
      tp1: tp1.toFixed(4),
      tp1Type,
      rr1: (Math.abs(tp1 - entry) / riskAmount).toFixed(2),
      numTPs: bosTPSL.numTPs,
      swingLength: bosSwingLength
    });
    
    return {
      id: `bos_trend_${lastBOS.breakTime}`,
      time: lastBOS.breakTime,
      type: isLong ? 'LONG' : 'SHORT',
      strategy: 'bos_trend',
      entry,
      stopLoss,
      tp1,
      tp2,
      tp3,
      tp1Type,
      tp2Type,
      tp3Type,
      riskReward1: Math.abs(tp1 - entry) / riskAmount,
      riskReward2: Math.abs(tp2 - entry) / riskAmount,
      riskReward3: Math.abs(tp3 - entry) / riskAmount,
      quantity: calculatePositionSize(entry, stopLoss),
      reason: `BOS ${isLong ? 'Bullish' : 'Bearish'} at ${lastBOS.swingPrice.toFixed(4)}`,
      active: true,
    };
  }, [stratBOSTrend, calculateBOSandCHoCH, bosSwingLength, bosConfirmCandles, bosWickRatio, bosUseWickFilter, bosUseConfirmCandles, bosDirectionFilter, bosTrendFilter, bias, structureTrend, calculatePositionSize, bosTPSL, getCurrentATR, getClosestVWAP, findNextSwingLevels, calculateSwings, bosTPSwingLength, bosSLSwingLength]);

  // Generate SIMPLIFIED FVG retest signal (NO CHoCH requirements)
  const generateChochFVGSignal = useCallback((data: CandleData[]): TradeSignal | null => {
    if (!stratChochFVG || data.length < 50) return null;
    
    // Calculate FVGs
    const fvgs = calculateFVGs(data, true);
    const currentCandle = data[data.length - 1];
    const currentPrice = currentCandle.close;
    
    // Simple FVG retest detection:
    // LONG: Price enters bullish FVG from above (retracement down into support)
    // SHORT: Price enters bearish FVG from below (retracement up into resistance)
    const relevantFVGs = fvgs.filter(fvg => {
      const inZone = currentPrice >= fvg.lower && currentPrice <= fvg.upper;
      const validVolume = (fvg.volumeScore || 0) >= chochFVGVolumeThreshold;
      
      // OPTIONAL: Ensure FVG has minimum height (filter out tiny gaps)
      let significantSize = true;
      if (chochUseFVGSizeFilter) {
        const fvgHeight = fvg.upper - fvg.lower;
        const minHeight = getCurrentATR(data) * (chochFVGMinSizeATR / 100);
        significantSize = fvgHeight >= minHeight;
      }
      
      // Entry direction check - price must enter from correct side
      const fvgIndex = data.findIndex(c => c.time === fvg.time);
      if (fvgIndex < 0 || fvgIndex >= data.length - 1) return false;
      
      // Check if current candle is entering FVG from the right direction
      const prevCandle = data[data.length - 2];
      const enteringFromAbove = prevCandle.close > fvg.upper && currentPrice >= fvg.lower && currentPrice <= fvg.upper;
      const enteringFromBelow = prevCandle.close < fvg.lower && currentPrice >= fvg.lower && currentPrice <= fvg.upper;
      
      const correctEntry = (fvg.type === 'bullish' && enteringFromAbove) || (fvg.type === 'bearish' && enteringFromBelow);
      
      return inZone && validVolume && significantSize && correctEntry;
    });
    
    if (relevantFVGs.length === 0) return null;
    
    const fvg = relevantFVGs[0];
    const isLong = fvg.type === 'bullish';
    const entry = isLong ? fvg.upper : fvg.lower;
    const atr = getCurrentATR(data);
    
    console.log('âœ… FVG Retest Entry:', {
      type: fvg.type.toUpperCase(),
      direction: isLong ? 'LONG' : 'SHORT',
      fvgZone: `${fvg.lower.toFixed(4)} - ${fvg.upper.toFixed(4)}`,
      entry: entry.toFixed(4),
      currentPrice: currentPrice.toFixed(4),
    });
    
    // Stop Loss: Fixed % from FVG boundary OR nearest pivot beyond FVG
    const slConfig = chochTPSL.sl;
    let stopLoss: number;
    
    if (slConfig.type === 'structure') {
      // Find nearest pivot BEYOND the FVG (opposite side from entry)
      const swings = calculateSwings(data, chochSLSwingLength);
      const fvgBoundary = isLong ? fvg.lower : fvg.upper;
      
      let nearestPivot: number | null = null;
      for (let i = swings.length - 1; i >= 0; i--) {
        const swing = swings[i];
        if (isLong && swing.type === 'low' && swing.value < fvgBoundary) {
          nearestPivot = swing.value;
          break;
        } else if (!isLong && swing.type === 'high' && swing.value > fvgBoundary) {
          nearestPivot = swing.value;
          break;
        }
      }
      
      // If no pivot found, use fixed % from FVG
      stopLoss = nearestPivot !== null ? nearestPivot : (isLong ? fvg.lower * 0.99 : fvg.upper * 1.01);
    } else {
      // Fixed % from FVG boundary
      const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
      const fvgBoundary = isLong ? fvg.lower : fvg.upper;
      stopLoss = isLong ? fvgBoundary * (1 - distancePercent) : fvgBoundary * (1 + distancePercent);
    }
    
    const riskAmount = Math.abs(entry - stopLoss);
    
    // TP Mode: Structure (last swing high/low) OR Trailing (starts at SL, moves to new pivots)
    const { tp1: tp1Config } = chochTPSL;
    let tp1: number;
    let tp1Type: TPType = 'structure';
    
    if (tp1Config.type === 'structure') {
      // Target last swing high (longs) or low (shorts)
      const swings = calculateSwings(data, chochTPSwingLength);
      const targetPivots = isLong 
        ? swings.filter(s => s.type === 'high' && s.value > entry).sort((a, b) => a.value - b.value)
        : swings.filter(s => s.type === 'low' && s.value < entry).sort((a, b) => b.value - a.value);
      
      tp1 = targetPivots.length > 0 ? targetPivots[0].value : stopLoss;
      
      console.log('ðŸ“Š Structure TP:', {
        direction: isLong ? 'LONG' : 'SHORT',
        entry: entry.toFixed(4),
        targetPivot: tp1.toFixed(4),
        pivotsFound: targetPivots.length,
      });
    } else {
      // Trailing TP: Set far away initially, will activate once profitable + swing forms
      tp1 = isLong ? entry * 100 : entry * 0.01; // Far away price to prevent premature exit
      tp1Type = 'trailing';
      
      console.log('ðŸ“Š Trailing TP Initialized:', {
        direction: isLong ? 'LONG' : 'SHORT',
        entry: entry.toFixed(4),
        sl: stopLoss.toFixed(4),
        initialTP: 'Disabled (far away)',
        note: 'Will activate when profitable + swing forms',
      });
    }
    
    const signal: TradeSignal = {
      id: `fvg_${fvg.time}_${entry.toFixed(4)}`,
      time: data[data.length - 1].time,
      type: isLong ? 'LONG' : 'SHORT',
      strategy: 'choch_fvg',
      entry,
      stopLoss,
      tp1,
      tp2: tp1, // Single TP approach
      tp3: tp1,
      tp1Type,
      tp2Type: tp1Type,
      tp3Type: tp1Type,
      riskReward1: Math.abs(tp1 - entry) / riskAmount,
      riskReward2: Math.abs(tp1 - entry) / riskAmount,
      riskReward3: Math.abs(tp1 - entry) / riskAmount,
      quantity: calculatePositionSize(entry, stopLoss),
      reason: `FVG Retest (${fvg.type})`,
      active: true,
      trailingActive: tp1Config.type === 'trailing' ? false : undefined, // Start inactive for trailing
    };
    
    return signal;
  }, [stratChochFVG, calculateFVGs, getCurrentATR, chochFVGVolumeThreshold, chochUseFVGSizeFilter, chochFVGMinSizeATR, chochTPSL, chochSLSwingLength, calculateSwings, chochTPSwingLength, calculatePositionSize]);

  // Generate VWAP Trading signal (Bounce and Cross patterns)
  const generateVWAPTradingSignal = useCallback((data: CandleData[]): TradeSignal | null => {
    if (!stratVWAPRejection || data.length < 50) return null;
    
    // Calculate VWAP independently based on vwapType setting
    let vwapData: VWAPData[];
    if (vwapType === 'daily') {
      vwapData = calculatePeriodicVWAP(data, 'daily', true);
    } else if (vwapType === 'weekly') {
      vwapData = calculatePeriodicVWAP(data, 'weekly', true);
    } else if (vwapType === 'monthly') {
      vwapData = calculatePeriodicVWAP(data, 'monthly', true);
    } else if (vwapType === 'rolling10') {
      vwapData = calculateRollingVWAP(data, 10);
    } else if (vwapType === 'rolling20') {
      vwapData = calculateRollingVWAP(data, 20);
    } else if (vwapType === 'rolling50') {
      vwapData = calculateRollingVWAP(data, 50);
    } else {
      vwapData = calculatePeriodicVWAP(data, 'weekly', true); // default
    }
    
    if (vwapData.length < 2) return null;
    const vwapLevel = vwapData[vwapData.length - 1].value;
    
    // Get last 2 candles - simple approach
    if (data.length < 2) return null;
    const prevCandle = data[data.length - 2];
    const currentCandle = data[data.length - 1];
    
    const tolerance = vwapLevel * (vwapThreshold / 100);
    const upperZone = vwapLevel + tolerance;
    const lowerZone = vwapLevel - tolerance;
    
    // Helper: Check if candle touches threshold zone (wick or body)
    const touchesZone = (c: CandleData) => c.high >= lowerZone && c.low <= upperZone;
    
    let signal: { type: 'LONG' | 'SHORT', pattern: 'Bounce' | 'Cross' } | null = null;
    
    if (vwapEntryCandles === 'single') {
      // SINGLE CANDLE MODE: Current candle does everything (instant entry)
      if (touchesZone(currentCandle)) {
        // BULLISH BOUNCE: touches zone + closes above VWAP line
        if (currentCandle.close > vwapLevel) {
          signal = { type: 'LONG', pattern: 'Bounce' };
        }
        // BEARISH BOUNCE: touches zone + closes below VWAP line
        else if (currentCandle.close < vwapLevel) {
          signal = { type: 'SHORT', pattern: 'Bounce' };
        }
      }
      
      // CROSS PATTERN: touches zone + closes OUTSIDE threshold opposite side
      if (!signal && touchesZone(currentCandle)) {
        // BULLISH CROSS: closes above upper zone
        if (currentCandle.close > upperZone) {
          signal = { type: 'LONG', pattern: 'Cross' };
        }
        // BEARISH CROSS: closes below lower zone
        else if (currentCandle.close < lowerZone) {
          signal = { type: 'SHORT', pattern: 'Cross' };
        }
      }
    } else {
      // DOUBLE CANDLE MODE: Previous candle touches, current candle confirms
      if (touchesZone(prevCandle)) {
        // BULLISH BOUNCE: prev touched zone, current confirms by closing above VWAP
        if (currentCandle.close > vwapLevel) {
          signal = { type: 'LONG', pattern: 'Bounce' };
        }
        // BEARISH BOUNCE: prev touched zone, current confirms by closing below VWAP
        else if (currentCandle.close < vwapLevel) {
          signal = { type: 'SHORT', pattern: 'Bounce' };
        }
      }
      
      // CROSS PATTERN: prev touched zone, current confirms by closing OUTSIDE zone
      if (!signal && touchesZone(prevCandle)) {
        // BULLISH CROSS: confirms by closing above upper zone
        if (currentCandle.close > upperZone) {
          signal = { type: 'LONG', pattern: 'Cross' };
        }
        // BEARISH CROSS: confirms by closing below lower zone
        else if (currentCandle.close < lowerZone) {
          signal = { type: 'SHORT', pattern: 'Cross' };
        }
      }
    }
    
    if (!signal) return null;
    
    const isLong = signal.type === 'LONG';
    if (!checkDirectionFilter(signal.type)) return null;
    
    const entry = currentCandle.close;
    const atr = getCurrentATR(data);
    
    // Calculate stop loss
    const slConfig = vwapTPSL.sl;
    let stopLoss: number;
    if (slConfig.type === 'atr') {
      stopLoss = isLong ? vwapLevel - (atr * (slConfig.atrMultiplier || 1.5)) : vwapLevel + (atr * (slConfig.atrMultiplier || 1.5));
    } else if (slConfig.type === 'structure') {
      stopLoss = isLong ? vwapLevel - atr : vwapLevel + atr;
    } else {
      const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
      stopLoss = isLong ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
    }
    
    const riskAmount = Math.abs(entry - stopLoss);
    const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, isLong ? 'long' : 'short', vwapTPSwingLength);
    
    // Calculate TPs
    const { tp1: tp1Config, tp2: tp2Config } = vwapTPSL;
    
    let tp1: number, tp2: number, tp3: number;
    let tp1Type: TPType = tp1Config.type;
    let tp2Type: TPType = tp2Config?.type || 'structure';
    let tp3Type: TPType = 'projection';
    
    // TP1
    if (tp1Config.type === 'ema' || tp1Config.type === 'vwap') {
      // EMA/VWAP exits have no price target - only exit on signal
      tp1 = isLong ? Infinity : -Infinity;
    } else if (tp1Config.type === 'atr') {
      tp1 = isLong ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
    } else if (tp1Config.type === 'structure') {
      tp1 = structureTP2;
    } else if (tp1Config.type === 'fixed_rr') {
      tp1 = isLong ? entry + (riskAmount * (tp1Config.fixedRR || 2.0)) : entry - (riskAmount * (tp1Config.fixedRR || 2.0));
    } else {
      tp1 = structureTP2;
    }
    
    // TP2
    if (tp2Config?.type === 'ema' || tp2Config?.type === 'vwap') {
      // EMA/VWAP exits have no price target - only exit on signal
      tp2 = isLong ? Infinity : -Infinity;
    } else if (tp2Config?.type === 'atr') {
      tp2 = isLong ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
    } else if (tp2Config?.type === 'fixed_rr') {
      tp2 = isLong ? entry + (riskAmount * (tp2Config.fixedRR || 3.0)) : entry - (riskAmount * (tp2Config.fixedRR || 3.0));
    } else {
      tp2 = structureTP3;
    }
    
    // TP3
    if (vwapTPSL.tp3?.type === 'ema' || vwapTPSL.tp3?.type === 'vwap') {
      tp3 = isLong ? Infinity : -Infinity;
    } else {
      tp3 = isLong ? entry + (structureTP2 - entry) * 1.5 : entry - (entry - structureTP2) * 1.5;
    }
    
    // Capture EMA state at entry for crossover exit detection
    let entryEMAState: 'fast_above_slow' | 'fast_below_slow' | undefined;
    const hasEMAExit = vwapTPSL.tp1.type === 'ema' || vwapTPSL.tp2?.type === 'ema' || vwapTPSL.tp3?.type === 'ema';
    if (hasEMAExit) {
      const tp1EMA = vwapTPSL.tp1.type === 'ema' ? vwapTPSL.tp1 : (vwapTPSL.tp2?.type === 'ema' ? vwapTPSL.tp2 : vwapTPSL.tp3);
      // Use configured EMA periods or defaults (match backtest defaults)
      const fastPeriod = (tp1EMA as any)?.fastEMA || 10;
      const slowPeriod = (tp1EMA as any)?.slowEMA || 40;
      
      const closes = data.map(c => c.close);
      const fastEMAValues = calculateEMA(closes, fastPeriod);
      const slowEMAValues = calculateEMA(closes, slowPeriod);
      if (fastEMAValues.length > 0 && slowEMAValues.length > 0) {
        const currentFast = fastEMAValues[fastEMAValues.length - 1];
        const currentSlow = slowEMAValues[slowEMAValues.length - 1];
        entryEMAState = currentFast >= currentSlow ? 'fast_above_slow' : 'fast_below_slow';
      }
    }
    
    return {
      id: `vwap_${signal.pattern.toLowerCase()}_${currentCandle.time}_${isLong ? 'long' : 'short'}`,
      time: currentCandle.time,
      type: signal.type,
      strategy: 'vwap_rejection',
      entry,
      stopLoss,
      tp1,
      tp2,
      tp3,
      tp1Type,
      tp2Type,
      tp3Type,
      tp1Config: vwapTPSL.tp1,
      tp2Config: vwapTPSL.tp2,
      tp3Config: vwapTPSL.tp3,
      riskReward1: Math.abs(tp1 - entry) / riskAmount,
      riskReward2: Math.abs(tp2 - entry) / riskAmount,
      riskReward3: Math.abs(tp3 - entry) / riskAmount,
      quantity: calculatePositionSize(entry, stopLoss),
      reason: `VWAP ${signal.pattern} at ${vwapLevel.toFixed(4)}`,
      active: true,
      entryEMAState,
    };
  }, [stratVWAPRejection, vwapType, calculatePeriodicVWAP, calculateRollingVWAP, getCurrentATR, vwapTPSL, findNextSwingLevels, calculatePositionSize, checkDirectionFilter, vwapThreshold, vwapTPSwingLength, calculateEMA, vwapEntryCandles]);

  // Generate EMA Trading signal (Bounce, Cross, and Trend Trade patterns)
  const generateEMATradingSignal = useCallback((data: CandleData[]): TradeSignal | null => {
    if (!stratEMATrading || data.length < 50) return null;
    
    // Calculate EMA based on entry mode
    let emaLevel: number | null = null;
    let fastEMA: number | null = null;
    let slowEMA: number | null = null;
    
    if (emaEntryMode === 'bounce' || emaEntryMode === 'cross') {
      const emaValues = calculateEMA(data, emaSinglePeriod);
      if (emaValues.length < 3) return null;
      emaLevel = emaValues[emaValues.length - 1];
    } else {
      const fastEMAValues = calculateEMA(data, emaFastPeriod);
      const slowEMAValues = calculateEMA(data, emaSlowPeriod);
      if (fastEMAValues.length < 3 || slowEMAValues.length < 3) return null;
      fastEMA = fastEMAValues[fastEMAValues.length - 1];
      slowEMA = slowEMAValues[slowEMAValues.length - 1];
      const prevFastEMA = fastEMAValues[fastEMAValues.length - 2];
      const prevSlowEMA = slowEMAValues[slowEMAValues.length - 2];
      
      // Trend Trade: Fast EMA crosses Slow EMA
      const bullishCross = prevFastEMA <= prevSlowEMA && fastEMA > slowEMA;
      const bearishCross = prevFastEMA >= prevSlowEMA && fastEMA < slowEMA;
      
      if (!bullishCross && !bearishCross) return null;
      
      const signal: 'LONG' | 'SHORT' = bullishCross ? 'LONG' : 'SHORT';
      if (!checkDirectionFilter(signal)) return null;
      
      const currentCandle = data[data.length - 1];
      const entry = currentCandle.close;
      const atr = getCurrentATR(data);
      
      // Calculate stop loss
      const slConfig = emaTradingTPSL.sl;
      let stopLoss: number;
      if (slConfig.type === 'atr') {
        stopLoss = signal === 'LONG' ? entry - (atr * (slConfig.atrMultiplier || 1.5)) : entry + (atr * (slConfig.atrMultiplier || 1.5));
      } else if (slConfig.type === 'structure') {
        const swings = calculateSwings(data, emaTradingSLSwingLength);
        const recentSwings = swings.slice(-10);
        const swingLevels = signal === 'LONG' ? recentSwings.filter(s => s.type === 'low').map(s => s.price) : recentSwings.filter(s => s.type === 'high').map(s => s.price);
        stopLoss = signal === 'LONG' ? (swingLevels.length > 0 ? Math.max(...swingLevels) : entry - atr) : (swingLevels.length > 0 ? Math.min(...swingLevels) : entry + atr);
      } else {
        const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
        stopLoss = signal === 'LONG' ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
      }
      
      const riskAmount = Math.abs(entry - stopLoss);
      const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, signal === 'LONG' ? 'long' : 'short', emaTradingTPSwingLength);
      
      // Calculate TPs
      const { tp1: tp1Config, tp2: tp2Config } = emaTradingTPSL;
      
      let tp1: number, tp2: number, tp3: number;
      let tp1Type: TPType = tp1Config.type;
      let tp2Type: TPType = tp2Config?.type || 'structure';
      
      if (tp1Config.type === 'ema' || tp1Config.type === 'vwap') {
        // EMA/VWAP exits have no price target - only exit on signal
        tp1 = signal === 'LONG' ? Infinity : -Infinity;
      } else if (tp1Config.type === 'atr') {
        tp1 = signal === 'LONG' ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
      } else if (tp1Config.type === 'structure') {
        tp1 = structureTP2;
      } else if (tp1Config.type === 'fixed_rr') {
        tp1 = signal === 'LONG' ? entry + (riskAmount * (tp1Config.fixedRR || 2.0)) : entry - (riskAmount * (tp1Config.fixedRR || 2.0));
      } else {
        tp1 = structureTP2;
      }
      
      if (tp2Config?.type === 'ema' || tp2Config?.type === 'vwap') {
        tp2 = signal === 'LONG' ? Infinity : -Infinity;
      } else if (tp2Config?.type === 'atr') {
        tp2 = signal === 'LONG' ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
      } else if (tp2Config?.type === 'fixed_rr') {
        tp2 = signal === 'LONG' ? entry + (riskAmount * (tp2Config.fixedRR || 3.0)) : entry - (riskAmount * (tp2Config.fixedRR || 3.0));
      } else {
        tp2 = structureTP3;
      }
      
      if (emaTradingTPSL.tp3?.type === 'ema' || emaTradingTPSL.tp3?.type === 'vwap') {
        tp3 = signal === 'LONG' ? Infinity : -Infinity;
      } else {
        tp3 = signal === 'LONG' ? entry + (structureTP2 - entry) * 1.5 : entry - (entry - structureTP2) * 1.5;
      }
      
      // Capture EMA state at entry for crossover exit detection
      let entryEMAState: 'fast_above_slow' | 'fast_below_slow' | undefined;
      const hasEMAExit = tp1Type === 'ema' || tp2Type === 'ema' || emaTradingTPSL.tp3?.type === 'ema';
      if (hasEMAExit && fastEMA !== null && slowEMA !== null) {
        entryEMAState = fastEMA >= slowEMA ? 'fast_above_slow' : 'fast_below_slow';
      }
      
      return {
        id: `ema_trend_${currentCandle.time}_${signal.toLowerCase()}`,
        time: currentCandle.time,
        type: signal,
        strategy: 'ema_trading',
        entry,
        stopLoss,
        tp1,
        tp2,
        tp3,
        tp1Type,
        tp2Type,
        tp3Type: 'projection',
        riskReward1: Math.abs(tp1 - entry) / riskAmount,
        riskReward2: Math.abs(tp2 - entry) / riskAmount,
        riskReward3: Math.abs(tp3 - entry) / riskAmount,
        quantity: calculatePositionSize(entry, stopLoss),
        reason: `EMA Crossover (${emaFastPeriod}/${emaSlowPeriod})`,
        active: true,
        entryEMAState,
      };
    }
    
    // For Bounce and Cross modes
    if (data.length < 3 || !emaLevel) return null;
    
    const prevCandle = data[data.length - 3];
    const entryCandle = data[data.length - 2];
    const confirmCandle = data[data.length - 1];
    
    const tolerance = emaLevel * (emaThreshold / 100);
    const upperZone = emaLevel + tolerance;
    const lowerZone = emaLevel - tolerance;
    
    const inZone = (c: CandleData) => c.high >= lowerZone && c.low <= upperZone;
    const aboveZone = (c: CandleData) => c.low > upperZone;
    const belowZone = (c: CandleData) => c.high < lowerZone;
    
    let signal: { type: 'LONG' | 'SHORT', pattern: 'Bounce' | 'Cross' } | null = null;
    
    if (emaEntryMode === 'bounce' && inZone(entryCandle)) {
      if (belowZone(prevCandle) && confirmCandle.close > emaLevel) {
        signal = { type: 'LONG', pattern: 'Bounce' };
      } else if (aboveZone(prevCandle) && confirmCandle.close < emaLevel) {
        signal = { type: 'SHORT', pattern: 'Bounce' };
      }
    }
    
    if (emaEntryMode === 'cross' && !signal && inZone(entryCandle)) {
      if (belowZone(prevCandle) && confirmCandle.close > upperZone) {
        signal = { type: 'LONG', pattern: 'Cross' };
      } else if (aboveZone(prevCandle) && confirmCandle.close < lowerZone) {
        signal = { type: 'SHORT', pattern: 'Cross' };
      }
    }
    
    if (!signal) return null;
    if (!checkDirectionFilter(signal.type)) return null;
    
    const entry = confirmCandle.close;
    const atr = getCurrentATR(data);
    
    // Calculate stop loss
    const slConfig = emaTradingTPSL.sl;
    let stopLoss: number;
    if (slConfig.type === 'atr') {
      stopLoss = signal.type === 'LONG' ? emaLevel - (atr * (slConfig.atrMultiplier || 1.5)) : emaLevel + (atr * (slConfig.atrMultiplier || 1.5));
    } else if (slConfig.type === 'structure') {
      stopLoss = signal.type === 'LONG' ? emaLevel - atr : emaLevel + atr;
    } else {
      const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
      stopLoss = signal.type === 'LONG' ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
    }
    
    const riskAmount = Math.abs(entry - stopLoss);
    const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, signal.type === 'LONG' ? 'long' : 'short', emaTradingTPSwingLength);
    
    // Calculate TPs
    const { tp1: tp1Config, tp2: tp2Config } = emaTradingTPSL;
    
    let tp1: number, tp2: number, tp3: number;
    let tp1Type: TPType = tp1Config.type;
    let tp2Type: TPType = tp2Config?.type || 'structure';
    
    if (tp1Config.type === 'ema' || tp1Config.type === 'vwap') {
      // EMA/VWAP exits have no price target - only exit on signal
      tp1 = signal.type === 'LONG' ? Infinity : -Infinity;
    } else if (tp1Config.type === 'atr') {
      tp1 = signal.type === 'LONG' ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
    } else if (tp1Config.type === 'structure') {
      tp1 = structureTP2;
    } else if (tp1Config.type === 'fixed_rr') {
      tp1 = signal.type === 'LONG' ? entry + (riskAmount * (tp1Config.fixedRR || 2.0)) : entry - (riskAmount * (tp1Config.fixedRR || 2.0));
    } else {
      tp1 = structureTP2;
    }
    
    if (tp2Config?.type === 'ema' || tp2Config?.type === 'vwap') {
      tp2 = signal.type === 'LONG' ? Infinity : -Infinity;
    } else if (tp2Config?.type === 'atr') {
      tp2 = signal.type === 'LONG' ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
    } else if (tp2Config?.type === 'fixed_rr') {
      tp2 = signal.type === 'LONG' ? entry + (riskAmount * (tp2Config.fixedRR || 3.0)) : entry - (riskAmount * (tp2Config.fixedRR || 3.0));
    } else {
      tp2 = structureTP3;
    }
    
    if (emaTradingTPSL.tp3?.type === 'ema' || emaTradingTPSL.tp3?.type === 'vwap') {
      tp3 = signal.type === 'LONG' ? Infinity : -Infinity;
    } else {
      tp3 = signal.type === 'LONG' ? entry + (structureTP2 - entry) * 1.5 : entry - (entry - structureTP2) * 1.5;
    }
    
    // Capture EMA state at entry for crossover exit detection (if EMA exit configured)
    let entryEMAState: 'fast_above_slow' | 'fast_below_slow' | undefined;
    const hasEMAExit = tp1Type === 'ema' || tp2Type === 'ema' || emaTradingTPSL.tp3?.type === 'ema';
    if (hasEMAExit) {
      const tp1EMA = tp1Config.type === 'ema' ? tp1Config : (tp2Config?.type === 'ema' ? tp2Config : emaTradingTPSL.tp3);
      // Use configured EMA periods or defaults (match backtest defaults)
      const fastPeriod = (tp1EMA as any)?.fastEMA || 10;
      const slowPeriod = (tp1EMA as any)?.slowEMA || 40;
      
      const closes = data.map(c => c.close);
      const fastEMAValues = calculateEMA(closes, fastPeriod);
      const slowEMAValues = calculateEMA(closes, slowPeriod);
      if (fastEMAValues.length > 0 && slowEMAValues.length > 0) {
        const currentFast = fastEMAValues[fastEMAValues.length - 1];
        const currentSlow = slowEMAValues[slowEMAValues.length - 1];
        entryEMAState = currentFast >= currentSlow ? 'fast_above_slow' : 'fast_below_slow';
      }
    }
    
    return {
      id: `ema_${signal.pattern.toLowerCase()}_${entryCandle.time}_${signal.type.toLowerCase()}`,
      time: confirmCandle.time,
      type: signal.type,
      strategy: 'ema_trading',
      entry,
      stopLoss,
      tp1,
      tp2,
      tp3,
      tp1Type,
      tp2Type,
      tp3Type: 'projection',
      riskReward1: Math.abs(tp1 - entry) / riskAmount,
      riskReward2: Math.abs(tp2 - entry) / riskAmount,
      riskReward3: Math.abs(tp3 - entry) / riskAmount,
      quantity: calculatePositionSize(entry, stopLoss),
      reason: `EMA ${signal.pattern} at ${emaLevel.toFixed(4)} (${emaSinglePeriod}MA)`,
      active: true,
      entryEMAState,
    };
  }, [stratEMATrading, emaEntryMode, calculateEMA, emaSinglePeriod, emaFastPeriod, emaSlowPeriod, emaThreshold, getCurrentATR, emaTradingTPSL, calculateSwings, emaTradingSLSwingLength, findNextSwingLevels, emaTradingTPSwingLength, calculatePositionSize, checkDirectionFilter]);

  // Generate R/S Flip signal (Resistance/Support Flip - retest after breakout)
  const generateRSFlipSignal = useCallback((data: CandleData[]): TradeSignal | null => {
    if (!stratRSFlip || data.length < 100) return null;
    
    // Detect trendlines
    const trendlines = detectTrendlines(data, trendlineMinTouches, trendlineTolerance, trendlinePivotLength);
    if (trendlines.length === 0) return null;
    
    const currentCandle = data[data.length - 1];
    const currentPrice = currentCandle.close;
    
    // Look for recent breakouts (within last rsFlipRetestCandles)
    for (const line of trendlines) {
      const currentLinePrice = line.slope * (data.length - 1) + line.intercept;
      
      // Check if we're near the broken trendline (within 0.5%)
      const tolerance = currentLinePrice * 0.005;
      const nearLine = Math.abs(currentPrice - currentLinePrice) < tolerance;
      
      if (!nearLine) continue;
      
      // Look back to find the breakout candle
      let breakoutIdx = -1;
      for (let i = data.length - 2; i >= Math.max(0, data.length - rsFlipRetestCandles - 1); i--) {
        const prevCandle = data[i - 1];
        const candle = data[i];
        const linePrice = line.slope * i + line.intercept;
        const prevLinePrice = line.slope * (i - 1) + line.intercept;
        
        if (line.type === 'resistance') {
          // Bullish breakout: was below, closed above
          if (prevCandle.close < prevLinePrice && candle.close > linePrice) {
            breakoutIdx = i;
            break;
          }
        } else {
          // Bearish breakout: was above, closed below
          if (prevCandle.close > prevLinePrice && candle.close < linePrice) {
            breakoutIdx = i;
            break;
          }
        }
      }
      
      if (breakoutIdx === -1) continue; // No recent breakout found
      
      // Check if this is a retest (price came back to the line)
      const candlesSinceBreakout = data.length - 1 - breakoutIdx;
      if (candlesSinceBreakout < 2 || candlesSinceBreakout > rsFlipRetestCandles) continue;
      
      // Confirm rejection/bounce at the retested level
      const isLong = line.type === 'resistance'; // Broken resistance becomes support
      
      // Look for rejection pattern on current or recent candles
      let hasRejection = false;
      for (let i = Math.max(0, data.length - 3); i < data.length; i++) {
        const c = data[i];
        const linePrice = line.slope * i + line.intercept;
        
        if (isLong) {
          // For support (former resistance): wick below, close above
          const wickedBelow = c.low < linePrice && c.close > linePrice;
          if (wickedBelow) hasRejection = true;
        } else {
          // For resistance (former support): wick above, close below
          const wickedAbove = c.high > linePrice && c.close < linePrice;
          if (wickedAbove) hasRejection = true;
        }
      }
      
      if (!hasRejection) continue;
      
      // Check direction filter
      if (rsFlipDirectionFilter !== 'both') {
        if (rsFlipDirectionFilter === 'bull' && !isLong) continue;
        if (rsFlipDirectionFilter === 'bear' && isLong) continue;
      }
      
      // Check trend filter (if enabled)
      if (rsFlipTrendFilter !== 'none') {
        if (rsFlipTrendFilter === 'ema' && bias === null) continue;
        if (rsFlipTrendFilter === 'structure' && (structureTrend === null || structureTrend === 'ranging')) continue;
        if (rsFlipTrendFilter === 'both') {
          const emaBullish = bias === 'bullish';
          const structureBullish = structureTrend === 'uptrend';
          const emaBearish = bias === 'bearish';
          const structureBearish = structureTrend === 'downtrend';
          if (!((emaBullish && structureBullish) || (emaBearish && structureBearish))) continue;
        }
      }
      
      // Generate signal
      const entry = currentPrice;
      const atr = getCurrentATR(data);
      
      // Use bot-specific SL configuration
      const slConfig = rsFlipTPSL.sl;
      let stopLoss: number;
      if (slConfig.type === 'structure') {
        // Place SL just beyond the broken trendline
        const buffer = currentLinePrice * 0.003; // 0.3% buffer
        stopLoss = isLong ? currentLinePrice - buffer : currentLinePrice + buffer;
      } else if (slConfig.type === 'atr') {
        stopLoss = isLong ? entry - (atr * (slConfig.atrMultiplier || 1.5)) : entry + (atr * (slConfig.atrMultiplier || 1.5));
      } else {
        const distancePercent = (slConfig.fixedDistance || 1.0) / 100;
        stopLoss = isLong ? entry * (1 - distancePercent) : entry * (1 + distancePercent);
      }
      
      const riskAmount = Math.abs(entry - stopLoss);
      const { tp2: structureTP2, tp3: structureTP3 } = findNextSwingLevels(data, entry, isLong ? 'long' : 'short', rsFlipTPSwingLength);
      
      // Calculate TPs based on bot-specific config
      const { tp1: tp1Config, tp2: tp2Config } = rsFlipTPSL;
      
      let tp1: number, tp2: number, tp3: number;
      let tp1Type: TPType = tp1Config.type;
      let tp2Type: TPType = tp2Config?.type || 'structure';
      let tp3Type: TPType = 'projection';
      
      // TP1 calculation
      if (tp1Config.type === 'atr') {
        tp1 = isLong ? entry + (atr * (tp1Config.atrMultiplier || 1.5)) : entry - (atr * (tp1Config.atrMultiplier || 1.5));
      } else if (tp1Config.type === 'structure') {
        tp1 = structureTP2;
      } else if (tp1Config.type === 'fixed_rr') {
        tp1 = isLong ? entry + (riskAmount * (tp1Config.fixedRR || 2.0)) : entry - (riskAmount * (tp1Config.fixedRR || 2.0));
      } else {
        tp1 = structureTP2;
      }
      
      // TP2 calculation
      if (tp2Config?.type === 'atr') {
        tp2 = isLong ? entry + (atr * (tp2Config.atrMultiplier || 2.0)) : entry - (atr * (tp2Config.atrMultiplier || 2.0));
      } else if (tp2Config?.type === 'fixed_rr') {
        tp2 = isLong ? entry + (riskAmount * (tp2Config.fixedRR || 3.0)) : entry - (riskAmount * (tp2Config.fixedRR || 3.0));
      } else {
        tp2 = structureTP3;
      }
      
      // TP3 (default projection)
      tp3 = isLong ? entry + (structureTP2 - entry) * 1.5 : entry - (entry - structureTP2) * 1.5;
      
      // Found a valid R/S Flip signal
      return {
        id: `rs_flip_${line.type}_${breakoutIdx}`,
        time: currentCandle.time,
        type: isLong ? 'LONG' : 'SHORT',
        strategy: 'rs_flip',
        entry,
        stopLoss,
        tp1,
        tp2,
        tp3,
        tp1Type,
        tp2Type,
        tp3Type,
        riskReward1: Math.abs(tp1 - entry) / riskAmount,
        riskReward2: Math.abs(tp2 - entry) / riskAmount,
        riskReward3: Math.abs(tp3 - entry) / riskAmount,
        quantity: calculatePositionSize(entry, stopLoss),
        reason: `${line.type === 'resistance' ? 'Resistance' : 'Support'} flip retest at ${currentLinePrice.toFixed(4)}`,
        active: true,
      };
    }
    
    return null; // No valid R/S flip found
  }, [stratRSFlip, detectTrendlines, trendlineMinTouches, trendlineTolerance, trendlinePivotLength, rsFlipRetestCandles, rsFlipDirectionFilter, rsFlipTrendFilter, bias, structureTrend, getCurrentATR, rsFlipTPSL, findNextSwingLevels, calculatePositionSize, rsFlipTPSwingLength]);

  // Master signal generator - checks all enabled strategies
  const generateSignals = useCallback(() => {
    if (!botEnabled || candles.length < 50 || !checkTrendFilter()) return;
    
    const newSignals: TradeSignal[] = [];
    
    // NOTE: Liquidity Grab is now visual-only (removed signal generation)
    // Only show cyan markers on chart, no trade signals
    
    const chochFVGSignal = generateChochFVGSignal(candles);
    if (chochFVGSignal) newSignals.push(chochFVGSignal);
    
    const vwapSignal = generateVWAPTradingSignal(candles);
    if (vwapSignal) newSignals.push(vwapSignal);
    
    const bosTrendSignal = generateBOSTrendSignal(candles);
    if (bosTrendSignal) newSignals.push(bosTrendSignal);
    
    if (newSignals.length > 0) {
      setTradeSignals(prev => {
        // Remove duplicate signals for same strategy
        const filtered = prev.filter(s => 
          !newSignals.some(ns => ns.strategy === s.strategy && s.active)
        );
        return [...filtered, ...newSignals];
      });
    }
  }, [botEnabled, candles, checkTrendFilter, generateChochFVGSignal, generateVWAPTradingSignal, generateBOSTrendSignal]);

  // Detect market structure events and populate alerts
  const detectMarketAlerts = useCallback(() => {
    if (candles.length < 50) return;
    
    const { bos, choch } = calculateBOSandCHoCH(
      candles,
      liqGrabSwingLength,
      liqGrabConfirmCandles,
      liqGrabWickRatio,
      liqGrabUseWickFilter,
      liqGrabUseConfirmCandles
    );
    
    const newAlerts: MarketAlert[] = [];
    
    // Add BOS alerts
    bos.forEach(bosEvent => {
      const alertType = bosEvent.isLiquidityGrab ? 'Liquidity Sweep' : 'BOS';
      const description = bosEvent.isLiquidityGrab 
        ? `${bosEvent.type === 'bullish' ? 'Bullish' : 'Bearish'} liquidity sweep at ${bosEvent.swingPrice.toFixed(4)}`
        : `${bosEvent.type === 'bullish' ? 'Bullish' : 'Bearish'} BOS at ${bosEvent.swingPrice.toFixed(4)}`;
      
      newAlerts.push({
        id: `alert_${bosEvent.breakTime}_${alertType}`,
        time: bosEvent.breakTime,
        type: alertType,
        direction: bosEvent.type,
        price: bosEvent.swingPrice,
        description,
      });
    });
    
    // Add CHoCH alerts
    choch.forEach(chochEvent => {
      const alertType = chochEvent.isLiquidityGrab ? 'Liquidity Sweep' : 'CHoCH';
      const description = chochEvent.isLiquidityGrab
        ? `${chochEvent.type === 'bullish' ? 'Bullish' : 'Bearish'} liquidity sweep at ${chochEvent.swingPrice.toFixed(4)}`
        : `${chochEvent.type === 'bullish' ? 'Bullish' : 'Bearish'} CHoCH at ${chochEvent.swingPrice.toFixed(4)}`;
      
      newAlerts.push({
        id: `alert_${chochEvent.breakTime}_${alertType}`,
        time: chochEvent.breakTime,
        type: alertType,
        direction: chochEvent.type,
        price: chochEvent.swingPrice,
        description,
      });
    });
    
    // Add high-value FVG alerts
    const fvgs = calculateFVGs(candles, true);
    fvgs.forEach(fvg => {
      if (fvg.isHighValue && isActiveFVG(fvg, candles)) {
        newAlerts.push({
          id: `alert_${fvg.time}_FVG`,
          time: fvg.time,
          type: 'FVG',
          direction: fvg.type,
          price: (fvg.upper + fvg.lower) / 2,
          description: `${fvg.type === 'bullish' ? 'Bullish' : 'Bearish'} high-value FVG at ${((fvg.upper + fvg.lower) / 2).toFixed(4)}`,
        });
      }
    });
    
    // Add FVG Entry alerts (price entering FVG zones)
    // Calculate 1-week lookback limit (7 days in seconds)
    const oneWeekSeconds = 7 * 24 * 60 * 60;
    const currentTime = candles[candles.length - 1].time;
    const cutoffTime = currentTime - oneWeekSeconds;
    
    // For each active FVG, check if price entered it
    fvgs.forEach(fvg => {
      if (!isActiveFVG(fvg, candles)) return; // Skip filled FVGs
      
      const fvgIdx = candles.findIndex(c => c.time === fvg.time);
      if (fvgIdx === -1) return;
      
      // Check candles after FVG was created
      for (let i = fvgIdx + 1; i < candles.length; i++) {
        const candle = candles[i];
        const prevCandle = candles[i - 1];
        
        // Only alert on recent entries (within 1 week)
        if (candle.time < cutoffTime) continue;
        
        // Check if price entered the FVG zone on this candle
        // Bullish FVG entry: price moves DOWN into bullish FVG
        if (fvg.type === 'bullish') {
          const wasAboveFVG = prevCandle.low > fvg.upper;
          const enteredFVG = candle.low <= fvg.upper && candle.low >= fvg.lower;
          
          if (wasAboveFVG && enteredFVG) {
            newAlerts.push({
              id: `alert_${candle.time}_FVG_ENTRY_BULL_${fvg.time}`,
              time: candle.time,
              type: 'FVG Entry',
              direction: 'bullish',
              price: candle.low,
              description: `Bullish FVG entry at ${candle.low.toFixed(4)} (zone: ${fvg.lower.toFixed(4)}-${fvg.upper.toFixed(4)})`,
            });
            break; // Only alert once per FVG
          }
        }
        
        // Bearish FVG entry: price moves UP into bearish FVG
        if (fvg.type === 'bearish') {
          const wasBelowFVG = prevCandle.high < fvg.lower;
          const enteredFVG = candle.high >= fvg.lower && candle.high <= fvg.upper;
          
          if (wasBelowFVG && enteredFVG) {
            newAlerts.push({
              id: `alert_${candle.time}_FVG_ENTRY_BEAR_${fvg.time}`,
              time: candle.time,
              type: 'FVG Entry',
              direction: 'bearish',
              price: candle.high,
              description: `Bearish FVG entry at ${candle.high.toFixed(4)} (zone: ${fvg.lower.toFixed(4)}-${fvg.upper.toFixed(4)})`,
            });
            break; // Only alert once per FVG
          }
        }
      }
    });
    
    // Add VWAP rejection and cross alerts using HISTORICAL weekly VWAP values with 1-week lookback
    const weeklyVWAP = calculatePeriodicVWAP(candles, 'weekly', true);
    if (weeklyVWAP.length > 0 && candles.length > 1) {
      // Calculate 1-week lookback limit (7 days in seconds)
      const oneWeekSeconds = 7 * 24 * 60 * 60;
      const currentTime = candles[candles.length - 1].time;
      const cutoffTime = currentTime - oneWeekSeconds;
      
      console.log(`ðŸ“Š VWAP Alert Detection - Using historical VWAP values, 1-week lookback from ${new Date(cutoffTime * 1000).toLocaleString()}`);
      
      // Create a map for fast VWAP value lookup by timestamp
      const vwapMap = new Map<number, number>();
      weeklyVWAP.forEach(v => vwapMap.set(v.time, v.value));
      
      // Check candles within 1-week lookback window
      for (let i = 1; i < candles.length; i++) {
        const candle = candles[i];
        const prevCandle = candles[i - 1];
        
        // Skip candles older than 1 week
        if (candle.time < cutoffTime) continue;
        
        // Get historical VWAP value for this candle's timestamp
        const vwapValue = vwapMap.get(candle.time);
        const prevVwapValue = vwapMap.get(prevCandle.time);
        
        // Skip if we don't have VWAP data for this candle
        if (vwapValue === undefined || prevVwapValue === undefined) continue;
        
        // Check for VWAP Crosses first (takes priority over rejections)
        // Bullish cross: previous close below VWAP, current close above VWAP
        const isBullishCross = prevCandle.close < prevVwapValue && candle.close > vwapValue;
        // Bearish cross: previous close above VWAP, current close below VWAP
        const isBearishCross = prevCandle.close > prevVwapValue && candle.close < vwapValue;
        
        if (isBullishCross) {
          console.log(`ðŸŸ¢ VWAP Bullish Cross at ${new Date(candle.time * 1000).toLocaleString()}, VWAP: ${vwapValue.toFixed(4)}`);
          newAlerts.push({
            id: `alert_${candle.time}_VWAP_CROSS_BULL`,
            time: candle.time,
            type: 'VWAP Cross',
            direction: 'bullish',
            price: vwapValue,
            description: `Bullish VWAP cross at ${vwapValue.toFixed(4)}`,
          });
        } else if (isBearishCross) {
          console.log(`ðŸ”´ VWAP Bearish Cross at ${new Date(candle.time * 1000).toLocaleString()}, VWAP: ${vwapValue.toFixed(4)}`);
          newAlerts.push({
            id: `alert_${candle.time}_VWAP_CROSS_BEAR`,
            time: candle.time,
            type: 'VWAP Cross',
            direction: 'bearish',
            price: vwapValue,
            description: `Bearish VWAP cross at ${vwapValue.toFixed(4)}`,
          });
        } else {
          // Only check for bounces if it's NOT a cross
          // VWAP Bounces: enters VWAP zone, close stays on same side (AND previous close was same side)
          const vwapZone = vwapValue * (vwapThreshold / 100);
          
          // Bullish bounce: wick enters VWAP zone from below, close above zone, previous close above zone
          const enteredZoneFromBelow = candle.low <= vwapValue + vwapZone && candle.low >= vwapValue - vwapZone;
          const closedAboveZone = candle.close > vwapValue + vwapZone;
          const prevClosedAboveZone = prevCandle.close > prevVwapValue + (prevVwapValue * (vwapThreshold / 100));
          
          if (enteredZoneFromBelow && closedAboveZone && prevClosedAboveZone) {
            console.log(`ðŸŸ¢ VWAP Bullish Bounce at ${new Date(candle.time * 1000).toLocaleString()}, VWAP: ${vwapValue.toFixed(4)}, Zone: Â±${vwapThreshold}%`);
            newAlerts.push({
              id: `alert_${candle.time}_VWAP_BOUNCE_BULL`,
              time: candle.time,
              type: 'VWAP Bounce',
              direction: 'bullish',
              price: vwapValue,
              description: `Bullish VWAP bounce at ${vwapValue.toFixed(4)}`,
            });
          }
          
          // Bearish bounce: wick enters VWAP zone from above, close below zone, previous close below zone
          const enteredZoneFromAbove = candle.high >= vwapValue - vwapZone && candle.high <= vwapValue + vwapZone;
          const closedBelowZone = candle.close < vwapValue - vwapZone;
          const prevClosedBelowZone = prevCandle.close < prevVwapValue - (prevVwapValue * (vwapThreshold / 100));
          
          if (enteredZoneFromAbove && closedBelowZone && prevClosedBelowZone) {
            console.log(`ðŸ”´ VWAP Bearish Bounce at ${new Date(candle.time * 1000).toLocaleString()}, VWAP: ${vwapValue.toFixed(4)}, Zone: Â±${vwapThreshold}%`);
            newAlerts.push({
              id: `alert_${candle.time}_VWAP_BOUNCE_BEAR`,
              time: candle.time,
              type: 'VWAP Bounce',
              direction: 'bearish',
              price: vwapValue,
              description: `Bearish VWAP bounce at ${vwapValue.toFixed(4)}`,
            });
          }
        }
      }
    }
    
    // Add Trendline Breakout and Rejection alerts with 1-week lookback
    if (candles.length > 100) {
      // Get effective pivot length (adaptive or user-set)
      const adaptivePivotLength = candles.length > 1000 ? 20 : candles.length > 500 ? 15 : 10;
      const effectivePivotLength = trendlinePivotLength || adaptivePivotLength;
      
      // Detect current trendlines
      const trendlines = detectTrendlines(candles, trendlineMinTouches, trendlineTolerance, effectivePivotLength);
      
      if (trendlines.length > 0) {
        // 1-week lookback
        const oneWeekSeconds = 7 * 24 * 60 * 60;
        const currentTime = candles[candles.length - 1].time;
        const cutoffTime = currentTime - oneWeekSeconds;
        
        trendlines.forEach(line => {
          // Check candles within 1-week window
          for (let i = 1; i < candles.length; i++) {
            const candle = candles[i];
            const prevCandle = candles[i - 1];
            
            // Skip old candles
            if (candle.time < cutoffTime) continue;
            
            // Calculate trendline price at this candle index
            const linePrice = line.slope * i + line.intercept;
            const prevLinePrice = line.slope * (i - 1) + line.intercept;
            const tolerance = linePrice * 0.003; // 0.3% tolerance zone
            
            if (line.type === 'resistance') {
              // BULLISH BREAKOUT: previous close below line, current close above line
              const wasBelowLine = prevCandle.close < prevLinePrice;
              const closedAboveLine = candle.close > linePrice;
              
              if (wasBelowLine && closedAboveLine) {
                newAlerts.push({
                  id: `alert_${candle.time}_TRENDLINE_BREAK_BULL`,
                  time: candle.time,
                  type: 'Trendline Breakout',
                  direction: 'bullish',
                  price: linePrice,
                  description: `Bullish breakout through resistance at ${linePrice.toFixed(4)}`,
                });
              }
              
              // BEARISH REJECTION: wick touches/penetrates line from below, but close stays below
              const wickTouchedLine = candle.high >= linePrice - tolerance && candle.high <= linePrice + tolerance;
              const closedBelowLine = candle.close < linePrice - tolerance;
              const prevClosedBelowLine = prevCandle.close < prevLinePrice - tolerance;
              
              if (wickTouchedLine && closedBelowLine && prevClosedBelowLine) {
                newAlerts.push({
                  id: `alert_${candle.time}_TRENDLINE_REJ_BEAR`,
                  time: candle.time,
                  type: 'Trendline Rejection',
                  direction: 'bearish',
                  price: linePrice,
                  description: `Bearish rejection at resistance ${linePrice.toFixed(4)}`,
                });
              }
            } else {
              // Support line
              // BEARISH BREAKOUT: previous close above line, current close below line
              const wasAboveLine = prevCandle.close > prevLinePrice;
              const closedBelowLine = candle.close < linePrice;
              
              if (wasAboveLine && closedBelowLine) {
                newAlerts.push({
                  id: `alert_${candle.time}_TRENDLINE_BREAK_BEAR`,
                  time: candle.time,
                  type: 'Trendline Breakout',
                  direction: 'bearish',
                  price: linePrice,
                  description: `Bearish breakdown through support at ${linePrice.toFixed(4)}`,
                });
              }
              
              // BULLISH REJECTION: wick touches/penetrates line from above, but close stays above
              const wickTouchedLine = candle.low <= linePrice + tolerance && candle.low >= linePrice - tolerance;
              const closedAboveLine = candle.close > linePrice + tolerance;
              const prevClosedAboveLine = prevCandle.close > prevLinePrice + tolerance;
              
              if (wickTouchedLine && closedAboveLine && prevClosedAboveLine) {
                newAlerts.push({
                  id: `alert_${candle.time}_TRENDLINE_REJ_BULL`,
                  time: candle.time,
                  type: 'Trendline Rejection',
                  direction: 'bullish',
                  price: linePrice,
                  description: `Bullish rejection at support ${linePrice.toFixed(4)}`,
                });
              }
            }
          }
        });
      }
    }
    
    // Sort by time descending (most recent first) and keep last 20
    const sortedAlerts = newAlerts.sort((a, b) => b.time - a.time).slice(0, 20);
    setMarketAlerts(sortedAlerts);
  }, [candles, liqGrabSwingLength, liqGrabConfirmCandles, liqGrabWickRatio, liqGrabUseWickFilter, liqGrabUseConfirmCandles, calculateBOSandCHoCH, calculateFVGs, isActiveFVG, calculatePeriodicVWAP, vwapThreshold, detectTrendlines, trendlineMinTouches, trendlineTolerance, trendlinePivotLength]);

  // Calculate weighted R:R for partial exits based on which TPs were hit
  const calculateWeightedRR = useCallback((strategy: string, outcome: string, rr1: number, rr2: number, rr3: number): number => {
    // Get bot-specific config
    let config: BotTPSLConfig;
    if (strategy === 'liquidity_grab') config = liqGrabTPSL;
    else if (strategy === 'bos_trend') config = bosTPSL;
    else if (strategy === 'choch_fvg') config = chochTPSL;
    else if (strategy === 'vwap_rejection') config = vwapTPSL;
    else return outcome === 'SL' ? -1 : rr1; // Fallback
    
    const tp1Pct = config.tp1.positionPercent / 100;
    const tp2Pct = (config.tp2?.positionPercent || 0) / 100;
    const tp3Pct = (config.tp3?.positionPercent || 0) / 100;
    
    // Calculate weighted R based on outcome
    if (outcome === 'SL') return -1;
    if (outcome === 'Breakeven') return 0;
    
    if (outcome === 'TP1') {
      // Only TP1 hit - exit full position there
      return rr1;
    } else if (outcome === 'TP2') {
      // TP1 and TP2 hit - partial exit at TP1, rest at TP2
      if (config.numTPs === 1) return rr2; // Full position
      return (tp1Pct * rr1) + ((tp2Pct + tp3Pct) * rr2);
    } else if (outcome === 'TP3') {
      // All TPs hit - partial exits at each level
      if (config.numTPs === 1) return rr3; // Full position
      if (config.numTPs === 2) return (tp1Pct * rr1) + (tp2Pct * rr3);
      return (tp1Pct * rr1) + (tp2Pct * rr2) + (tp3Pct * rr3);
    }
    
    return rr1; // Default
  }, [liqGrabTPSL, bosTPSL, chochTPSL, vwapTPSL]);

  // Simulate a single trade forward to find outcome
  // NEW: When TP1 hits, move SL to entry (breakeven) and continue
  const simulateTrade = useCallback((signal: TradeSignal, startIdx: number, data: CandleData[]): BacktestTrade | null => {
    const isLong = signal.type === 'LONG';
    
    // Trading costs (realistic Binance.US fees + slippage)
    const commissionRate = 0.001; // 0.1% per side = 0.2% round trip
    const slippageBps = 0.0005; // 0.05% slippage per trade
    
    let currentStopLoss = signal.stopLoss;
    let tp1Hit = false;
    
    // Check if any TP is set to EMA exit or VWAP exit
    const hasEMAExit = signal.tp1Type === 'ema' || signal.tp2Type === 'ema' || signal.tp3Type === 'ema';
    const hasVWAPExit = signal.tp1Type === 'vwap' || signal.tp2Type === 'vwap' || signal.tp3Type === 'vwap';
    
    // Calculate EMAs if needed for EMA exit - use TP config settings
    let emaFast: number[] = [];
    let emaSlow: number[] = [];
    let emaExitMode: 'touch' | 'crossover' = 'crossover'; // Default
    if (hasEMAExit) {
      const closes = data.map(c => c.close);
      // Get EMA settings from the first TP that has EMA exit configured
      let emaFastPeriodToUse = 10; // Default
      let emaSlowPeriodToUse = 40; // Default
      
      if (signal.tp1Type === 'ema' && signal.tp1Config) {
        emaFastPeriodToUse = signal.tp1Config.emaFast || 10;
        emaSlowPeriodToUse = signal.tp1Config.emaSlow || 40;
        emaExitMode = signal.tp1Config.emaExitMode || 'crossover';
      } else if (signal.tp2Type === 'ema' && signal.tp2Config) {
        emaFastPeriodToUse = signal.tp2Config.emaFast || 10;
        emaSlowPeriodToUse = signal.tp2Config.emaSlow || 40;
        emaExitMode = signal.tp2Config.emaExitMode || 'crossover';
      } else if (signal.tp3Type === 'ema' && signal.tp3Config) {
        emaFastPeriodToUse = signal.tp3Config.emaFast || 10;
        emaSlowPeriodToUse = signal.tp3Config.emaSlow || 40;
        emaExitMode = signal.tp3Config.emaExitMode || 'crossover';
      }
      
      emaFast = calculateEMA(closes, emaFastPeriodToUse);
      emaSlow = calculateEMA(closes, emaSlowPeriodToUse);
    }
    
    // Calculate VWAP if needed for VWAP exit
    let vwapValues: VWAPData[] = [];
    if (hasVWAPExit) {
      // Use the strategy's VWAP type setting
      if (signal.strategy === 'vwap_rejection') {
        if (vwapType === 'daily') vwapValues = calculatePeriodicVWAP(data, 'daily', true);
        else if (vwapType === 'weekly') vwapValues = calculatePeriodicVWAP(data, 'weekly', true);
        else if (vwapType === 'monthly') vwapValues = calculatePeriodicVWAP(data, 'monthly', true);
        else if (vwapType === 'rolling10') vwapValues = calculateRollingVWAP(data, 10);
        else if (vwapType === 'rolling20') vwapValues = calculateRollingVWAP(data, 20);
        else if (vwapType === 'rolling50') vwapValues = calculateRollingVWAP(data, 50);
        else vwapValues = calculatePeriodicVWAP(data, 'weekly', true); // default
      } else {
        // For other strategies, default to weekly VWAP
        vwapValues = calculatePeriodicVWAP(data, 'weekly', true);
      }
    }
    
    // Search forward from the signal to find which level hits first
    for (let i = startIdx + 1; i < data.length; i++) {
      const candle = data[i];
      
      if (isLong) {
        // Check SL first (more conservative)
        if (candle.low <= currentStopLoss) {
          const rawPL = (currentStopLoss - signal.entry) * signal.quantity;
          const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(currentStopLoss * commissionRate)) * signal.quantity;
          const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(currentStopLoss * slippageBps)) * signal.quantity;
          const netPL = rawPL - commission - slippage;
          
          return {
            id: signal.id,
            entryTime: signal.time,
            exitTime: candle.time,
            direction: 'long',
            strategy: signal.strategy,
            entry: signal.entry,
            exit: currentStopLoss,
            stopLoss: signal.stopLoss,
            tp1: signal.tp1,
            tp2: signal.tp2,
            tp3: signal.tp3,
            outcome: tp1Hit ? 'Breakeven' : 'SL',
            rr: tp1Hit ? 0 : -1,
            profitLoss: netPL,
            winner: tp1Hit ? (netPL >= 0) : false,
          };
        }
        
        // Check for EMA Exit - supports both Touch and Crossover modes
        if (hasEMAExit && i > 0 && emaFast.length > i && emaSlow.length > i) {
          let shouldExit = false;
          
          if (emaExitMode === 'crossover') {
            // CROSSOVER MODE: Directional exit - LONG only exits on bearish crossover
            const prevFast = emaFast[i - 1];
            const prevSlow = emaSlow[i - 1];
            const currFast = emaFast[i];
            const currSlow = emaSlow[i];
            
            const prevState = prevFast >= prevSlow ? 'fast_above_slow' : 'fast_below_slow';
            const currState = currFast >= currSlow ? 'fast_above_slow' : 'fast_below_slow';
            
            // LONG: Only exit on bearish crossover (fast crosses below slow)
            if (signal.entryEMAState) {
              const crossedOver = (prevState === signal.entryEMAState) && (currState !== signal.entryEMAState);
              const isBearishCross = currState === 'fast_below_slow';
              shouldExit = crossedOver && isBearishCross;
            }
          } else {
            // TOUCH MODE: LONG exits when price touches or crosses below slow EMA
            const slowEMA = emaSlow[i];
            const prevClose = data[i - 1].close;
            
            // Was above, now at or below slow EMA
            shouldExit = prevClose > slowEMA && candle.close <= slowEMA;
          }
          
          if (shouldExit) {
            const exitPrice = candle.close;
            const rawPL = (exitPrice - signal.entry) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(exitPrice * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(exitPrice * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'long',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: exitPrice,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'EMA Exit',
              rr: (exitPrice - signal.entry) / (signal.entry - signal.stopLoss),
              profitLoss: netPL,
              winner: netPL > 0,
            };
          }
        }
        
        // Check for VWAP Exit - LONG exits when price crosses below VWAP
        if (hasVWAPExit && i > 0 && vwapValues.length > i) {
          const prevVWAP = vwapValues[i - 1]?.value;
          const currVWAP = vwapValues[i]?.value;
          const prevClose = data[i - 1].close;
          const currClose = candle.close;
          
          if (prevVWAP && currVWAP) {
            // LONG exit: price crosses below VWAP (was above, now below)
            const wasAboveVWAP = prevClose > prevVWAP;
            const nowBelowVWAP = currClose < currVWAP;
            
            if (wasAboveVWAP && nowBelowVWAP) {
              const exitPrice = candle.close;
              const rawPL = (exitPrice - signal.entry) * signal.quantity;
              const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(exitPrice * commissionRate)) * signal.quantity;
              const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(exitPrice * slippageBps)) * signal.quantity;
              const netPL = rawPL - commission - slippage;
              
              return {
                id: signal.id,
                entryTime: signal.time,
                exitTime: candle.time,
                direction: 'long',
                strategy: signal.strategy,
                entry: signal.entry,
                exit: exitPrice,
                stopLoss: signal.stopLoss,
                tp1: signal.tp1,
                tp2: signal.tp2,
                tp3: signal.tp3,
                outcome: 'VWAP Exit',
                rr: (exitPrice - signal.entry) / (signal.entry - signal.stopLoss),
                profitLoss: netPL,
                winner: netPL > 0,
              };
            }
          }
        }
        
        // Get bot config to check numTPs
        let numTPs = 3;
        if (signal.strategy === 'liquidity_grab') numTPs = liqGrabTPSL.numTPs;
        else if (signal.strategy === 'bos_trend') numTPs = bosTPSL.numTPs;
        else if (signal.strategy === 'choch_fvg') numTPs = chochTPSL.numTPs;
        else if (signal.strategy === 'vwap_rejection') numTPs = vwapTPSL.numTPs;
        
        // TRAILING TP LOGIC FOR LONGS
        if (signal.tp1Type === 'trailing' && signal.strategy === 'choch_fvg') {
          const isInProfit = candle.close > signal.entry;
          const dataUpToNow = data.slice(0, i + 1);
          
          if (signal.trailingActive === false) {
            // Trailing not activated yet - check if we should activate it
            if (isInProfit) {
              const swings = calculateSwings(dataUpToNow, chochTPSwingLength);
              // Find pivot lows below current price (potential exit points)
              const pivotLows = swings.filter(s => 
                s.type === 'low' && 
                s.value < candle.close &&
                s.value > signal.entry && // Must be in profit zone
                s.index < i // Must have formed before current candle
              ).sort((a, b) => b.value - a.value); // Highest pivot first
              
              if (pivotLows.length > 0) {
                // Activate trailing at the nearest pivot low
                signal.tp1 = pivotLows[0].value;
                signal.tp2 = signal.tp1;
                signal.tp3 = signal.tp1;
                signal.trailingActive = true;
                
                console.log('âœ… LONG Trailing TP Activated:', {
                  entry: signal.entry.toFixed(4),
                  currentPrice: candle.close.toFixed(4),
                  trailingTP: signal.tp1.toFixed(4),
                  pivotTime: new Date(pivotLows[0].time * 1000).toLocaleString(),
                });
              }
            }
          } else {
            // Trailing already active - update to new pivots if they form
            const swings = calculateSwings(dataUpToNow, chochTPSwingLength);
            const pivotLows = swings.filter(s => 
              s.type === 'low' && 
              s.value > signal.tp1 && // Must be higher than current TP
              s.value < candle.close && // Must be below current price
              s.index < i // Must have formed before current candle
            ).sort((a, b) => b.value - a.value); // Highest pivot first
            
            if (pivotLows.length > 0) {
              signal.tp1 = pivotLows[0].value;
              signal.tp2 = signal.tp1;
              signal.tp3 = signal.tp1;
              
              console.log('ðŸ“ˆ LONG Trailing TP Updated:', {
                newTP: signal.tp1.toFixed(4),
                currentPrice: candle.close.toFixed(4),
                pivotTime: new Date(pivotLows[0].time * 1000).toLocaleString(),
              });
            }
          }
        }
        
        // TRAILING TP LOGIC FOR LIQUIDITY GRAB LONGS
        if (signal.tp1Type === 'trailing' && signal.strategy === 'liquidity_grab') {
          const isInProfit = candle.close > signal.entry;
          const dataUpToNow = data.slice(0, i + 1);
          
          if (signal.trailingActive === false) {
            // Trailing not activated yet - check if we should activate it
            if (isInProfit) {
              const swings = calculateSwings(dataUpToNow, liqGrabTPSwingLength);
              // Find pivot lows below current price (potential exit points)
              const pivotLows = swings.filter(s => 
                s.type === 'low' && 
                s.value < candle.close &&
                s.value > signal.entry && // Must be in profit zone
                s.index < i // Must have formed before current candle
              ).sort((a, b) => b.value - a.value); // Highest pivot first
              
              if (pivotLows.length > 0) {
                // Activate trailing at the nearest pivot low
                signal.tp1 = pivotLows[0].value;
                signal.tp2 = signal.tp1;
                signal.tp3 = signal.tp1;
                signal.trailingActive = true;
                
                console.log('âœ… LIQUIDITY GRAB LONG Trailing TP Activated:', {
                  entry: signal.entry.toFixed(4),
                  currentPrice: candle.close.toFixed(4),
                  trailingTP: signal.tp1.toFixed(4),
                  pivotTime: new Date(pivotLows[0].time * 1000).toLocaleString(),
                });
              }
            }
          } else {
            // Trailing already active - update to new pivots if they form
            const swings = calculateSwings(dataUpToNow, liqGrabTPSwingLength);
            const pivotLows = swings.filter(s => 
              s.type === 'low' && 
              s.value > signal.tp1 && // Must be higher than current TP
              s.value < candle.close && // Must be below current price
              s.index < i // Must have formed before current candle
            ).sort((a, b) => b.value - a.value); // Highest pivot first
            
            if (pivotLows.length > 0) {
              signal.tp1 = pivotLows[0].value;
              signal.tp2 = signal.tp1;
              signal.tp3 = signal.tp1;
              
              console.log('ðŸ“ˆ LIQUIDITY GRAB LONG Trailing TP Updated:', {
                newTP: signal.tp1.toFixed(4),
                currentPrice: candle.close.toFixed(4),
                pivotTime: new Date(pivotLows[0].time * 1000).toLocaleString(),
              });
            }
          }
        }
        
        // Check TPs in order: TP1, then TP2, then TP3
        // Exit at first configured TP hit
        if (!tp1Hit && candle.high >= signal.tp1) {
          if (numTPs === 1) {
            // Only 1 TP configured - exit full position at TP1
            const rawPL = (signal.tp1 - signal.entry) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp1 * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp1 * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            const weightedRR = calculateWeightedRR(signal.strategy, 'TP1', signal.riskReward1, signal.riskReward2, signal.riskReward3);
            
            console.log('ðŸ’° LONG TP1 Hit:', {
              strategy: signal.strategy,
              entry: signal.entry,
              exit: signal.tp1,
              quantity: signal.quantity,
              rawPL,
              commission,
              slippage,
              netPL,
              calculation: `(${signal.tp1} - ${signal.entry}) * ${signal.quantity} = ${rawPL}`
            });
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'long',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: signal.tp1,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'TP1',
              rr: weightedRR,
              profitLoss: netPL,
              winner: true,
            };
          } else {
            // Multiple TPs - move SL to entry and continue
            tp1Hit = true;
            currentStopLoss = signal.entry;
            continue;
          }
        }
        
        if (tp1Hit && numTPs >= 2 && candle.high >= signal.tp2) {
          if (numTPs === 2) {
            // Only 2 TPs configured - exit remaining position at TP2
            const rawPL = (signal.tp2 - signal.entry) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp2 * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp2 * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            const weightedRR = calculateWeightedRR(signal.strategy, 'TP2', signal.riskReward1, signal.riskReward2, signal.riskReward3);
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'long',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: signal.tp2,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'TP2',
              rr: weightedRR,
              profitLoss: netPL,
              winner: true,
            };
          }
        }
        
        if (tp1Hit && numTPs >= 3 && candle.high >= signal.tp3) {
          const rawPL = (signal.tp3 - signal.entry) * signal.quantity;
          const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp3 * commissionRate)) * signal.quantity;
          const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp3 * slippageBps)) * signal.quantity;
          const netPL = rawPL - commission - slippage;
          const weightedRR = calculateWeightedRR(signal.strategy, 'TP3', signal.riskReward1, signal.riskReward2, signal.riskReward3);
          
          return {
            id: signal.id,
            entryTime: signal.time,
            exitTime: candle.time,
            direction: 'long',
            strategy: signal.strategy,
            entry: signal.entry,
            exit: signal.tp3,
            stopLoss: signal.stopLoss,
            tp1: signal.tp1,
            tp2: signal.tp2,
            tp3: signal.tp3,
            outcome: 'TP3',
            rr: weightedRR,
            profitLoss: netPL,
            winner: true,
          };
        }
      } else {
        // SHORT trade
        if (candle.high >= currentStopLoss) {
          const rawPL = (signal.entry - currentStopLoss) * signal.quantity;
          const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(currentStopLoss * commissionRate)) * signal.quantity;
          const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(currentStopLoss * slippageBps)) * signal.quantity;
          const netPL = rawPL - commission - slippage;
          
          return {
            id: signal.id,
            entryTime: signal.time,
            exitTime: candle.time,
            direction: 'short',
            strategy: signal.strategy,
            entry: signal.entry,
            exit: currentStopLoss,
            stopLoss: signal.stopLoss,
            tp1: signal.tp1,
            tp2: signal.tp2,
            tp3: signal.tp3,
            outcome: tp1Hit ? 'Breakeven' : 'SL',
            rr: tp1Hit ? 0 : -1,
            profitLoss: netPL,
            winner: tp1Hit ? (netPL >= 0) : false,
          };
        }
        
        // Check for EMA Exit - supports both Touch and Crossover modes
        if (hasEMAExit && i > 0 && emaFast.length > i && emaSlow.length > i) {
          let shouldExit = false;
          
          if (emaExitMode === 'crossover') {
            // CROSSOVER MODE: Directional exit - SHORT only exits on bullish crossover
            const prevFast = emaFast[i - 1];
            const prevSlow = emaSlow[i - 1];
            const currFast = emaFast[i];
            const currSlow = emaSlow[i];
            
            const prevState = prevFast >= prevSlow ? 'fast_above_slow' : 'fast_below_slow';
            const currState = currFast >= currSlow ? 'fast_above_slow' : 'fast_below_slow';
            
            // SHORT: Only exit on bullish crossover (fast crosses above slow)
            if (signal.entryEMAState) {
              const crossedOver = (prevState === signal.entryEMAState) && (currState !== signal.entryEMAState);
              const isBullishCross = currState === 'fast_above_slow';
              shouldExit = crossedOver && isBullishCross;
            }
          } else {
            // TOUCH MODE: SHORT exits when price touches or crosses above slow EMA
            const slowEMA = emaSlow[i];
            const prevClose = data[i - 1].close;
            
            // Was below, now at or above slow EMA
            shouldExit = prevClose < slowEMA && candle.close >= slowEMA;
          }
          
          if (shouldExit) {
            const exitPrice = candle.close;
            const rawPL = (signal.entry - exitPrice) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(exitPrice * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(exitPrice * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'short',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: exitPrice,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'EMA Exit',
              rr: (signal.entry - exitPrice) / (signal.stopLoss - signal.entry),
              profitLoss: netPL,
              winner: netPL > 0,
            };
          }
        }
        
        // Check for VWAP Exit - SHORT exits when price crosses above VWAP
        if (hasVWAPExit && i > 0 && vwapValues.length > i) {
          const prevVWAP = vwapValues[i - 1]?.value;
          const currVWAP = vwapValues[i]?.value;
          const prevClose = data[i - 1].close;
          const currClose = candle.close;
          
          if (prevVWAP && currVWAP) {
            // SHORT exit: price crosses above VWAP (was below, now above)
            const wasBelowVWAP = prevClose < prevVWAP;
            const nowAboveVWAP = currClose > currVWAP;
            
            if (wasBelowVWAP && nowAboveVWAP) {
              const exitPrice = candle.close;
              const rawPL = (signal.entry - exitPrice) * signal.quantity;
              const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(exitPrice * commissionRate)) * signal.quantity;
              const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(exitPrice * slippageBps)) * signal.quantity;
              const netPL = rawPL - commission - slippage;
              
              return {
                id: signal.id,
                entryTime: signal.time,
                exitTime: candle.time,
                direction: 'short',
                strategy: signal.strategy,
                entry: signal.entry,
                exit: exitPrice,
                stopLoss: signal.stopLoss,
                tp1: signal.tp1,
                tp2: signal.tp2,
                tp3: signal.tp3,
                outcome: 'VWAP Exit',
                rr: (signal.entry - exitPrice) / (signal.stopLoss - signal.entry),
                profitLoss: netPL,
                winner: netPL > 0,
              };
            }
          }
        }
        
        // Get bot config to check numTPs (same as LONG side)
        let numTPs = 3;
        if (signal.strategy === 'liquidity_grab') numTPs = liqGrabTPSL.numTPs;
        else if (signal.strategy === 'bos_trend') numTPs = bosTPSL.numTPs;
        else if (signal.strategy === 'choch_fvg') numTPs = chochTPSL.numTPs;
        else if (signal.strategy === 'vwap_rejection') numTPs = vwapTPSL.numTPs;
        
        // TRAILING TP LOGIC FOR SHORTS
        if (signal.tp1Type === 'trailing' && signal.strategy === 'choch_fvg') {
          const isInProfit = candle.close < signal.entry;
          const dataUpToNow = data.slice(0, i + 1);
          
          if (signal.trailingActive === false) {
            // Trailing not activated yet - check if we should activate it
            if (isInProfit) {
              const swings = calculateSwings(dataUpToNow, chochTPSwingLength);
              // Find pivot highs above current price (potential exit points)
              const pivotHighs = swings.filter(s => 
                s.type === 'high' && 
                s.value > candle.close &&
                s.value < signal.entry && // Must be in profit zone
                s.index < i // Must have formed before current candle
              ).sort((a, b) => a.value - b.value); // Lowest pivot first
              
              if (pivotHighs.length > 0) {
                // Activate trailing at the nearest pivot high
                signal.tp1 = pivotHighs[0].value;
                signal.tp2 = signal.tp1;
                signal.tp3 = signal.tp1;
                signal.trailingActive = true;
                
                console.log('âœ… SHORT Trailing TP Activated:', {
                  entry: signal.entry.toFixed(4),
                  currentPrice: candle.close.toFixed(4),
                  trailingTP: signal.tp1.toFixed(4),
                  pivotTime: new Date(pivotHighs[0].time * 1000).toLocaleString(),
                });
              }
            }
          } else {
            // Trailing already active - update to new pivots if they form
            const swings = calculateSwings(dataUpToNow, chochTPSwingLength);
            const pivotHighs = swings.filter(s => 
              s.type === 'high' && 
              s.value < signal.tp1 && // Must be lower than current TP
              s.value > candle.close && // Must be above current price
              s.index < i // Must have formed before current candle
            ).sort((a, b) => a.value - b.value); // Lowest pivot first
            
            if (pivotHighs.length > 0) {
              signal.tp1 = pivotHighs[0].value;
              signal.tp2 = signal.tp1;
              signal.tp3 = signal.tp1;
              
              console.log('ðŸ“‰ SHORT Trailing TP Updated:', {
                newTP: signal.tp1.toFixed(4),
                currentPrice: candle.close.toFixed(4),
                pivotTime: new Date(pivotHighs[0].time * 1000).toLocaleString(),
              });
            }
          }
        }
        
        // TRAILING TP LOGIC FOR LIQUIDITY GRAB SHORTS
        if (signal.tp1Type === 'trailing' && signal.strategy === 'liquidity_grab') {
          const isInProfit = candle.close < signal.entry;
          const dataUpToNow = data.slice(0, i + 1);
          
          if (signal.trailingActive === false) {
            // Trailing not activated yet - check if we should activate it
            if (isInProfit) {
              const swings = calculateSwings(dataUpToNow, liqGrabTPSwingLength);
              // Find pivot highs above current price (potential exit points)
              const pivotHighs = swings.filter(s => 
                s.type === 'high' && 
                s.value > candle.close &&
                s.value < signal.entry && // Must be in profit zone
                s.index < i // Must have formed before current candle
              ).sort((a, b) => a.value - b.value); // Lowest pivot first
              
              if (pivotHighs.length > 0) {
                // Activate trailing at the nearest pivot high
                signal.tp1 = pivotHighs[0].value;
                signal.tp2 = signal.tp1;
                signal.tp3 = signal.tp1;
                signal.trailingActive = true;
                
                console.log('âœ… LIQUIDITY GRAB SHORT Trailing TP Activated:', {
                  entry: signal.entry.toFixed(4),
                  currentPrice: candle.close.toFixed(4),
                  trailingTP: signal.tp1.toFixed(4),
                  pivotTime: new Date(pivotHighs[0].time * 1000).toLocaleString(),
                });
              }
            }
          } else {
            // Trailing already active - update to new pivots if they form
            const swings = calculateSwings(dataUpToNow, liqGrabTPSwingLength);
            const pivotHighs = swings.filter(s => 
              s.type === 'high' && 
              s.value < signal.tp1 && // Must be lower than current TP
              s.value > candle.close && // Must be above current price
              s.index < i // Must have formed before current candle
            ).sort((a, b) => a.value - b.value); // Lowest pivot first
            
            if (pivotHighs.length > 0) {
              signal.tp1 = pivotHighs[0].value;
              signal.tp2 = signal.tp1;
              signal.tp3 = signal.tp1;
              
              console.log('ðŸ“‰ LIQUIDITY GRAB SHORT Trailing TP Updated:', {
                newTP: signal.tp1.toFixed(4),
                currentPrice: candle.close.toFixed(4),
                pivotTime: new Date(pivotHighs[0].time * 1000).toLocaleString(),
              });
            }
          }
        }
        
        // Check TPs in order: TP1, then TP2, then TP3
        // Exit at first configured TP hit
        if (!tp1Hit && candle.low <= signal.tp1) {
          if (numTPs === 1) {
            // Only 1 TP configured - exit full position at TP1
            const rawPL = (signal.entry - signal.tp1) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp1 * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp1 * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            const weightedRR = calculateWeightedRR(signal.strategy, 'TP1', signal.riskReward1, signal.riskReward2, signal.riskReward3);
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'short',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: signal.tp1,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'TP1',
              rr: weightedRR,
              profitLoss: netPL,
              winner: true,
            };
          } else {
            // Multiple TPs - move SL to entry and continue
            tp1Hit = true;
            currentStopLoss = signal.entry;
            continue;
          }
        }
        
        if (tp1Hit && numTPs >= 2 && candle.low <= signal.tp2) {
          if (numTPs === 2) {
            // Only 2 TPs configured - exit remaining position at TP2
            const rawPL = (signal.entry - signal.tp2) * signal.quantity;
            const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp2 * commissionRate)) * signal.quantity;
            const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp2 * slippageBps)) * signal.quantity;
            const netPL = rawPL - commission - slippage;
            const weightedRR = calculateWeightedRR(signal.strategy, 'TP2', signal.riskReward1, signal.riskReward2, signal.riskReward3);
            
            return {
              id: signal.id,
              entryTime: signal.time,
              exitTime: candle.time,
              direction: 'short',
              strategy: signal.strategy,
              entry: signal.entry,
              exit: signal.tp2,
              stopLoss: signal.stopLoss,
              tp1: signal.tp1,
              tp2: signal.tp2,
              tp3: signal.tp3,
              outcome: 'TP2',
              rr: weightedRR,
              profitLoss: netPL,
              winner: true,
            };
          }
        }
        
        if (tp1Hit && numTPs >= 3 && candle.low <= signal.tp3) {
          const rawPL = (signal.entry - signal.tp3) * signal.quantity;
          const commission = (Math.abs(signal.entry * commissionRate) + Math.abs(signal.tp3 * commissionRate)) * signal.quantity;
          const slippage = (Math.abs(signal.entry * slippageBps) + Math.abs(signal.tp3 * slippageBps)) * signal.quantity;
          const netPL = rawPL - commission - slippage;
          const weightedRR = calculateWeightedRR(signal.strategy, 'TP3', signal.riskReward1, signal.riskReward2, signal.riskReward3);
          
          return {
            id: signal.id,
            entryTime: signal.time,
            exitTime: candle.time,
            direction: 'short',
            strategy: signal.strategy,
            entry: signal.entry,
            exit: signal.tp3,
            stopLoss: signal.stopLoss,
            tp1: signal.tp1,
            tp2: signal.tp2,
            tp3: signal.tp3,
            outcome: 'TP3',
            rr: weightedRR,
            profitLoss: netPL,
            winner: true,
          };
        }
      }
    }
    
    return null; // Trade didn't close within available data
  }, [calculateWeightedRR, liqGrabTPSL, bosTPSL, chochTPSL, vwapTPSL, rsFlipTPSL, calculateEMA, emaFastPeriod, emaSlowPeriod]);

  // Generate all combinations of bot configurations for auto-backtest
  // Helper to generate range values
  const generateRangeValues = (min: number, max: number, step: number): number[] => {
    const values: number[] = [];
    for (let v = min; v <= max; v += step) {
      values.push(Number(v.toFixed(2)));
    }
    return values;
  };

  const generateAutoBacktestCombinations = useCallback((): any[] => {
    const combinations: any[] = [];
    
    // Generate arrays from ranges for strategy parameters
    const swingLengthValues = generateRangeValues(swingLengthRange.min, swingLengthRange.max, swingLengthRange.step);
    const wickRatioValues = generateRangeValues(wickRatioRange.min, wickRatioRange.max, wickRatioRange.step);
    const confirmCandlesValues = generateRangeValues(confirmCandlesRange.min, confirmCandlesRange.max, confirmCandlesRange.step);
    
    // TP1 parameter arrays - Liquidity Grab uses: Structure, Trailing, EMA, Fixed R:R
    const tp1StructureSwingValues = testTP1Structure ? generateRangeValues(tp1SwingLengthRange.min, tp1SwingLengthRange.max, tp1SwingLengthRange.step) : [];
    const tp1TrailingSwingValues = testTP1Trailing ? generateRangeValues(tp1TrailingSwingRange.min, tp1TrailingSwingRange.max, tp1TrailingSwingRange.step) : [];
    const tp1EMAFastValues = testTP1EMA ? generateRangeValues(tp1EMAFastRange.min, tp1EMAFastRange.max, tp1EMAFastRange.step) : [];
    const tp1EMASlowValues = testTP1EMA ? generateRangeValues(tp1EMASlowRange.min, tp1EMASlowRange.max, tp1EMASlowRange.step) : [];
    const tp1RRValues = testTP1FixedRR ? generateRangeValues(tp1RRRange.min, tp1RRRange.max, tp1RRRange.step) : [];
    
    // TP2 parameter arrays
    const tp2StructureSwingValues = testTP2Structure ? generateRangeValues(tp2SwingLengthRange.min, tp2SwingLengthRange.max, tp2SwingLengthRange.step) : [];
    const tp2TrailingSwingValues = testTP2Trailing ? generateRangeValues(tp2TrailingSwingRange.min, tp2TrailingSwingRange.max, tp2TrailingSwingRange.step) : [];
    const tp2EMAFastValues = testTP2EMA ? generateRangeValues(tp2EMAFastRange.min, tp2EMAFastRange.max, tp2EMAFastRange.step) : [];
    const tp2EMASlowValues = testTP2EMA ? generateRangeValues(tp2EMASlowRange.min, tp2EMASlowRange.max, tp2EMASlowRange.step) : [];
    const tp2RRValues = testTP2FixedRR ? generateRangeValues(tp2RRRange.min, tp2RRRange.max, tp2RRRange.step) : [];
    
    // TP3 parameter arrays
    const tp3StructureSwingValues = testTP3Structure ? generateRangeValues(tp3SwingLengthRange.min, tp3SwingLengthRange.max, tp3SwingLengthRange.step) : [];
    const tp3TrailingSwingValues = testTP3Trailing ? generateRangeValues(tp3TrailingSwingRange.min, tp3TrailingSwingRange.max, tp3TrailingSwingRange.step) : [];
    const tp3EMAFastValues = testTP3EMA ? generateRangeValues(tp3EMAFastRange.min, tp3EMAFastRange.max, tp3EMAFastRange.step) : [];
    const tp3EMASlowValues = testTP3EMA ? generateRangeValues(tp3EMASlowRange.min, tp3EMASlowRange.max, tp3EMASlowRange.step) : [];
    const tp3RRValues = testTP3FixedRR ? generateRangeValues(tp3RRRange.min, tp3RRRange.max, tp3RRRange.step) : [];
    
    // SL parameter arrays
    const slATRValues = testSLATR ? generateRangeValues(slATRRange.min, slATRRange.max, slATRRange.step) : [];
    const slStructureSwingValues = testSLStructure ? generateRangeValues(slSwingLengthRange.min, slSwingLengthRange.max, slSwingLengthRange.step) : [];
    const slFixedDistanceValues = testSLFixedDistance ? generateRangeValues(slFixedDistanceRange.min, slFixedDistanceRange.max, slFixedDistanceRange.step) : [];
    
    // Combine all TP1 types (include positionPercent from current config)
    const tp1Configs: any[] = [];
    tp1StructureSwingValues.forEach(v => tp1Configs.push({ type: 'structure', swingLength: v, positionPercent: liqGrabTPSL.tp1.positionPercent }));
    tp1TrailingSwingValues.forEach(v => tp1Configs.push({ type: 'trailing', trailingSwingLength: v, positionPercent: liqGrabTPSL.tp1.positionPercent }));
    // For EMA, create combinations of fast and slow
    tp1EMAFastValues.forEach(fast => {
      tp1EMASlowValues.forEach(slow => {
        if (slow > fast) { // Ensure slow > fast
          tp1Configs.push({ type: 'ema', emaFast: fast, emaSlow: slow, positionPercent: liqGrabTPSL.tp1.positionPercent });
        }
      });
    });
    tp1RRValues.forEach(v => tp1Configs.push({ type: 'fixed_rr', fixedRR: v, positionPercent: liqGrabTPSL.tp1.positionPercent }));
    
    // Combine all TP2 types (include positionPercent from current config)
    const tp2Configs: any[] = [];
    const tp2PositionPercent = liqGrabTPSL.tp2?.positionPercent || 30;
    tp2StructureSwingValues.forEach(v => tp2Configs.push({ type: 'structure', swingLength: v, positionPercent: tp2PositionPercent }));
    tp2TrailingSwingValues.forEach(v => tp2Configs.push({ type: 'trailing', trailingSwingLength: v, positionPercent: tp2PositionPercent }));
    tp2EMAFastValues.forEach(fast => {
      tp2EMASlowValues.forEach(slow => {
        if (slow > fast) {
          tp2Configs.push({ type: 'ema', emaFast: fast, emaSlow: slow, positionPercent: tp2PositionPercent });
        }
      });
    });
    tp2RRValues.forEach(v => tp2Configs.push({ type: 'fixed_rr', fixedRR: v, positionPercent: tp2PositionPercent }));
    
    // Combine all TP3 types (include positionPercent from current config)
    const tp3Configs: any[] = [];
    const tp3PositionPercent = liqGrabTPSL.tp3?.positionPercent || 20;
    tp3StructureSwingValues.forEach(v => tp3Configs.push({ type: 'structure', swingLength: v, positionPercent: tp3PositionPercent }));
    tp3TrailingSwingValues.forEach(v => tp3Configs.push({ type: 'trailing', trailingSwingLength: v, positionPercent: tp3PositionPercent }));
    tp3EMAFastValues.forEach(fast => {
      tp3EMASlowValues.forEach(slow => {
        if (slow > fast) {
          tp3Configs.push({ type: 'ema', emaFast: fast, emaSlow: slow, positionPercent: tp3PositionPercent });
        }
      });
    });
    tp3RRValues.forEach(v => tp3Configs.push({ type: 'fixed_rr', fixedRR: v, positionPercent: tp3PositionPercent }));
    
    // Combine all SL types
    const slConfigs: any[] = [];
    slATRValues.forEach(v => slConfigs.push({ type: 'atr', atrMultiplier: v }));
    slStructureSwingValues.forEach(v => slConfigs.push({ type: 'structure', swingLength: v }));
    slFixedDistanceValues.forEach(v => slConfigs.push({ type: 'fixed_distance', distancePercent: v }));
    
    // Boolean filter combinations - only test when checkbox is enabled
    const wickFilterOptions = testUseWickFilter ? [true] : [false];
    const confirmCandlesOptions = testUseConfirmCandles ? [true] : [false];
    
    // Generate all combinations
    for (const trendFilter of testTrendFilters) {
      for (const direction of testDirections) {
        for (const useWickFilter of wickFilterOptions) {
          for (const useConfirmCandles of confirmCandlesOptions) {
            for (const swingLength of swingLengthValues) {
              // Only test different wick ratios when wick filter is enabled
              const wickRatiosToTest = useWickFilter ? wickRatioValues : [100];
              for (const wickRatio of wickRatiosToTest) {
                // Only test different confirm candles when confirm candles is enabled
                const confirmCandlesToTest = useConfirmCandles ? confirmCandlesValues : [0];
                for (const confirmCandles of confirmCandlesToTest) {
                  for (const tp1 of tp1Configs.length > 0 ? tp1Configs : [null]) {
                    for (const tp2 of liqGrabTPSL.numTPs >= 2 && tp2Configs.length > 0 ? tp2Configs : [null]) {
                      for (const tp3 of liqGrabTPSL.numTPs >= 3 && tp3Configs.length > 0 ? tp3Configs : [null]) {
                        for (const sl of slConfigs) {
                          combinations.push({
                            numTPs: liqGrabTPSL.numTPs,
                            trendFilter,
                            direction,
                            swingLength,
                            wickRatio,
                            confirmCandles,
                            useWickFilter,
                            useConfirmCandles,
                            tp1,
                            tp2,
                            tp3,
                            sl
                          });
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    console.log(`ðŸ§ª Generated ${combinations.length} test combinations`);
    return combinations;
  }, [
    testTrendFilters, testDirections,
    swingLengthRange, wickRatioRange, confirmCandlesRange,
    testUseWickFilter, testUseConfirmCandles,
    liqGrabTPSL.numTPs, liqGrabTPSL.tp1.positionPercent, liqGrabTPSL.tp2, liqGrabTPSL.tp3,
    testTP1Structure, testTP1Trailing, testTP1EMA, testTP1FixedRR,
    tp1SwingLengthRange, tp1TrailingSwingRange, tp1EMAFastRange, tp1EMASlowRange, tp1RRRange,
    testTP2Structure, testTP2Trailing, testTP2EMA, testTP2FixedRR,
    tp2SwingLengthRange, tp2TrailingSwingRange, tp2EMAFastRange, tp2EMASlowRange, tp2RRRange,
    testTP3Structure, testTP3Trailing, testTP3EMA, testTP3FixedRR,
    tp3SwingLengthRange, tp3TrailingSwingRange, tp3EMAFastRange, tp3EMASlowRange, tp3RRRange,
    testSLATR, testSLStructure, testSLFixedDistance,
    slATRRange, slSwingLengthRange, slFixedDistanceRange
  ]);

  // Run auto-backtest with all combinations
  const runAutoBacktest = useCallback(async () => {
    if (candles.length < 100) {
      alert('Need at least 100 candles for backtest');
      return;
    }
    
    const startTime = performance.now();
    
    setLiqGrabAutoTestRunning(true);
    setLiqGrabAutoTestResults([]);
    setLiqGrabAutoTestProgress(0);
    
    const combinations = generateAutoBacktestCombinations();
    const results: AutoBacktestResult[] = [];
    
    console.log(`ðŸš€ Starting auto-backtest with ${combinations.length} configurations...`);
    
    // Test each combination (simplified backtest)
    for (let i = 0; i < combinations.length; i++) {
      const config = combinations[i];
      
      // Update progress
      setLiqGrabAutoTestProgress(Math.round((i / combinations.length) * 100));
      
      // Run a simplified backtest for this config (config passed directly to signal generator)
      const allSignals: TradeSignal[] = [];
      const completedTrades: BacktestTrade[] = [];
      let lastTradeExitTime = 0;
      
      for (let j = 50; j < candles.length - 10; j++) {
        const currentTime = candles[j].time;
        if (currentTime < lastTradeExitTime) continue;
        
        const dataSlice = candles.slice(0, j + 1);
        const liqSignal = generateLiquidityGrabSignal(dataSlice, true, {
          swingLength: config.swingLength,
          wickRatio: config.wickRatio,
          confirmCandles: config.confirmCandles,
          useWickFilter: config.useWickFilter,
          useConfirmCandles: config.useConfirmCandles,
          trendFilter: config.trendFilter,
          directionFilter: config.direction,
          tpslConfig: config
        });
        
        if (liqSignal && !allSignals.some(s => s.id === liqSignal.id)) {
          allSignals.push(liqSignal);
          const trade = simulateTrade(liqSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
          }
        }
      }
      
      // Calculate results
      const winners = completedTrades.filter(t => t.winner).length;
      const losers = completedTrades.filter(t => !t.winner).length;
      const totalPL = completedTrades.reduce((sum, t) => sum + t.profitLoss, 0);
      const avgRR = completedTrades.length > 0 ? completedTrades.reduce((sum, t) => sum + t.rr, 0) / completedTrades.length : 0;
      const winRate = completedTrades.length > 0 ? (winners / completedTrades.length) * 100 : 0;
      
      const grossProfit = completedTrades.filter(t => t.winner).reduce((sum, t) => sum + t.profitLoss, 0);
      const grossLoss = Math.abs(completedTrades.filter(t => !t.winner).reduce((sum, t) => sum + t.profitLoss, 0));
      const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999 : 0;
      
      const finalBalance = accountSize + totalPL;
      const returnPercent = ((finalBalance - accountSize) / accountSize) * 100;
      
      const backtestResults: BacktestResults = {
        trades: completedTrades,
        totalTrades: completedTrades.length,
        winners,
        losers,
        winRate,
        avgRR,
        totalPL,
        profitFactor,
        accountSize,
        riskPerTrade: riskPercent,
        avgPositionSize: 0,
        finalBalance,
        returnPercent
      };
      
      // Create description - only show configured TPs
      let desc = `Swing:${config.swingLength}`;
      if (config.useWickFilter) desc += ` | Wick:${config.wickRatio}%`;
      if (config.useConfirmCandles) desc += ` | Confirm:${config.confirmCandles}`;
      desc += ` | Trend:${config.trendFilter} | Dir:${config.direction}`;
      desc += ` | TP1:${config.tp1.type}`;
      if (config.tp1.type === 'atr') desc += `(${config.tp1.atrMultiplier}x)`;
      if (config.tp1.type === 'fixed_rr') desc += `(${config.tp1.fixedRR}:1)`;
      if (config.tp1.type === 'structure') desc += `(sw${config.tp1.swingLength})`;
      
      if (config.numTPs >= 2 && config.tp2) {
        desc += ` | TP2:${config.tp2.type}`;
        if (config.tp2.type === 'atr') desc += `(${config.tp2.atrMultiplier}x)`;
        if (config.tp2.type === 'fixed_rr') desc += `(${config.tp2.fixedRR}:1)`;
        if (config.tp2.type === 'structure') desc += `(sw${config.tp2.swingLength})`;
      }
      
      if (config.numTPs === 3 && config.tp3) {
        desc += ` | TP3:${config.tp3.type}`;
        if (config.tp3.type === 'atr') desc += `(${config.tp3.atrMultiplier}x)`;
        if (config.tp3.type === 'structure') desc += `(sw${config.tp3.swingLength})`;
      }
      
      desc += ` | SL:${config.sl.type}`;
      if (config.sl.type === 'atr') desc += `(${config.sl.atrMultiplier}x)`;
      if (config.sl.type === 'structure') desc += `(sw${config.sl.swingLength})`;
      if (config.sl.type === 'fixed_distance') desc += `(${config.sl.distancePercent}%)`;
      
      results.push({
        config,
        results: backtestResults,
        configDescription: desc,
        swingLength: config.swingLength,
        wickRatio: config.wickRatio,
        confirmCandles: config.confirmCandles,
        useWickFilter: config.useWickFilter,
        useConfirmCandles: config.useConfirmCandles,
        trendFilter: config.trendFilter,
        allowedDirections: config.direction
      });
      
      // Allow UI to update
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    // Sort by total profit (default)
    results.sort((a, b) => b.results.totalPL - a.results.totalPL);
    
    // Track duration and combo count for future time estimates
    const duration = performance.now() - startTime;
    setLiqGrabAutoTestDurations(prev => {
      const updated = [...prev, { duration, combos: combinations.length }];
      return updated.slice(-5); // Keep only last 5
    });
    
    setLiqGrabAutoTestResults(results);
    setLiqGrabAutoTestProgress(100);
    setLiqGrabAutoTestRunning(false);
    
    console.log('âœ… Auto-backtest complete!', {
      totalConfigs: results.length,
      bestProfit: results[0]?.results.totalPL.toFixed(2),
      bestConfig: results[0]?.configDescription,
      duration: `${(duration / 1000).toFixed(1)}s`
    });
  }, [candles, generateAutoBacktestCombinations, generateLiquidityGrabSignal, simulateTrade, liqGrabTPSL, accountSize, riskPercent]);

  // Apply all settings from an auto-backtest result
  const applyAutoBacktestConfig = useCallback((result: AutoBacktestResult) => {
    // Apply TP/SL configuration
    setLiqGrabTPSL(result.config);
    
    // Apply strategy parameters
    setLiqGrabSwingLength(result.swingLength);
    setLiqGrabSwingLengthInput(result.swingLength.toString());
    setLiqGrabWickRatio(result.wickRatio);
    setLiqGrabWickRatioInput(result.wickRatio.toString());
    setLiqGrabConfirmCandles(result.confirmCandles);
    setLiqGrabConfirmCandlesInput(result.confirmCandles.toString());
    setLiqGrabUseWickFilter(result.useWickFilter);
    setLiqGrabUseConfirmCandles(result.useConfirmCandles);
    setLiqGrabTrendFilter(result.trendFilter);
    setLiqGrabDirectionFilter(result.allowedDirections);
    
    // Apply TP/SL swing lengths from config if they're structure type
    if (result.config.tp1.type === 'structure' && result.config.tp1.swingLength) {
      setLiqGrabTPSwingLength(result.config.tp1.swingLength);
      setLiqGrabTPSwingLengthInput(result.config.tp1.swingLength.toString());
    }
    if (result.config.sl.type === 'structure' && result.config.sl.swingLength) {
      setLiqGrabSLSwingLength(result.config.sl.swingLength);
      setLiqGrabSLSwingLengthInput(result.config.sl.swingLength.toString());
    }
    
    // Show success notification
    toast({
      title: "âœ… Settings Applied",
      description: `Configuration applied: ${result.configDescription}`,
      duration: 3000,
    });
    
    console.log('âœ… Applied auto-backtest configuration:', {
      swingLength: result.swingLength,
      wickRatio: result.wickRatio,
      confirmCandles: result.confirmCandles,
      useWickFilter: result.useWickFilter,
      useConfirmCandles: result.useConfirmCandles,
      trendFilter: result.trendFilter,
      allowedDirections: result.allowedDirections,
      tpsl: result.config
    });
  }, [toast]);

  // Save current Liquidity Grab settings as default
  const saveAsDefault = useCallback(() => {
    const defaultSettings = {
      swingLength: liqGrabSwingLength,
      wickRatio: liqGrabWickRatio,
      confirmCandles: liqGrabConfirmCandles,
      useWickFilter: liqGrabUseWickFilter,
      useConfirmCandles: liqGrabUseConfirmCandles,
      trendFilter: liqGrabTrendFilter,
      directionFilter: liqGrabDirectionFilter,
      tpSwingLength: liqGrabTPSwingLength,
      slSwingLength: liqGrabSLSwingLength,
      tpslConfig: liqGrabTPSL
    };
    
    localStorage.setItem('liqGrabDefaultSettings', JSON.stringify(defaultSettings));
    
    toast({
      title: "ðŸ’¾ Saved as Default",
      description: "Current settings saved as default configuration",
      duration: 3000,
    });
    
    console.log('ðŸ’¾ Saved default settings:', defaultSettings);
  }, [liqGrabSwingLength, liqGrabWickRatio, liqGrabConfirmCandles, liqGrabUseWickFilter, liqGrabUseConfirmCandles, liqGrabTrendFilter, liqGrabDirectionFilter, liqGrabTPSwingLength, liqGrabSLSwingLength, liqGrabTPSL, toast]);

  // Load default settings from localStorage
  const loadDefaultSettings = useCallback(() => {
    try {
      const saved = localStorage.getItem('liqGrabDefaultSettings');
      if (saved) {
        const defaultSettings = JSON.parse(saved);
        
        if (defaultSettings.swingLength !== undefined) {
          setLiqGrabSwingLength(defaultSettings.swingLength);
          setLiqGrabSwingLengthInput(defaultSettings.swingLength.toString());
        }
        if (defaultSettings.wickRatio !== undefined) {
          setLiqGrabWickRatio(defaultSettings.wickRatio);
          setLiqGrabWickRatioInput(defaultSettings.wickRatio.toString());
        }
        if (defaultSettings.confirmCandles !== undefined) {
          setLiqGrabConfirmCandles(defaultSettings.confirmCandles);
          setLiqGrabConfirmCandlesInput(defaultSettings.confirmCandles.toString());
        }
        if (defaultSettings.useWickFilter !== undefined) {
          setLiqGrabUseWickFilter(defaultSettings.useWickFilter);
        }
        if (defaultSettings.useConfirmCandles !== undefined) {
          setLiqGrabUseConfirmCandles(defaultSettings.useConfirmCandles);
        }
        if (defaultSettings.trendFilter !== undefined) {
          setLiqGrabTrendFilter(defaultSettings.trendFilter);
        }
        if (defaultSettings.directionFilter !== undefined) {
          setLiqGrabDirectionFilter(defaultSettings.directionFilter);
        }
        if (defaultSettings.tpSwingLength !== undefined) {
          setLiqGrabTPSwingLength(defaultSettings.tpSwingLength);
          setLiqGrabTPSwingLengthInput(defaultSettings.tpSwingLength.toString());
        }
        if (defaultSettings.slSwingLength !== undefined) {
          setLiqGrabSLSwingLength(defaultSettings.slSwingLength);
          setLiqGrabSLSwingLengthInput(defaultSettings.slSwingLength.toString());
        }
        if (defaultSettings.tpslConfig !== undefined) {
          setLiqGrabTPSL(defaultSettings.tpslConfig);
          console.log('âœ… TP/SL configuration loaded:', defaultSettings.tpslConfig);
          
          // Sync SL swing length from tpslConfig (this takes priority over the separate slSwingLength field)
          if (defaultSettings.tpslConfig.sl?.swingLength !== undefined) {
            setLiqGrabSLSwingLength(defaultSettings.tpslConfig.sl.swingLength);
            setLiqGrabSLSwingLengthInput(defaultSettings.tpslConfig.sl.swingLength.toString());
            console.log('âœ… Synced SL swing length from tpslConfig:', defaultSettings.tpslConfig.sl.swingLength);
          }
          // Sync TP trailing swing length from tpslConfig if it exists
          if (defaultSettings.tpslConfig.tp1?.trailingSwingLength !== undefined) {
            setLiqGrabTPSwingLength(defaultSettings.tpslConfig.tp1.trailingSwingLength);
            setLiqGrabTPSwingLengthInput(defaultSettings.tpslConfig.tp1.trailingSwingLength.toString());
            console.log('âœ… Synced TP trailing swing length from tpslConfig:', defaultSettings.tpslConfig.tp1.trailingSwingLength);
          }
        }
        
        console.log('ðŸ“‚ Loaded default settings from localStorage');
        return true;
      }
    } catch (error) {
      console.error('Failed to load default settings:', error);
    }
    return false;
  }, []);

  // Load default settings on mount
  useEffect(() => {
    loadDefaultSettings();
  }, [loadDefaultSettings]);

  // Sort auto-backtest results based on selected column
  const sortedAutoBacktestResults = useMemo(() => {
    const sorted = [...liqGrabAutoTestResults];
    switch (liqGrabAutoTestSortBy) {
      case 'profit':
        return sorted.sort((a, b) => b.results.totalPL - a.results.totalPL);
      case 'winRate':
        return sorted.sort((a, b) => b.results.winRate - a.results.winRate);
      case 'trades':
        return sorted.sort((a, b) => b.results.totalTrades - a.results.totalTrades);
      case 'avgRR':
        return sorted.sort((a, b) => b.results.avgRR - a.results.avgRR);
      default:
        return sorted;
    }
  }, [liqGrabAutoTestResults, liqGrabAutoTestSortBy]);

  // Run backtest on historical data
  // NEW: Only allow 1 trade at a time - no overlapping trades
  const runBacktest = useCallback(async () => {
    if (candles.length < 100) {
      alert('Need at least 100 candles for backtest');
      return;
    }
    
    setBacktesting(true);
    
    // Process candles sequentially and generate signals
    const allSignals: TradeSignal[] = [];
    const completedTrades: BacktestTrade[] = [];
    let lastTradeExitTime = 0; // Track when last trade closed
    
    // Process in chunks to avoid freezing the UI
    const chunkSize = 50;
    const totalCandles = candles.length - 10;
    
    // Use first 50 candles for initialization, then start generating signals
    for (let i = 50; i < totalCandles; i += chunkSize) {
      // Process chunk
      const chunkEnd = Math.min(i + chunkSize, totalCandles);
      
      for (let j = i; j < chunkEnd; j++) {
        const currentTime = candles[j].time;
        
        // Skip if we have an open trade (current time is before last trade exit)
        if (currentTime < lastTradeExitTime) {
          continue;
        }
        
        const dataSlice = candles.slice(0, j + 1);
        
        // Try to generate signals at this point in time (only if no trade is open)
        // Pass current state values as override to ensure manual backtest matches auto-backtest behavior
        const liqSignal = generateLiquidityGrabSignal(dataSlice, true, {
          swingLength: liqGrabSwingLength,
          wickRatio: liqGrabWickRatio,
          confirmCandles: liqGrabConfirmCandles,
          useWickFilter: liqGrabUseWickFilter,
          useConfirmCandles: liqGrabUseConfirmCandles,
          trendFilter: liqGrabTrendFilter,
          directionFilter: liqGrabDirectionFilter,
          tpslConfig: liqGrabTPSL
        });
        if (liqSignal && !allSignals.some(s => s.id === liqSignal.id)) {
          console.log('ðŸ’° Liquidity Grab trade signal at', new Date(candles[j].time * 1000).toLocaleString(), {
            type: liqSignal.type,
            entry: liqSignal.entry?.toFixed(4) || 'N/A',
            stopLoss: liqSignal.stopLoss?.toFixed(4) || 'N/A',
            reason: liqSignal.reason
          });
          allSignals.push(liqSignal);
          const trade = simulateTrade(liqSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            continue; // Skip other signals this candle - we took a trade
          }
        }
        
        const chochSignal = generateChochFVGSignal(dataSlice);
        if (chochSignal && !allSignals.some(s => s.id === chochSignal.id)) {
          allSignals.push(chochSignal);
          const trade = simulateTrade(chochSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            continue; // Skip other signals this candle - we took a trade
          }
        }
        
        const vwapSignal = generateVWAPTradingSignal(dataSlice);
        if (vwapSignal && !allSignals.some(s => s.id === vwapSignal.id)) {
          allSignals.push(vwapSignal);
          const trade = simulateTrade(vwapSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            continue; // Skip other signals this candle - we took a trade
          }
        }
        
        const emaSignal = generateEMATradingSignal(dataSlice);
        if (emaSignal && !allSignals.some(s => s.id === emaSignal.id)) {
          allSignals.push(emaSignal);
          const trade = simulateTrade(emaSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            continue; // Skip other signals this candle - we took a trade
          }
        }
        
        const rsFlipSignal = generateRSFlipSignal(dataSlice);
        if (rsFlipSignal && !allSignals.some(s => s.id === rsFlipSignal.id)) {
          allSignals.push(rsFlipSignal);
          const trade = simulateTrade(rsFlipSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            continue; // Skip other signals this candle - we took a trade
          }
        }
        
        const bosTrendSignal = generateBOSTrendSignal(dataSlice);
        if (bosTrendSignal && !allSignals.some(s => s.id === bosTrendSignal.id)) {
          allSignals.push(bosTrendSignal);
          const trade = simulateTrade(bosTrendSignal, j, candles);
          if (trade) {
            completedTrades.push(trade);
            lastTradeExitTime = trade.exitTime;
            // No continue needed - this is the last strategy
          }
        }
      }
      
      // Yield to browser to prevent freezing
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    // Calculate statistics
    const winners = completedTrades.filter(t => t.winner);
    const losers = completedTrades.filter(t => !t.winner);
    const totalPL = completedTrades.reduce((sum, t) => sum + t.profitLoss, 0);
    const grossWins = winners.reduce((sum, t) => sum + Math.abs(t.profitLoss), 0);
    const grossLosses = Math.abs(losers.reduce((sum, t) => sum + t.profitLoss, 0));
    const avgRR = completedTrades.length > 0 
      ? completedTrades.reduce((sum, t) => sum + t.rr, 0) / completedTrades.length 
      : 0;
    
    // Calculate position sizing metrics
    const avgPositionSize = completedTrades.length > 0
      ? allSignals.reduce((sum, s) => sum + s.quantity, 0) / allSignals.length
      : 0;
    const finalBalance = accountSize + totalPL;
    const returnPercent = (totalPL / accountSize) * 100;
    
    const results: BacktestResults = {
      trades: completedTrades,
      totalTrades: completedTrades.length,
      winners: winners.length,
      losers: losers.length,
      winRate: completedTrades.length > 0 ? (winners.length / completedTrades.length) * 100 : 0,
      avgRR,
      totalPL,
      profitFactor: grossLosses > 0 ? grossWins / grossLosses : grossWins > 0 ? 999 : 0,
      accountSize,
      riskPerTrade: riskPercent,
      avgPositionSize,
      finalBalance,
      returnPercent,
    };
    
    // Analyze sweep detection vs trade execution (only for Liquidity Grab strategy)
    if (stratLiquidityGrab) {
      const { bos, choch } = calculateBOSandCHoCH(
        candles,
        liqGrabSwingLength,
        liqGrabConfirmCandles,
        liqGrabWickRatio,
        liqGrabUseWickFilter,
        liqGrabUseConfirmCandles
      );
      const allSweeps = [...bos, ...choch].filter(e => e.isLiquidityGrab);
      const liqGrabTrades = completedTrades.filter(t => t.strategy === 'liquidity_grab');
      
      console.log('ðŸ“Š LIQUIDITY GRAB BACKTEST SUMMARY:', {
        totalSweepsDetected: allSweeps.length,
        tradesTaken: liqGrabTrades.length,
        sweepsNotTraded: allSweeps.length - liqGrabTrades.length,
        settings: {
          swingLength: liqGrabSwingLength,
          confirmCandles: liqGrabConfirmCandles,
          wickRatio: liqGrabWickRatio,
          useWickFilter: liqGrabUseWickFilter,
          useConfirmCandles: liqGrabUseConfirmCandles,
          trendFilter: liqGrabTrendFilter,
          directionFilter: liqGrabDirectionFilter,
          numTPs: liqGrabTPSL.numTPs
        }
      });
      
      // Log why sweeps were not traded
      const tradedSweepTimes = new Set(liqGrabTrades.map(t => t.entryTime));
      const untradedSweeps = allSweeps.filter(sweep => !tradedSweepTimes.has(sweep.breakTime));
      
      if (untradedSweeps.length > 0) {
        console.log(`â­ï¸ ${untradedSweeps.length} sweeps were NOT traded:`, 
          untradedSweeps.map(s => ({
            time: new Date(s.breakTime * 1000).toLocaleString(),
            price: s.swingPrice.toFixed(4),
            type: s.sweptLevel === 'low' ? 'LONG (swept low)' : 'SHORT (swept high)',
            reason: 'Likely filtered by trend/direction or overlapping trade'
          }))
        );
      }
    }
    
    console.log('ðŸŽ¯ Backtest complete:', {
      totalTrades: completedTrades.length,
      signals: allSignals.length,
      winners: winners.length,
      losers: losers.length,
      totalPL: totalPL.toFixed(2)
    });
    
    setBacktestResults(results);
    setBacktesting(false);
  }, [candles, generateLiquidityGrabSignal, generateChochFVGSignal, generateVWAPTradingSignal, generateEMATradingSignal, generateRSFlipSignal, generateBOSTrendSignal, simulateTrade, accountSize, riskPercent, liqGrabSwingLength, liqGrabConfirmCandles, liqGrabWickRatio, liqGrabUseWickFilter, liqGrabUseConfirmCandles, liqGrabTrendFilter, liqGrabDirectionFilter, stratLiquidityGrab, calculateBOSandCHoCH, liqGrabTPSL]);

  // Initialize chart
  useEffect(() => {
    if (candles.length === 0 || loading) {
      console.log('Chart init skipped - candles:', candles.length, 'loading:', loading);
      return;
    }
    
    // Prevent recreation if chart already exists
    if (chartRef.current) {
      console.log('Chart already exists, skipping recreation');
      return;
    }
    
    // Use setTimeout to ensure DOM is fully rendered
    const timer = setTimeout(() => {
      if (!chartContainerRef.current) {
        console.log('Chart container ref not available');
        return;
      }
      
      // Double check chart doesn't exist
      if (chartRef.current) {
        console.log('Chart created during timeout, skipping');
        return;
      }
      
      const container = chartContainerRef.current;
      const containerWidth = container.clientWidth > 0 ? container.clientWidth : 800;
      
      console.log('Creating chart - width:', containerWidth, 'candles:', candles.length);
      
      const chart = createChart(container, {
        width: containerWidth,
        height: 600,
        layout: {
          background: { type: ColorType.Solid, color: '#0f172a' },
          textColor: '#d1d5db',
        },
        grid: {
          vertLines: { color: '#1e293b' },
          horzLines: { color: '#1e293b' },
        },
        rightPriceScale: {
          borderVisible: true,
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          },
          autoScale: true,
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
          borderVisible: true,
        },
      });

      const candleSeries = chart.addSeries(CandlestickSeries, {
        upColor: '#10b981',
        downColor: '#ef4444',
        borderVisible: false,
        wickUpColor: '#10b981',
        wickDownColor: '#ef4444',
      });

      candleSeries.setData(candles as any);
      chartRef.current = chart;
      candleSeriesRef.current = candleSeries;

      chart.timeScale().fitContent();
      console.log('Chart created successfully!');
      setChartReady(true);
    }, 100);

    const handleResize = () => {
      if (chartContainerRef.current && chartRef.current) {
        chartRef.current.applyOptions({
          width: chartContainerRef.current.clientWidth,
        });
      }
    };

    window.addEventListener('resize', handleResize);

    return () => {
      clearTimeout(timer);
      window.removeEventListener('resize', handleResize);
      
      if (chartRef.current) {
        setChartReady(false);
        // Clear all series refs before removing chart
        vwapSeriesRefs.current = {};
        fvgSeriesRefs.current = [];
        bosSeriesRefs.current = [];
        chochSeriesRefs.current = [];
        tradeMarkerRefs.current = [];
        
        chartRef.current.remove();
        chartRef.current = null;
        candleSeriesRef.current = null;
      }
    };
  }, [candles.length, loading, symbol, interval]);

  // Update VWAPs
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) return;

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }
    
    const refs = vwapSeriesRefs.current;

    // Helper to manage VWAP series
    const manageVWAP = (
      key: keyof typeof refs,
      show: boolean,
      data: VWAPData[],
      color: string,
      title: string
    ) => {
      if (show && data.length > 0) {
        if (!refs[key]) {
          try {
            refs[key] = chart.addSeries(LineSeries, {
              color,
              lineWidth: 2,
              priceLineVisible: false,
              lastValueVisible: true,
              title,
            });
          } catch (e) {
            // Chart might be disposed
            return;
          }
        }
        try {
          refs[key]!.setData(data as any);
        } catch (e) {
          // Series might be disposed
        }
      } else if (!show && refs[key]) {
        try {
          chart.removeSeries(refs[key]!);
        } catch (e) {
          // Series might already be disposed
        }
        delete refs[key];
      }
    };

    manageVWAP('session', showVWAPSession, calculatePeriodicVWAP(candles, 'daily', true), '#a78bfa', 'Session VWAP');
    manageVWAP('daily', showVWAPDaily, calculatePeriodicVWAP(candles, 'daily', true), '#fb923c', 'Daily VWAP');
    manageVWAP('weekly', showVWAPWeekly, calculatePeriodicVWAP(candles, 'weekly', true), '#10b981', 'Weekly VWAP');
    manageVWAP('monthly', showVWAPMonthly, calculatePeriodicVWAP(candles, 'monthly', true), '#3b82f6', 'Monthly VWAP');
    manageVWAP('rolling10', showVWAPRolling10, calculateRollingVWAP(candles, 10), '#ef4444', 'rVWAP(10)');
    manageVWAP('rolling20', showVWAPRolling20, calculateRollingVWAP(candles, 20), '#ec4899', 'rVWAP(20)');
    manageVWAP('rolling50', showVWAPRolling50, calculateRollingVWAP(candles, 50), '#06b6d4', 'rVWAP(50)');
  }, [chartReady, candles, showVWAPSession, showVWAPDaily, showVWAPWeekly, showVWAPMonthly, showVWAPRolling10, showVWAPRolling20, showVWAPRolling50, calculatePeriodicVWAP, calculateRollingVWAP]);

  // Update FVGs with shaded rectangles
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }
    
    const refs = fvgSeriesRefs.current;

    // Remove old FVG series
    if (Array.isArray(refs) && refs.length > 0) {
      refs.forEach(fl => {
        try {
          if (chart && fl.upper) chart.removeSeries(fl.upper);
        } catch (e) {
          // Series might already be removed
        }
        try {
          if (chart && fl.lower) chart.removeSeries(fl.lower);
        } catch (e) {
          // Series might already be removed
        }
        try {
          if (chart && fl.fill) chart.removeSeries(fl.fill);
        } catch (e) {
          // Series might already be removed
        }
      });
    }
    fvgSeriesRefs.current = [];
    
    if (!showFVG) return;

    // Extract FVG times from active CHoCH+FVG trade signals AND backtest trades
    const activeTradeFVGTimes = new Set<number>();
    
    // Add FVG times from live trade signals
    tradeSignals
      .filter(signal => signal.strategy === 'choch_fvg' && signal.active)
      .forEach(signal => {
        // Signal ID format: choch_fvg_${chochTime}_${fvgTime}
        const parts = signal.id.split('_');
        if (parts.length >= 4) {
          const fvgTime = parseInt(parts[3]);
          if (!isNaN(fvgTime)) {
            activeTradeFVGTimes.add(fvgTime);
          }
        }
      });
    
    // Add FVG times from backtest trades (for replay mode visibility)
    if (backtestResults && backtestResults.trades.length > 0) {
      backtestResults.trades
        .filter(trade => trade.strategy === 'choch_fvg')
        .forEach(trade => {
          // Trade ID format: choch_fvg_${chochTime}_${fvgTime}
          const parts = trade.id.split('_');
          if (parts.length >= 4) {
            const fvgTime = parseInt(parts[3]);
            if (!isNaN(fvgTime)) {
              activeTradeFVGTimes.add(fvgTime);
            }
          }
        });
    }

    const fvgs = calculateFVGs(candles, true);
    const lastTime = candles[candles.length - 1].time;

    fvgs.forEach(fvg => {
      const hasActiveTrade = activeTradeFVGTimes.has(fvg.time);
      
      // Only show FVG if it has an active trade OR if it's still valid (not filled)
      const shouldShow = hasActiveTrade || isActiveFVG(fvg, candles);
      
      if (shouldShow) {
        // Skip non-high-value FVGs if filter is enabled (but always show traded FVGs)
        if (!hasActiveTrade && showHighValueOnly && !fvg.isHighValue) {
          return;
        }

        // Use YELLOW for FVGs with active trades, normal colors otherwise
        let color: string;
        let borderColor: string;
        
        if (hasActiveTrade) {
          // Yellow for active trade FVGs
          color = 'rgba(234, 179, 8, 0.3)'; // Yellow with transparency
          borderColor = '#eab308'; // Solid yellow
        } else {
          // Normal colors based on type and value
          const isHighValue = fvg.isHighValue;
          color = fvg.type === 'bullish' 
            ? (isHighValue ? 'rgba(16, 185, 129, 0.25)' : 'rgba(16, 185, 129, 0.12)')
            : (isHighValue ? 'rgba(239, 68, 68, 0.25)' : 'rgba(239, 68, 68, 0.12)');
          borderColor = fvg.type === 'bullish' 
            ? (isHighValue ? '#10b981' : '#10b98180')
            : (isHighValue ? '#ef4444' : '#ef444480');
        }
        
        // Find all candles from FVG time to fill time (or current time if not filled)
        const fvgIdx = candles.findIndex(c => c.time === fvg.time);
        const fillTime = getFVGFillTime(fvg, candles);
        const endTime = fillTime || lastTime;
        const endIdx = candles.findIndex(c => c.time === endTime);
        const candlesInRange = candles.slice(fvgIdx, endIdx + 1);
        
        // Create histogram series to fill the gap area
        const fillSeries = chart.addSeries(HistogramSeries, {
          color,
          priceFormat: {
            type: 'price',
          },
          priceLineVisible: false,
          lastValueVisible: false,
          base: fvg.lower,
        });
        
        // Create border lines
        const lowerBorder = chart.addSeries(LineSeries, {
          color: borderColor,
          lineWidth: 2, // Thicker borders for better visibility
          priceLineVisible: false,
          lastValueVisible: false,
        });
        
        const upperBorder = chart.addSeries(LineSeries, {
          color: borderColor,
          lineWidth: 2,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        
        // Fill the gap with histogram bars for each time point
        const gapHeight = fvg.upper - fvg.lower;
        const histogramData = candlesInRange.map(c => ({
          time: c.time as any,
          value: fvg.upper, // Draw from base (fvg.lower) to fvg.upper
          color
        }));
        
        try {
          fillSeries.setData(histogramData);
          
          // Add border lines (stop at fill time if filled)
          lowerBorder.setData([
            { time: fvg.time as any, value: fvg.lower },
            { time: endTime as any, value: fvg.lower },
          ]);
          upperBorder.setData([
            { time: fvg.time as any, value: fvg.upper },
            { time: endTime as any, value: fvg.upper },
          ]);
          
          fvgSeriesRefs.current.push({ upper: upperBorder, lower: lowerBorder, fill: fillSeries, fvg });
        } catch (e) {
          // Series might be disposed
        }
      }
    });
  }, [chartReady, candles, showFVG, showHighValueOnly, calculateFVGs, isActiveFVG, getFVGFillTime, tradeSignals, backtestResults]);

  // Update EMAs on chart
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) return;

    const chart = chartRef.current;
    const refs = emaSeriesRefs.current;

    // Helper to manage EMA series
    const manageEMA = (
      key: 'fast' | 'slow',
      show: boolean,
      period: number,
      color: string,
      title: string
    ) => {
      if (show) {
        const closes = candles.map(c => c.close);
        const emaValues = calculateEMA(closes, period);
        const emaData = candles.map((c, i) => ({
          time: c.time as any,
          value: emaValues[i]
        }));

        if (!refs[key]) {
          try {
            refs[key] = chart.addSeries(LineSeries, {
              color,
              lineWidth: 2,
              priceLineVisible: false,
              lastValueVisible: true,
              title,
            });
          } catch (e) {
            // Chart might be disposed
            return;
          }
        }
        try {
          refs[key]!.setData(emaData);
        } catch (e) {
          // Series might be disposed
        }
      } else if (!show && refs[key]) {
        try {
          chart.removeSeries(refs[key]!);
        } catch (e) {
          // Series might already be disposed
        }
        refs[key] = undefined;
      }
    };

    manageEMA('fast', showEMA, emaFastPeriod, '#3b82f6', `EMA ${emaFastPeriod}`);
    manageEMA('slow', showEMA, emaSlowPeriod, '#f59e0b', `EMA ${emaSlowPeriod}`);
  }, [chartReady, candles, showEMA, emaFastPeriod, emaSlowPeriod, calculateEMA]);

  // Update BOS markers with horizontal lines
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }

    // Remove old BOS lines with better error handling
    if (bosSeriesRefs.current.length > 0) {
      bosSeriesRefs.current.forEach(series => {
        try {
          if (series && chart) {
            chart.removeSeries(series);
          }
        } catch (e) {
          // Series already disposed, ignore
        }
      });
      bosSeriesRefs.current = [];
    }
    
    if (!showBOS) return;

    try {
      // Calculate both BOS and CHoCH to detect conflicts
      const { bos } = calculateBOSandCHoCH(candles, chartBosSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles);
      const { choch } = calculateBOSandCHoCH(candles, chartChochSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles);
      
      // Create a Set of CHoCH pivot points (CHoCH takes precedence)
      const chochPivots = new Set(
        choch.map(c => `${c.swingTime}_${c.swingPrice.toFixed(4)}`)
      );
      
      // Filter out BOS that conflict with CHoCH at the same pivot point
      const filteredBos = bos.filter(b => {
        const pivotKey = `${b.swingTime}_${b.swingPrice.toFixed(4)}`;
        return !chochPivots.has(pivotKey);
      });
      
      console.log(`ðŸŽ¯ Drawing ${filteredBos.length} BOS markers on chart (${bos.length - filteredBos.length} filtered due to CHoCH conflict)`);
      
      // Add horizontal line series for each BOS point
      filteredBos.forEach((bosPoint, idx) => {
        try {
          const color = bosPoint.type === 'bullish' ? '#10b981' : '#ef4444';
          
          // All BOS use solid lines
          const bosSeries = chart.addSeries(LineSeries, {
            color,
            lineWidth: 2,
            lineStyle: 0, // Solid lines for all BOS
            priceLineVisible: false,
            lastValueVisible: false,
          });
          
          // Draw horizontal line from swing to break
          const lineData = [
            { time: bosPoint.swingTime as any, value: bosPoint.swingPrice },
            { time: bosPoint.breakTime as any, value: bosPoint.swingPrice },
          ];
          
          if (idx === 0) {
            const swingDate = new Date(bosPoint.swingTime * 1000);
            const breakDate = new Date(bosPoint.breakTime * 1000);
            const candlesBetween = (bosPoint.breakTime - bosPoint.swingTime) / 900; // 900 seconds = 15 min
            console.log('ðŸ” First BOS line:', {
              swingTime: swingDate.toLocaleString(),
              breakTime: breakDate.toLocaleString(),
              candlesBetween,
              price: bosPoint.swingPrice,
              type: bosPoint.type
            });
          }
          
          bosSeries.setData(lineData);
          
          bosSeriesRefs.current.push(bosSeries);
        } catch (lineErr) {
          console.error(`âŒ Failed to draw BOS line ${idx}:`, lineErr, bosPoint);
        }
      });
    } catch (e) {
      console.error('Error updating BOS markers:', e);
    }
  }, [chartReady, candles, showBOS, chartBosSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles, calculateBOSandCHoCH]);

  // Update CHoCH markers with horizontal lines
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }

    // Remove old CHoCH lines with better error handling
    if (chochSeriesRefs.current.length > 0) {
      chochSeriesRefs.current.forEach(series => {
        try {
          if (series && chart) {
            chart.removeSeries(series);
          }
        } catch (e) {
          // Series already disposed, ignore
        }
      });
      chochSeriesRefs.current = [];
    }
    
    if (!showCHoCH) return;

    try {
      // Use chart-only settings for CHoCH display (independent from strategy settings)
      const { choch } = calculateBOSandCHoCH(candles, chartChochSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles);
      
      // Add horizontal line series for each CHoCH point
      choch.forEach(chochPoint => {
        const color = chochPoint.type === 'bullish' ? '#eab308' : '#ec4899'; // Yellow for bullish, Pink for bearish
        
        // CHoCH always uses dashed lines
        const chochSeries = chart.addSeries(LineSeries, {
          color,
          lineWidth: 2,
          lineStyle: 2, // Dashed for CHoCH
          priceLineVisible: false,
          lastValueVisible: false,
        });
        
        // Draw horizontal line from swing to break
        chochSeries.setData([
          { time: chochPoint.swingTime as any, value: chochPoint.swingPrice },
          { time: chochPoint.breakTime as any, value: chochPoint.swingPrice },
        ]);
        
        chochSeriesRefs.current.push(chochSeries);
      });
    } catch (e) {
      console.error('Error updating CHoCH markers:', e);
    }
  }, [chartReady, candles, showCHoCH, chartChochSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles, calculateBOSandCHoCH]);

  // Draw white lines for swing pivots (visual-only indicator)
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }

    // Remove old swing pivot lines
    if (swingPivotSeriesRefs.current.length > 0) {
      swingPivotSeriesRefs.current.forEach(series => {
        try {
          if (series && chart) {
            chart.removeSeries(series);
          }
        } catch (e) {
          // Series already disposed, ignore
        }
      });
      swingPivotSeriesRefs.current = [];
    }
    
    if (!showSwingPivots) return;

    try {
      // Calculate swings at the user-specified swing length
      const swings = calculateSwings(candles, swingPivotLength);
      
      console.log(`ðŸŽ¯ Drawing ${swings.length} swing pivot markers (length: ${swingPivotLength})`);
      
      // Draw a white line for each swing pivot spanning 3 candles
      swings.forEach((swing) => {
        try {
          const pivotSeries = chart.addSeries(LineSeries, {
            color: '#FFFFFF', // White
            lineWidth: 2,
            lineStyle: 0, // Solid
            priceLineVisible: false,
            lastValueVisible: false,
          });
          
          // Find the candle index for this swing
          const swingIndex = candles.findIndex(c => c.time === swing.time);
          if (swingIndex === -1) return;
          
          // Calculate 3-candle span: 1 candle before, the pivot, 1 candle after
          const startIndex = Math.max(0, swingIndex - 1);
          const endIndex = Math.min(candles.length - 1, swingIndex + 1);
          
          const startTime = candles[startIndex].time;
          const endTime = candles[endIndex].time;
          
          // Draw horizontal line at swing price spanning 3 candles
          const lineData = [
            { time: startTime as any, value: swing.value },
            { time: endTime as any, value: swing.value },
          ];
          
          pivotSeries.setData(lineData);
          swingPivotSeriesRefs.current.push(pivotSeries);
        } catch (lineErr) {
          console.error(`âŒ Failed to draw swing pivot line:`, lineErr, swing);
        }
      });
    } catch (e) {
      console.error('Error updating swing pivot markers:', e);
    }
  }, [chartReady, candles, showSwingPivots, swingPivotLength, calculateSwings]);

  // Draw cyan lines for liquidity sweeps (visual-only indicator)
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check - ensure chart hasn't been disposed
    try {
      chart.timeScale();
    } catch (e) {
      return; // Chart is disposed, skip this update
    }

    // Remove old liquidity sweep lines with better error handling
    if (liquiditySweepSeriesRefs.current.length > 0) {
      liquiditySweepSeriesRefs.current.forEach(series => {
        try {
          if (series && chart) {
            chart.removeSeries(series);
          }
        } catch (e) {
          // Series already disposed, ignore
        }
      });
      liquiditySweepSeriesRefs.current = [];
    }
    
    // Show liquidity sweeps on chart when the indicator is toggled (independent of bot strategy)
    if (!stratLiquidityGrab) return;

    try {
      const { bos, choch } = calculateBOSandCHoCH(
        candles,
        chartLiquiditySweepSwingLength,
        chartConfirmCandles,
        chartWickRatio,
        chartUseWickFilter,
        chartUseConfirmCandles
      );
      
      const allSweeps = [...bos, ...choch].filter(e => e.isLiquidityGrab);
      
      console.log(`ðŸ“Š Chart Display: Found ${allSweeps.length} liquidity sweeps out of ${bos.length + choch.length} total BOS/CHoCH`, {
        swingLength: chartLiquiditySweepSwingLength,
        useWickFilter: chartUseWickFilter,
        useConfirmCandles: chartUseConfirmCandles,
        wickRatio: chartWickRatio,
        confirmCandles: chartConfirmCandles
      });
      
      allSweeps.forEach(sweep => {
        const sweepSeries = chart.addSeries(LineSeries, {
          color: '#22d3ee', // Cyan for liquidity sweeps
          lineWidth: 2,
          lineStyle: 0, // Solid line
          priceLineVisible: false,
          lastValueVisible: false,
        });
        
        try {
          sweepSeries.setData([
            { time: sweep.swingTime as any, value: sweep.swingPrice },
            { time: sweep.breakTime as any, value: sweep.swingPrice },
          ]);
          
          liquiditySweepSeriesRefs.current.push(sweepSeries);
        } catch (e) {
          // Series might be disposed
        }
      });
    } catch (e) {
      console.error('Error drawing liquidity sweep lines:', e);
    }
  }, [chartReady, candles, stratLiquidityGrab, chartLiquiditySweepSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles, calculateBOSandCHoCH]);

  // Draw auto trendlines on chart
  useEffect(() => {
    if (!chartReady || !chartRef.current || candles.length < 50) {
      return;
    }

    const chart = chartRef.current;
    
    // Clean up old trendline series
    if (trendlineSeriesRefs.current.length > 0) {
      trendlineSeriesRefs.current.forEach(series => {
        try {
          if (series && chart) {
            chart.removeSeries(series);
          }
        } catch (e) {
          // Series might already be removed
        }
      });
      trendlineSeriesRefs.current = [];
    }
    
    if (!showAutoTrendlines) return;

    try {
      // Adaptive pivot length based on number of visible candles
      const adaptivePivotLength = (() => {
        const candleCount = candles.length;
        if (candleCount < 100) return 2;      // Very sensitive for short timeframes
        if (candleCount < 300) return 5;      // Balanced for medium timeframes
        if (candleCount < 500) return 8;      // Medium sensitivity
        return 10;                              // Major swings only for long timeframes
      })();
      
      // Use user-set pivot length if available, otherwise use adaptive
      const effectivePivotLength = trendlinePivotLength || adaptivePivotLength;
      
      const trendlines = detectTrendlines(candles, trendlineMinTouches, trendlineTolerance, effectivePivotLength);
      
      trendlines.forEach(trendline => {
        const color = trendline.type === 'support' ? '#10b981' : '#ef4444'; // Green for support, red for resistance
        const lineWidth = trendline.strength >= 4 ? 2 : 1; // Thicker for stronger trendlines
        
        // Get first and last point
        const firstPoint = trendline.points[0];
        const lastPoint = trendline.points[trendline.points.length - 1];
        
        // Extend the line to the current price mark (latest candle)
        const currentIndex = candles.length - 1;
        const currentPrice = trendline.slope * currentIndex + trendline.intercept;
        const currentTime = candles[currentIndex].time;
        
        // Create line series
        const trendlineSeries = chart.addSeries(LineSeries, {
          color,
          lineWidth,
          lineStyle: 2, // Dashed line
          priceLineVisible: false,
          lastValueVisible: false,
        });
        
        try {
          // Set data from first touch to current price mark
          trendlineSeries.setData([
            { time: firstPoint.time as any, value: firstPoint.price },
            { time: currentTime as any, value: currentPrice },
          ]);
          
          trendlineSeriesRefs.current.push(trendlineSeries);
        } catch (e) {
          // Series might be disposed
        }
      });
    } catch (e) {
      console.error('Error drawing auto trendlines:', e);
    }
  }, [chartReady, candles, showAutoTrendlines, trendlineMinTouches, trendlineTolerance, trendlinePivotLength, detectTrendlines]);

  // Add text labels overlay for BOS and CHoCH with zoom/pan support
  useEffect(() => {
    if (!chartReady || !chartRef.current || !chartContainerRef.current || candles.length === 0) {
      return;
    }

    const chart = chartRef.current;
    const container = chartContainerRef.current;

    // Clean up old labels
    if (structureLabelsRef.current) {
      structureLabelsRef.current.remove();
      structureLabelsRef.current = null;
    }

    // If labels are disabled, don't create container
    if (!showChartLabels) return;

    // Create container for labels
    const labelsContainer = document.createElement('div');
    labelsContainer.style.position = 'absolute';
    labelsContainer.style.top = '0';
    labelsContainer.style.left = '0';
    labelsContainer.style.width = '100%';
    labelsContainer.style.height = '100%';
    labelsContainer.style.pointerEvents = 'none';
    labelsContainer.style.zIndex = '10';
    container.style.position = 'relative';
    container.appendChild(labelsContainer);
    structureLabelsRef.current = labelsContainer;

    // Store label data for repositioning
    interface LabelData {
      text: string;
      price: number;
      time: number;
      color: string;
      element: HTMLDivElement;
    }
    const labelDataArray: LabelData[] = [];

    const createLabel = (text: string, price: number, time: number, color: string): HTMLDivElement => {
      const label = document.createElement('div');
      label.textContent = text;
      label.style.position = 'absolute';
      label.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      label.style.color = color;
      label.style.padding = '2px 6px';
      label.style.borderRadius = '3px';
      label.style.fontSize = '10px';
      label.style.fontWeight = '600';
      label.style.whiteSpace = 'nowrap';
      label.style.border = `1px solid ${color}`;
      labelsContainer.appendChild(label);
      return label;
    };

    const updateLabelPositions = () => {
      const containerRect = labelsContainer.getBoundingClientRect();
      const chartWidth = containerRect.width;
      const chartHeight = containerRect.height;
      
      labelDataArray.forEach(({ price, time, element }) => {
        try {
          const yCoord = candleSeriesRef.current?.priceToCoordinate(price);
          const xCoord = chart.timeScale().timeToCoordinate(time as any);
          
          if (yCoord === null || yCoord === undefined || xCoord === null) {
            element.style.display = 'none';
            return;
          }

          element.style.display = 'block';
          
          // Get label dimensions
          const labelWidth = element.offsetWidth || 50;
          const labelHeight = element.offsetHeight || 20;
          
          // Calculate position with offset
          let leftPos = xCoord + 5;
          let topPos = yCoord - 10;
          
          // Constrain within chart boundaries
          // Right boundary: ensure label doesn't extend beyond chart width
          if (leftPos + labelWidth > chartWidth) {
            leftPos = Math.max(0, chartWidth - labelWidth - 5);
          }
          // Left boundary
          if (leftPos < 0) {
            leftPos = 5;
          }
          // Bottom boundary
          if (topPos + labelHeight > chartHeight) {
            topPos = Math.max(0, chartHeight - labelHeight - 5);
          }
          // Top boundary
          if (topPos < 0) {
            topPos = 5;
          }
          
          element.style.left = `${leftPos}px`;
          element.style.top = `${topPos}px`;
        } catch (e) {
          element.style.display = 'none';
        }
      });
    };

    // Collect all label data
    // Calculate both BOS and CHoCH first to handle conflicts (CHoCH takes precedence)
    let bosData: any[] = [];
    let chochData: any[] = [];
    
    if (showBOS) {
      try {
        const { bos } = calculateBOSandCHoCH(candles, chartBosSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles);
        bosData = bos.filter(b => !b.isLiquidityGrab);
      } catch (e) {
        console.error('Error calculating BOS labels:', e);
      }
    }

    if (showCHoCH) {
      try {
        const { choch } = calculateBOSandCHoCH(candles, chartChochSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles);
        chochData = choch.filter(c => !c.isLiquidityGrab);
      } catch (e) {
        console.error('Error calculating CHoCH labels:', e);
      }
    }
    
    // Create Set of CHoCH pivot points to filter BOS conflicts
    const chochPivots = new Set(
      chochData.map(c => `${c.swingTime}_${c.swingPrice.toFixed(4)}`)
    );
    
    // Add BOS labels (filtered to exclude CHoCH conflicts)
    if (showBOS) {
      try {
        bosData.forEach(bosPoint => {
          const pivotKey = `${bosPoint.swingTime}_${bosPoint.swingPrice.toFixed(4)}`;
          
          // Skip if CHoCH exists at same pivot (CHoCH takes precedence)
          if (chochPivots.has(pivotKey)) return;
          
          const text = bosPoint.type === 'bullish' ? 'BOSâ†‘' : 'BOSâ†“';
          const color = bosPoint.type === 'bullish' ? '#10b981' : '#ef4444';
          const element = createLabel(text, bosPoint.swingPrice, bosPoint.swingTime, color);
          labelDataArray.push({
            text,
            price: bosPoint.swingPrice,
            time: bosPoint.swingTime,
            color,
            element,
          });
        });
      } catch (e) {
        console.error('Error creating BOS labels:', e);
      }
    }

    // Add CHoCH labels
    if (showCHoCH) {
      try {
        chochData.forEach(chochPoint => {
          const text = chochPoint.type === 'bullish' ? 'CHoCHâ†‘' : 'CHoCHâ†“';
          const color = chochPoint.type === 'bullish' ? '#eab308' : '#ec4899'; // Yellow for bullish, Pink for bearish
          const element = createLabel(text, chochPoint.swingPrice, chochPoint.swingTime, color);
          labelDataArray.push({
            text,
            price: chochPoint.swingPrice,
            time: chochPoint.swingTime,
            color,
            element,
          });
        });
      } catch (e) {
        console.error('Error creating CHoCH labels:', e);
      }
    }
    
    // Add liquidity sweep labels from STRATEGY (cyan)
    if (stratLiquidityGrab) {
      try {
        const { bos, choch } = calculateBOSandCHoCH(
          candles,
          liqGrabSwingLength,
          liqGrabConfirmCandles,
          liqGrabWickRatio,
          liqGrabUseWickFilter,
          liqGrabUseConfirmCandles
        );
        const allSweeps = [...bos, ...choch].filter(e => e.isLiquidityGrab);
        
        allSweeps.forEach(sweep => {
          const text = sweep.type === 'bullish' ? 'â†“â†‘' : 'â†‘â†“';
          const color = '#22d3ee'; // Cyan for liquidity grab strategy
          const element = createLabel(text, sweep.swingPrice, sweep.swingTime, color);
          labelDataArray.push({
            text,
            price: sweep.swingPrice,
            time: sweep.swingTime,
            color,
            element,
          });
        });
      } catch (e) {
        console.error('Error creating liquidity sweep labels:', e);
      }
    }

    // Initial positioning
    updateLabelPositions();

    // Subscribe to time range changes (zoom/pan)
    const handleVisibleTimeRangeChange = () => {
      updateLabelPositions();
    };
    
    chart.timeScale().subscribeVisibleTimeRangeChange(handleVisibleTimeRangeChange);

    // Cleanup function
    return () => {
      try {
        chart.timeScale().unsubscribeVisibleTimeRangeChange(handleVisibleTimeRangeChange);
      } catch (e) {
        // Chart already disposed
      }
      if (structureLabelsRef.current) {
        structureLabelsRef.current.remove();
        structureLabelsRef.current = null;
      }
    };
  }, [chartReady, candles, showBOS, showCHoCH, showChartLabels, chartBosSwingLength, chartChochSwingLength, chartConfirmCandles, chartWickRatio, chartUseWickFilter, chartUseConfirmCandles, stratLiquidityGrab, liqGrabSwingLength, liqGrabConfirmCandles, liqGrabWickRatio, liqGrabUseWickFilter, liqGrabUseConfirmCandles, calculateBOSandCHoCH]);

  // Update backtest trade markers with price level lines and shaded zones
  useEffect(() => {
    if (!chartReady || !chartRef.current || !backtestResults || backtestResults.trades.length === 0) {
      // Clean up old trade markers
      if (tradeMarkerRefs.current.length > 0) {
        tradeMarkerRefs.current.forEach(series => {
          try {
            if (series && chartRef.current) {
              chartRef.current.removeSeries(series);
            }
          } catch (e) {
            // Already disposed
          }
        });
        tradeMarkerRefs.current = [];
      }
      return;
    }

    const chart = chartRef.current;
    
    // Extra safety check
    try {
      chart.timeScale();
    } catch (e) {
      return;
    }

    // Remove old trade markers
    tradeMarkerRefs.current.forEach(series => {
      try {
        chart.removeSeries(series);
      } catch (e) {
        // Already disposed
      }
    });
    tradeMarkerRefs.current = [];

    // Filter trades for replay mode - only show trades that have opened by current replay time
    const currentReplayTime = isReplayMode && candles.length > 0 ? candles[candles.length - 1].time : Infinity;
    const visibleTrades = backtestResults.trades.filter(trade => 
      !isReplayMode || trade.entryTime <= currentReplayTime
    );

    // Collect all markers for visible trades
    const allMarkers: any[] = [];

    // Add shaded zones and horizontal lines for each visible trade
    visibleTrades.forEach(trade => {
      const { entryTime, exitTime, entry, exit, stopLoss, tp1, tp2, tp3, direction, strategy, outcome } = trade;
      
      // Determine numTPs based on strategy
      let numTPs = 1; // Default to 1 TP to be safe
      if (strategy === 'liquidity_grab') {
        numTPs = liqGrabTPSL.numTPs;
      } else if (strategy === 'bos_trend') {
        numTPs = bosTPSL.numTPs;
      } else if (strategy === 'choch_fvg') {
        numTPs = chochTPSL.numTPs;
      } else if (strategy === 'vwap_rejection') {
        numTPs = vwapTPSL.numTPs;
      } else if (strategy === 'rs_flip') {
        numTPs = rsFlipTPSL.numTPs;
      } else if (strategy === 'structure_break') {
        numTPs = 2; // Structure break default
      }
      
      const isLong = direction === 'long';
      
      // ========== SHADED ZONES ==========
      // FIXED ISSUE 4: Risk zone (LOSS) should ALWAYS be RED, Profit zone (GAIN) should ALWAYS be GREEN
      // For LONG: Red zone (Entry to SL - LOSS), Green zone (Entry to TPs - PROFIT)
      // For SHORT: Red zone (Entry to SL - LOSS), Green zone (Entry to TPs - PROFIT)
      
      // Strategy: Draw semi-transparent rectangular zones using multiple close horizontal lines
      // This creates a "filled" visual effect between price levels
      
      const riskColor = 'rgba(239, 68, 68, 0.15)';  // Always RED for risk/loss
      const profitColor = 'rgba(16, 185, 129, 0.15)';  // Always GREEN for profit/gain
      
      // Determine highest TP based on numTPs OR use exit price for signal-based exits
      let highestTP = tp1;
      
      // For signal-based exits (EMA Exit, VWAP Exit), use actual exit price if profitable
      if (outcome === 'EMA Exit' || outcome === 'VWAP Exit') {
        // Check if the trade was profitable
        const isProfit = isLong ? exit > entry : exit < entry;
        if (isProfit) {
          highestTP = exit; // Use exit price for green zone
        } else {
          highestTP = entry; // No profit zone if exit was at a loss
        }
      } else {
        // Regular TP-based exit: use configured TPs
        if (numTPs >= 2 && tp2 !== undefined) highestTP = tp2;
        if (numTPs >= 3 && tp3 !== undefined) highestTP = tp3;
      }
      
      // Create filled zones by drawing many closely-spaced horizontal lines
      // Risk zone (Entry to SL)
      const riskLines = 20; // Number of lines to create filled effect
      const riskStep = Math.abs(stopLoss - entry) / riskLines;
      const riskStart = Math.min(entry, stopLoss);
      
      for (let i = 0; i <= riskLines; i++) {
        const price = riskStart + (riskStep * i);
        const riskLine = chart.addSeries(LineSeries, {
          color: riskColor,
          lineWidth: Math.max(1, Math.ceil(riskStep / (Math.abs(stopLoss - entry) / 100))) as any, // Dynamic width
          lineStyle: 0,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        try {
          riskLine.setData([
            { time: entryTime as any, value: price },
            { time: exitTime as any, value: price },
          ]);
          tradeMarkerRefs.current.push(riskLine);
        } catch (e) {
          // Series might be disposed
        }
      }
      
      // Profit zone (Entry to highest TP)
      const profitLines = 20;
      const profitStep = Math.abs(highestTP - entry) / profitLines;
      const profitStart = Math.min(entry, highestTP);
      
      for (let i = 0; i <= profitLines; i++) {
        const price = profitStart + (profitStep * i);
        const profitLine = chart.addSeries(LineSeries, {
          color: profitColor,
          lineWidth: Math.max(1, Math.ceil(profitStep / (Math.abs(highestTP - entry) / 100))) as any,
          lineStyle: 0,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        try {
          profitLine.setData([
            { time: entryTime as any, value: price },
            { time: exitTime as any, value: price },
          ]);
          tradeMarkerRefs.current.push(profitLine);
        } catch (e) {
          // Series might be disposed
        }
      }
      
      // ========== HORIZONTAL LINES WITHOUT LABELS ==========
      
      // STOP LOSS LINE (Red, thick)
      const slLine = chart.addSeries(LineSeries, {
        color: '#ef4444',
        lineWidth: 2,
        lineStyle: 0, // Solid
        priceLineVisible: false,
        lastValueVisible: false,
      });
      try {
        slLine.setData([
          { time: entryTime as any, value: stopLoss },
          { time: exitTime as any, value: stopLoss },
        ]);
        slLine.applyOptions({
          priceFormat: {
            type: 'price',
            precision: 6,
            minMove: 0.000001,
          },
        });
        tradeMarkerRefs.current.push(slLine);
      } catch (e) {
        // Series might be disposed
      }
      
      // ENTRY LINE (White, dashed)
      const entryLine = chart.addSeries(LineSeries, {
        color: '#ffffff',
        lineWidth: 2,
        lineStyle: 2, // Dashed
        priceLineVisible: false,
        lastValueVisible: false,
      });
      try {
        entryLine.setData([
          { time: entryTime as any, value: entry },
          { time: exitTime as any, value: entry },
        ]);
        entryLine.applyOptions({
          priceFormat: {
            type: 'price',
            precision: 6,
            minMove: 0.000001,
          },
        });
        tradeMarkerRefs.current.push(entryLine);
      } catch (e) {
        // Series might be disposed
      }
      
      // TP1 LINE (Green, solid) - Always draw if numTPs >= 1
      if (numTPs >= 1) {
        const tp1Line = chart.addSeries(LineSeries, {
          color: '#22c55e',
          lineWidth: 2,
          lineStyle: 0,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        try {
          tp1Line.setData([
            { time: entryTime as any, value: tp1 },
            { time: exitTime as any, value: tp1 },
          ]);
          tp1Line.applyOptions({
            priceFormat: {
              type: 'price',
              precision: 6,
              minMove: 0.000001,
            },
          });
          tradeMarkerRefs.current.push(tp1Line);
        } catch (e) {
          // Series might be disposed
        }
      }
      
      // TP2 LINE (Green, dashed) - Only draw if numTPs >= 2
      if (numTPs >= 2 && tp2 !== undefined) {
        const tp2Line = chart.addSeries(LineSeries, {
          color: '#22c55e',
          lineWidth: 2,
          lineStyle: 2,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        try {
          tp2Line.setData([
            { time: entryTime as any, value: tp2 },
            { time: exitTime as any, value: tp2 },
          ]);
          tp2Line.applyOptions({
            priceFormat: {
              type: 'price',
              precision: 6,
              minMove: 0.000001,
            },
          });
          tradeMarkerRefs.current.push(tp2Line);
        } catch (e) {
          // Series might be disposed
        }
      }
      
      // TP3 LINE (Green, dotted) - Only draw if numTPs >= 3
      if (numTPs >= 3 && tp3 !== undefined) {
        const tp3Line = chart.addSeries(LineSeries, {
          color: '#22c55e',
          lineWidth: 2,
          lineStyle: 3,
          priceLineVisible: false,
          lastValueVisible: false,
        });
        try {
          tp3Line.setData([
            { time: entryTime as any, value: tp3 },
            { time: exitTime as any, value: tp3 },
          ]);
          tp3Line.applyOptions({
            priceFormat: {
              type: 'price',
              precision: 6,
              minMove: 0.000001,
            },
          });
          tradeMarkerRefs.current.push(tp3Line);
        } catch (e) {
          // Series might be disposed
        }
      }
      
      // ========== CHART-ANCHORED MARKERS (LABELS) ==========
      // Add text markers at entry time for each price level
      
      // Entry marker (white)
      allMarkers.push({
        time: entryTime,
        position: isLong ? 'belowBar' : 'aboveBar',
        color: '#ffffff',
        shape: 'square',
        text: `Entry ${typeof entry === 'number' ? entry.toFixed(6) : entry}`
      });
      
      // Stop Loss marker (red) - only show if we have a numeric stop loss
      if (stopLoss !== undefined && stopLoss !== null && stopLoss !== 'N/A' && typeof stopLoss === 'number') {
        allMarkers.push({
          time: entryTime,
          position: isLong ? 'belowBar' : 'aboveBar',
          color: '#ef4444',
          shape: 'square',
          text: `SL ${stopLoss.toFixed(6)}`
        });
      }
      
      // TP markers (green)
      if (numTPs >= 1 && tp1 !== undefined && tp1 !== null && typeof tp1 === 'number') {
        allMarkers.push({
          time: entryTime,
          position: isLong ? 'aboveBar' : 'belowBar',
          color: '#22c55e',
          shape: 'square',
          text: `TP1 ${tp1.toFixed(6)}`
        });
      }
      
      if (numTPs >= 2 && tp2 !== undefined && tp2 !== null && typeof tp2 === 'number') {
        allMarkers.push({
          time: entryTime,
          position: isLong ? 'aboveBar' : 'belowBar',
          color: '#22c55e',
          shape: 'square',
          text: `TP2 ${tp2.toFixed(6)}`
        });
      }
      
      if (numTPs >= 3 && tp3 !== undefined && tp3 !== null && typeof tp3 === 'number') {
        allMarkers.push({
          time: entryTime,
          position: isLong ? 'aboveBar' : 'belowBar',
          color: '#22c55e',
          shape: 'square',
          text: `TP3 ${tp3.toFixed(6)}`
        });
      }
    });
    
    // Set all markers at once on the candlestick series
    if (candleSeriesRef.current && allMarkers.length > 0) {
      try {
        const series = candleSeriesRef.current as any;
        if (series && typeof series.setMarkers === 'function') {
          series.setMarkers(allMarkers);
        }
      } catch (e) {
        console.error('Failed to set markers on candlestick series:', e);
      }
    }
  }, [chartReady, backtestResults, candles, liqGrabTPSL, bosTPSL, chochTPSL, vwapTPSL, isReplayMode]);

  // ========== DEBOUNCE EFFECTS FOR STRATEGY SETTINGS ==========
  
  // Liquidity Grab Strategy
  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(liqGrabSwingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 20) {
        setLiqGrabSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [liqGrabSwingLengthInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(liqGrabConfirmCandlesInput);
      if (!isNaN(num) && num >= 1 && num <= 5) {
        setLiqGrabConfirmCandles(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [liqGrabConfirmCandlesInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(liqGrabWickRatioInput);
      if (!isNaN(num) && num >= 50 && num <= 500) {
        setLiqGrabWickRatio(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [liqGrabWickRatioInput]);

  // BOS Structure Strategy
  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(bosSwingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 20) {
        setBosSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [bosSwingLengthInput]);

  // CHoCH + FVG Strategy
  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(chochSwingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 20) {
        setChochSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [chochSwingLengthInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(chochTPSwingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 50) {
        setChochTPSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [chochTPSwingLengthInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(chochSLSwingLengthInput);
      if (!isNaN(num) && num >= 3 && num <= 30) {
        setChochSLSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [chochSLSwingLengthInput]);

  // Chart Liquidity Sweep Settings (separate from bot strategy)
  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(chartLiquiditySweepSwingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 50) {
        setChartLiquiditySweepSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [chartLiquiditySweepSwingLengthInput]);

  // Legacy debounce effects (deprecated - keeping for backward compatibility)
  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(swingLengthInput);
      if (!isNaN(num) && num >= 5 && num <= 20) {
        setSwingLength(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [swingLengthInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(liqGrabInput);
      if (!isNaN(num) && num >= 1 && num <= 5) {
        setLiqGrabCandles(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [liqGrabInput]);

  useEffect(() => {
    const timer = setTimeout(() => {
      const num = parseInt(wickRatioInput);
      if (!isNaN(num) && num >= 50 && num <= 500) {
        setWickToBodyRatio(num);
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [wickRatioInput]);

  // Determine bias when candles change
  useEffect(() => {
    if (candles.length > 0) {
      determineBias(candles);
      determineStructureTrend(candles);
    }
  }, [candles, determineBias, determineStructureTrend]);

  // Generate signals when candles update or bot settings change
  useEffect(() => {
    if (botEnabled && candles.length > 0) {
      generateSignals();
    }
  }, [candles, botEnabled, generateSignals]);

  // Detect market alerts when candles update
  useEffect(() => {
    if (candles.length > 0) {
      detectMarketAlerts();
    }
  }, [candles, detectMarketAlerts]);

  // Fetch initial data on mount
  useEffect(() => {
    fetchInitialData();
  }, [fetchInitialData]);

  // WebSocket connection for real-time updates
  useEffect(() => {
    if (!symbol || !interval || candles.length === 0) return;

    const ws = new WebSocket('wss://stream.binance.us:9443/ws');
    wsRef.current = ws;

    ws.onopen = () => {
      ws.send(JSON.stringify({
        method: 'SUBSCRIBE',
        params: [
          `${symbol.toLowerCase()}@kline_${interval}`,
          `${symbol.toLowerCase()}@trade`,
        ],
        id: 1,
      }));
    };

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      
      if (msg.e === 'kline') {
        const k = msg.k;
        const bar: CandleData = {
          time: k.t / 1000,
          open: parseFloat(k.o),
          high: parseFloat(k.h),
          low: parseFloat(k.l),
          close: parseFloat(k.c),
          volume: parseFloat(k.v),
        };

        setCandles(prev => {
          const newCandles = [...prev];
          if (k.x) { // Candle closed
            if (bar.time > newCandles[newCandles.length - 1].time) {
              newCandles.push(bar);
              // Save delta for this closed candle (use real delta if available)
              setDeltaHistory(prevHist => {
                const delta = realDeltaData.get(bar.time) || currentDelta;
                const newHist = [...prevHist, {
                  time: new Date(bar.time * 1000).toLocaleTimeString(),
                  delta,
                  cumDelta: cumDelta,
                  isBull: bar.close >= bar.open,
                  volume: bar.volume
                }];
                return newHist.slice(-20); // Keep last 20
              });
              setCurrentDelta(0);
            } else {
              newCandles[newCandles.length - 1] = bar;
            }
          } else {
            // Update last candle
            if (bar.time === newCandles[newCandles.length - 1].time) {
              newCandles[newCandles.length - 1] = bar;
            } else {
              newCandles.push(bar);
            }
          }
          return newCandles;
        });

        if (candleSeriesRef.current) {
          candleSeriesRef.current.update(bar as any);
        }
      } else if (msg.e === 'trade') {
        const qty = parseFloat(msg.q);
        const isBuy = !msg.m; // Buyer is maker = sell, not maker = buy
        const delta = isBuy ? qty : -qty;
        setCurrentDelta(prev => prev + delta);
        setCumDelta(prev => prev + delta);
      }
    };

    return () => {
      ws.close();
    };
  }, [symbol, interval, candles.length]);

  // Replay mode auto-play effect
  useEffect(() => {
    if (isReplayPlaying && isReplayMode && fullCandleData.length > 0) {
      const baseInterval = 1000; // 1 second base
      const intervalDuration = baseInterval / replaySpeed;
      
      const timer: any = setInterval(() => {
        setReplayIndex(prev => {
          if (prev >= fullCandleData.length) {
            setIsReplayPlaying(false);
            return prev;
          }
          return prev + 1;
        });
      }, intervalDuration);
      
      replayIntervalRef.current = timer as NodeJS.Timeout;

      return () => {
        if (replayIntervalRef.current) {
          clearInterval(replayIntervalRef.current);
          replayIntervalRef.current = null;
        }
      };
    } else {
      if (replayIntervalRef.current) {
        clearInterval(replayIntervalRef.current);
        replayIntervalRef.current = null;
      }
    }
  }, [isReplayPlaying, isReplayMode, replaySpeed, fullCandleData.length]);

  // Update candles when in replay mode
  useEffect(() => {
    if (isReplayMode && fullCandleData.length > 0) {
      // Store current visible range before updating candles
      let savedRange: any = null;
      if (chartRef.current) {
        try {
          savedRange = chartRef.current.timeScale().getVisibleRange();
        } catch (e) {
          // Chart might not be ready
        }
      }
      
      const replayCandles = fullCandleData.slice(0, replayIndex);
      setCandles(replayCandles);
      
      // Restore visible range after candles update (in next tick)
      if (savedRange) {
        setTimeout(() => {
          if (chartRef.current) {
            try {
              chartRef.current.timeScale().setVisibleRange(savedRange);
            } catch (e) {
              // Chart might be updating
            }
          }
        }, 50);
      }
    }
  }, [isReplayMode, replayIndex, fullCandleData]);

  // Store full candle data when new data is fetched (not in replay mode)
  useEffect(() => {
    if (!isReplayMode && candles.length > 0) {
      // Always update fullCandleData with latest candles when not in replay mode
      setFullCandleData([...candles]);
    }
  }, [candles.length, isReplayMode]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-cyan-50 to-blue-50 p-4">
      <div className="max-w-[1800px] mx-auto space-y-4">
        {/* Header with BearTec Logo */}
        <div className="flex flex-col items-center gap-4">
          {/* BearTec Logo with Crypto Stamp */}
          <div className="relative inline-block">
            <img 
              src={bearTecLogo} 
              alt="BearTec Logo" 
              className="h-[138px] object-contain"
            />
            {/* Crypto Stamp - rotated -25Â° (anti-clockwise), overlapping text slightly */}
            <img 
              src={cryptoStamp} 
              alt="Crypto Stamp" 
              className="absolute h-[114px] w-[114px] object-contain"
              style={{
                bottom: '-20px',
                right: '100px',
                transform: 'rotate(-25deg) translate(50%, 50%)',
                transformOrigin: 'center'
              }}
            />
          </div>
          
          {/* Ticker and Timeframe Selectors */}
          <div className="flex items-center gap-4 mt-8">
            <Select value={symbol} onValueChange={setSymbol}>
              <SelectTrigger className="w-40 bg-slate-800 text-white border-slate-600">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="XRPUSDT">XRP/USDT</SelectItem>
                <SelectItem value="BTCUSDT">BTC/USDT</SelectItem>
                <SelectItem value="ETHUSDT">ETH/USDT</SelectItem>
                <SelectItem value="ADAUSDT">ADA/USDT</SelectItem>
                <SelectItem value="SOLUSDT">SOL/USDT</SelectItem>
              </SelectContent>
            </Select>
            <Select value={interval} onValueChange={setInterval}>
              <SelectTrigger className="w-32 bg-slate-800 text-white border-slate-600">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1m">1m</SelectItem>
                <SelectItem value="5m">5m</SelectItem>
                <SelectItem value="15m">15m</SelectItem>
                <SelectItem value="1h">1h</SelectItem>
                <SelectItem value="4h">4h</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* Replay Mode Controls */}
        <Card className="bg-slate-800 border-slate-700">
          <CardContent className="p-3">
            <div className="space-y-2">
              {/* Row 1: Toggle, Reset, and Playback Controls */}
              <div className="flex items-center gap-2 flex-wrap">
                <div className="flex items-center gap-2 bg-slate-900 px-3 py-2 rounded">
                  <Label className="text-white font-semibold text-sm">Replay Mode</Label>
                  <Switch 
                    checked={isReplayMode} 
                    onCheckedChange={(checked) => {
                      setIsReplayMode(checked);
                      if (checked) {
                        // Entering replay mode
                        const currentCandles = [...candles];
                        setFullCandleData(currentCandles);
                        setReplayIndex(100);
                        setIsReplayPlaying(false);
                        if (replayIntervalRef.current) {
                          clearInterval(replayIntervalRef.current);
                          replayIntervalRef.current = null;
                        }
                      } else {
                        // Exiting replay mode - restore all candles
                        if (replayIntervalRef.current) {
                          clearInterval(replayIntervalRef.current);
                          replayIntervalRef.current = null;
                        }
                        setIsReplayPlaying(false);
                        // Restore full candles
                        if (fullCandleData.length > 0) {
                          setCandles([...fullCandleData]);
                        }
                      }
                    }}
                  />
                </div>

                {isReplayMode && (
                  <>
                    <button
                      onClick={() => setReplayIndex(100)}
                      className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-white rounded text-sm font-semibold transition-colors"
                      data-testid="button-replay-reset"
                    >
                      ðŸ”„ Reset
                    </button>
                    
                    <div className="flex items-center gap-1.5 bg-slate-900 px-2 py-1.5 rounded">
                      <button
                        onClick={() => setReplayIndex(Math.max(100, replayIndex - 10))}
                        disabled={replayIndex <= 100}
                        className="px-2.5 py-1 bg-orange-600 hover:bg-orange-700 disabled:bg-slate-800 disabled:cursor-not-allowed text-white rounded text-xs font-semibold transition-colors"
                        data-testid="button-replay-backward-10"
                      >
                        âª -10
                      </button>
                      <button
                        onClick={() => setReplayIndex(Math.max(100, replayIndex - 1))}
                        disabled={replayIndex <= 100}
                        className="px-2.5 py-1 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:cursor-not-allowed text-white rounded text-xs font-semibold transition-colors"
                        data-testid="button-replay-backward-1"
                      >
                        â—€ -1
                      </button>
                      <button
                        onClick={() => {
                          if (isReplayPlaying) {
                            setIsReplayPlaying(false);
                            if (replayIntervalRef.current) {
                              clearInterval(replayIntervalRef.current);
                              replayIntervalRef.current = null;
                            }
                          } else {
                            setIsReplayPlaying(true);
                          }
                        }}
                        className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-xs font-semibold transition-colors"
                        data-testid="button-replay-play"
                      >
                        {isReplayPlaying ? 'â¸ Pause' : 'â–¶ Play'}
                      </button>
                      <button
                        onClick={() => setReplayIndex(Math.min(fullCandleData.length, replayIndex + 1))}
                        disabled={replayIndex >= fullCandleData.length}
                        className="px-2.5 py-1 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:cursor-not-allowed text-white rounded text-xs font-semibold transition-colors"
                        data-testid="button-replay-forward-1"
                      >
                        +1 â–¶
                      </button>
                      <button
                        onClick={() => setReplayIndex(Math.min(fullCandleData.length, replayIndex + 10))}
                        disabled={replayIndex >= fullCandleData.length}
                        className="px-2.5 py-1 bg-orange-600 hover:bg-orange-700 disabled:bg-slate-800 disabled:cursor-not-allowed text-white rounded text-xs font-semibold transition-colors"
                        data-testid="button-replay-forward-10"
                      >
                        +10 â©
                      </button>
                    </div>
                  </>
                )}
              </div>

              {/* Row 2: Speed & Progress Bar */}
              {isReplayMode && (
                <div className="flex items-center gap-3">
                  <div className="flex items-center gap-2">
                    <Label className="text-gray-400 text-xs">Speed:</Label>
                    <Select value={replaySpeed.toString()} onValueChange={(v) => setReplaySpeed(parseInt(v))}>
                      <SelectTrigger className="w-20 h-7 bg-slate-900 text-white border-slate-600 text-xs">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="1">1x</SelectItem>
                        <SelectItem value="2">2x</SelectItem>
                        <SelectItem value="5">5x</SelectItem>
                        <SelectItem value="10">10x</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="flex-1 flex items-center gap-2">
                    <span className="text-gray-400 text-xs whitespace-nowrap">
                      {replayIndex} / {fullCandleData.length} candles
                    </span>
                    <div className="flex-1 bg-slate-900 rounded h-2 overflow-hidden">
                      <div 
                        className="bg-blue-500 h-full transition-all duration-200"
                        style={{ width: `${(replayIndex / fullCandleData.length) * 100}%` }}
                      />
                    </div>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-4 bg-transparent">
          {/* Main Chart */}
          <div className="lg:col-span-3 bg-transparent">
            <Card className="bg-slate-800 border-slate-700">
              <CardContent className="p-4 bg-slate-800">
                {loading ? (
                  <div className="h-[600px] flex items-center justify-center bg-slate-800">
                    <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
                  </div>
                ) : (
                  <div 
                    ref={chartContainerRef} 
                    className="w-full h-[600px] relative bg-[#0f172a] overflow-hidden" 
                    style={{ minHeight: '600px', background: '#0f172a' }}
                  />
                )}
              </CardContent>
            </Card>
          </div>

          {/* Right Panel: Bot Status & Signals */}
          <div className="space-y-4 bg-transparent">
            {/* Market Status */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader>
                <CardTitle className="text-white text-lg flex items-center gap-2">
                  <Activity className="h-5 w-5" />
                  Market Status
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300">EMA Bias</Label>
                  <div className="flex items-center gap-2">
                    {bias === 'bullish' ? (
                      <><TrendingUp className="h-4 w-4 text-green-500" /><span className="text-green-500 font-semibold">Bullish</span></>
                    ) : bias === 'bearish' ? (
                      <><TrendingDown className="h-4 w-4 text-red-500" /><span className="text-red-500 font-semibold">Bearish</span></>
                    ) : (
                      <span className="text-gray-500">-</span>
                    )}
                  </div>
                </div>
                <div className="flex items-center justify-between pt-2 border-t border-slate-700">
                  <Label className="text-gray-300">Structure</Label>
                  <div className="flex items-center gap-2">
                    {structureTrend === 'uptrend' ? (
                      <><TrendingUp className="h-4 w-4 text-green-500" /><span className="text-green-500 font-semibold">Uptrend</span></>
                    ) : structureTrend === 'downtrend' ? (
                      <><TrendingDown className="h-4 w-4 text-red-500" /><span className="text-red-500 font-semibold">Downtrend</span></>
                    ) : (
                      <span className="text-gray-500">Ranging</span>
                    )}
                  </div>
                </div>
                <div className="flex items-center justify-between pt-2 border-t border-slate-700">
                  <Label className="text-gray-300">Cum. Delta</Label>
                  <span className={cumDelta > 0 ? 'text-green-500 font-semibold' : 'text-red-500 font-semibold'}>
                    {cumDelta.toFixed(0)}
                  </span>
                </div>
              </CardContent>
            </Card>

            {/* AI Market Analysis */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CardTitle className="text-white text-sm flex items-center gap-2">
                      <span className="text-lg">ðŸ¤–</span>
                      AI Market Analysis
                    </CardTitle>
                    <img src={grokLogo} alt="Grok" className="h-4 brightness-110" />
                  </div>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => setAiAnalysisExpanded(!aiAnalysisExpanded)}
                    className="h-7 w-7 p-0 border-slate-600 hover:bg-slate-700"
                  >
                    {aiAnalysisExpanded ? <ChevronUp className="h-4 w-4 text-gray-300" /> : <ChevronDown className="h-4 w-4 text-gray-300" />}
                  </Button>
                </div>
              </CardHeader>
              {aiAnalysisExpanded && (
                <CardContent className="space-y-2">
                  {aiAnalysisLoading ? (
                    <div className="flex items-center justify-center py-4">
                      <Loader2 className="h-5 w-5 animate-spin text-blue-500" />
                      <span className="ml-2 text-sm text-gray-400">Analyzing market...</span>
                    </div>
                  ) : aiAnalysis ? (
                    <>
                      <div className="text-xs text-gray-300 whitespace-pre-wrap bg-slate-900 p-3 rounded border border-slate-700">
                        {aiAnalysis}
                      </div>
                      <div className="flex items-center justify-between text-xs text-gray-500 pt-1 border-t border-slate-700">
                        <span className="italic">
                          Written with Grok
                        </span>
                        <span>
                          {aiAnalysisTimestamp ? new Date(aiAnalysisTimestamp).toLocaleTimeString() : '-'}
                        </span>
                      </div>
                      <div className="text-xs text-gray-600 px-2 py-1 bg-slate-900/50 rounded border border-slate-700/50">
                        <span className="opacity-75">Note: This analysis uses Grok API. We are not affiliated with or endorsed by xAI.</span>
                      </div>
                      <Button
                        size="sm"
                        onClick={() => fetchAIAnalysis(true)}
                        className="w-full h-7 text-xs"
                        disabled={aiAnalysisLoading}
                      >
                        Refresh Analysis
                      </Button>
                    </>
                  ) : (
                    <div className="text-center py-4">
                      <p className="text-xs text-gray-400 mb-2">
                        {candles.length < 100 ? 'Loading chart data...' : 'Click to analyze market conditions'}
                      </p>
                      <Button
                        size="sm"
                        onClick={() => fetchAIAnalysis(true)}
                        className="h-7 text-xs"
                        disabled={candles.length < 100}
                      >
                        Generate Analysis
                      </Button>
                    </div>
                  )}
                </CardContent>
              )}
            </Card>

            {/* Market Alerts */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader className="pb-3">
                <CardTitle className="text-white text-lg flex items-center gap-2">
                  <Bell className="h-5 w-5" />
                  Market Alerts
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-2">
                {marketAlerts.length === 0 ? (
                  <div className="text-gray-400 text-sm text-center py-4">
                    No alerts yet
                  </div>
                ) : (
                  <div className="space-y-2 max-h-[300px] overflow-y-auto">
                    {marketAlerts.slice(0, 10).map((alert) => (
                      <div 
                        key={alert.id}
                        className="bg-slate-900 p-2 rounded border border-slate-700"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            {alert.type === 'Liquidity Sweep' && (
                              <span className="text-yellow-400 text-xs font-semibold">ðŸ’§ SWEEP</span>
                            )}
                            {alert.type === 'BOS' && (
                              <span className="text-green-400 text-xs font-semibold">ðŸ“ˆ BOS</span>
                            )}
                            {alert.type === 'CHoCH' && (
                              <span className="text-orange-400 text-xs font-semibold">ðŸ”„ CHoCH</span>
                            )}
                            {alert.type === 'FVG' && (
                              <span className="text-purple-400 text-xs font-semibold">â¬œ FVG</span>
                            )}
                            {alert.type === 'VWAP Bounce' && (
                              <span className="text-cyan-400 text-xs font-semibold">ðŸ“Š VWAP BOUNCE</span>
                            )}
                            {alert.type === 'VWAP Cross' && (
                              <span className="text-blue-400 text-xs font-semibold">â†—ï¸ VWAP X</span>
                            )}
                            {alert.direction === 'bullish' ? (
                              <TrendingUp className="h-3 w-3 text-green-500" />
                            ) : (
                              <TrendingDown className="h-3 w-3 text-red-500" />
                            )}
                          </div>
                          <span className="text-xs text-gray-400">
                            {new Date(alert.time * 1000).toLocaleString('en-GB', { 
                              day: '2-digit', 
                              month: '2-digit', 
                              year: 'numeric',
                              hour: '2-digit', 
                              minute: '2-digit' 
                            })}
                          </span>
                        </div>
                        <div className="text-xs text-gray-300 mt-1">
                          {alert.description}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Footprint Delta Table */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-white text-sm">Footprint Delta vs CVD</CardTitle>
                  <div className="flex items-center gap-2">
                    {multiExchangeLoading && (
                      <span className="text-xs text-yellow-400">Loading...</span>
                    )}
                    {multiExchangeData?.metadata && (
                      <div className="flex items-center gap-2">
                        <span className="text-xs text-green-400">
                          ðŸŒ Multi-Exchange
                        </span>
                        <details className="relative group">
                          <summary className="cursor-pointer text-xs text-cyan-400 hover:text-cyan-300 list-none">
                            {multiExchangeData.metadata.exchanges.filter((e: any) => e.success).length}/{multiExchangeData.metadata.exchanges.length} â„¹ï¸
                          </summary>
                          <div className="absolute right-0 top-6 z-50 bg-slate-900 border border-slate-700 rounded-md shadow-xl p-3 min-w-[280px]">
                            <div className="text-xs font-semibold text-white mb-2 border-b border-slate-700 pb-2">
                              Exchange Status
                            </div>
                            <div className="space-y-1.5">
                              {multiExchangeData.metadata.exchanges.map((ex: any) => (
                                <div key={ex.exchange_id} className="flex items-center justify-between text-xs">
                                  <div className="flex items-center gap-2">
                                    {ex.success ? (
                                      <span className="text-green-400">âœ“</span>
                                    ) : (
                                      <span className="text-red-400">âœ—</span>
                                    )}
                                    <span className={ex.success ? 'text-gray-300' : 'text-gray-500'}>
                                      {ex.exchange}
                                    </span>
                                  </div>
                                  <div className="flex items-center gap-2">
                                    {ex.success && (
                                      <>
                                        <span className="text-gray-400">{ex.trades_count} trades</span>
                                        <span className="text-gray-500">{ex.response_time_ms}ms</span>
                                        {ex.retries > 0 && (
                                          <span className="text-yellow-400 text-[10px]">â†»{ex.retries}</span>
                                        )}
                                      </>
                                    )}
                                    {!ex.success && ex.error && (
                                      <span className="text-red-400 text-[10px] max-w-[120px] truncate" title={ex.error}>
                                        {ex.error}
                                      </span>
                                    )}
                                  </div>
                                </div>
                              ))}
                            </div>
                            <div className="mt-2 pt-2 border-t border-slate-700 text-[10px] text-gray-400">
                              Avg response: {Math.round(multiExchangeData.metadata.avg_response_time_ms)}ms | 
                              Success: {(multiExchangeData.metadata.success_rate * 100).toFixed(0)}%
                            </div>
                          </div>
                        </details>
                      </div>
                    )}
                  </div>
                </div>
                {useMultiExchange && multiExchangeData?.divergences && multiExchangeData.divergences.length > 0 && (
                  <div className="mt-2 text-xs text-yellow-400 bg-yellow-900/20 p-2 rounded border border-yellow-700/50">
                    âš ï¸ {multiExchangeData.divergences.length} divergence alert{multiExchangeData.divergences.length > 1 ? 's' : ''} detected
                  </div>
                )}
              </CardHeader>
              <CardContent>
                <div className="max-h-[300px] overflow-y-auto">
                  <table className="w-full text-xs">
                    <thead className="sticky top-0 bg-slate-800">
                      <tr className="border-b border-slate-600">
                        <th className="text-left text-gray-400 py-1 px-1">Time</th>
                        <th className="text-right text-gray-400 py-1 px-1">Delta</th>
                        <th className="text-right text-gray-400 py-1 px-1">CVD</th>
                        {useMultiExchange && (
                          <>
                            <th className="text-center text-gray-400 py-1 px-1" title="Number of exchanges">Ex</th>
                            <th className="text-center text-gray-400 py-1 px-1" title="Confidence level">Conf</th>
                          </>
                        )}
                        <th className="text-center text-gray-400 py-1 px-1">Vol</th>
                      </tr>
                    </thead>
                    <tbody>
                      {deltaHistory.length === 0 ? (
                        <tr>
                          <td colSpan={4} className="text-center text-gray-500 py-2">No data yet</td>
                        </tr>
                      ) : (
                        <>
                          {/* LIVE Current Bar */}
                          {(() => {
                            const currentBar = deltaHistory[deltaHistory.length - 1];
                            if (!currentBar) return null;
                            
                            // Calculate separate averages for bullish and bearish bars
                            const bullishBars = deltaHistory.filter(h => h.delta > 0);
                            const bearishBars = deltaHistory.filter(h => h.delta < 0);
                            const avgBullishDelta = bullishBars.length > 0 
                              ? bullishBars.reduce((sum, h) => sum + h.delta, 0) / bullishBars.length 
                              : 0;
                            const avgBearishDelta = bearishBars.length > 0 
                              ? bearishBars.reduce((sum, h) => sum + h.delta, 0) / bearishBars.length 
                              : 0;
                            
                            const isBullishSpike = currentBar.delta > 0 && currentBar.delta >= avgBullishDelta * 2;
                            const isBearishSpike = currentBar.delta < 0 && currentBar.delta <= avgBearishDelta * 2;
                            const hasDivergence = useMultiExchange && currentBar.divergence;
                            
                            return (
                              <tr className="bg-blue-900/30 border-b-2 border-blue-500 animate-pulse">
                                <td className="text-blue-300 py-1 px-1 font-mono text-[10px] font-bold">
                                  ðŸ”´ LIVE
                                </td>
                                <td className={`text-right py-1 px-1 font-mono font-bold ${currentBar.delta > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                  {currentBar.delta > 0 ? '+' : ''}{(currentBar.delta / 1000).toFixed(1)}k
                                </td>
                                <td className={`text-right py-1 px-1 font-mono font-bold ${currentBar.cumDelta > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                  {(currentBar.cumDelta / 1000).toFixed(1)}k
                                </td>
                                {useMultiExchange && (
                                  <>
                                    <td className="text-center py-1 px-1 text-gray-300 font-semibold">
                                      {currentBar.exchanges || 0}
                                    </td>
                                    <td className="text-center py-1 px-1">
                                      <span className={`text-[10px] font-bold ${
                                        (currentBar.confidence || 0) >= 0.8 ? 'text-green-400' :
                                        (currentBar.confidence || 0) >= 0.6 ? 'text-yellow-400' :
                                        'text-red-400'
                                      }`}>
                                        {((currentBar.confidence || 0) * 100).toFixed(0)}%
                                      </span>
                                    </td>
                                  </>
                                )}
                                <td className="text-center py-1 px-1">
                                  {hasDivergence && <span className="text-yellow-400 text-xs" title="Exchange divergence">âš ï¸</span>}
                                  {isBullishSpike && !hasDivergence && <span className="text-green-400 text-xs" title="Bullish delta spike (2x avg)">ðŸ”¥</span>}
                                  {isBearishSpike && !hasDivergence && !isBullishSpike && <span className="text-red-400 text-xs" title="Bearish delta spike (2x avg)">ðŸ”¥</span>}
                                </td>
                              </tr>
                            );
                          })()}
                          
                          {/* Historical Bars */}
                          {deltaHistory.slice(0, -1).reverse().map((item, idx) => {
                            // Calculate separate averages for bullish and bearish bars
                            const bullishBars = deltaHistory.filter(h => h.delta > 0);
                            const bearishBars = deltaHistory.filter(h => h.delta < 0);
                            const avgBullishDelta = bullishBars.length > 0 
                              ? bullishBars.reduce((sum, h) => sum + h.delta, 0) / bullishBars.length 
                              : 0;
                            const avgBearishDelta = bearishBars.length > 0 
                              ? bearishBars.reduce((sum, h) => sum + h.delta, 0) / bearishBars.length 
                              : 0;
                            
                            const isBullishSpike = item.delta > 0 && item.delta >= avgBullishDelta * 2;
                            const isBearishSpike = item.delta < 0 && item.delta <= avgBearishDelta * 2;
                            const hasDivergence = useMultiExchange && item.divergence;
                            const cellBg = hasDivergence 
                              ? 'bg-yellow-900/20' 
                              : item.isBull ? 'bg-green-900/20' : 'bg-red-900/20';
                            
                            return (
                              <tr key={idx} className={`border-b border-slate-700/50 ${cellBg}`}>
                              <td className="text-gray-300 py-1 px-1 font-mono text-[10px]">{item.time}</td>
                              <td className={`text-right py-1 px-1 font-mono font-semibold ${item.delta > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                {item.delta > 0 ? '+' : ''}{(item.delta / 1000).toFixed(1)}k
                              </td>
                              <td className={`text-right py-1 px-1 font-mono font-semibold ${item.cumDelta > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                {(item.cumDelta / 1000).toFixed(1)}k
                              </td>
                              {useMultiExchange && (
                                <>
                                  <td className="text-center py-1 px-1 text-gray-300">
                                    {item.exchanges || 0}
                                  </td>
                                  <td className="text-center py-1 px-1">
                                    <span className={`text-[10px] font-semibold ${
                                      (item.confidence || 0) >= 0.8 ? 'text-green-400' :
                                      (item.confidence || 0) >= 0.6 ? 'text-yellow-400' :
                                      'text-red-400'
                                    }`} title={`${((item.confidence || 0) * 100).toFixed(0)}% confidence`}>
                                      {((item.confidence || 0) * 100).toFixed(0)}%
                                    </span>
                                  </td>
                                </>
                              )}
                              <td className="text-center py-1 px-1">
                                {hasDivergence && <span className="text-yellow-400 text-xs" title="Exchange divergence">âš ï¸</span>}
                                {isBullishSpike && !hasDivergence && <span className="text-green-400 text-xs" title="Bullish delta spike (2x avg)">ðŸ”¥</span>}
                                {isBearishSpike && !hasDivergence && !isBullishSpike && <span className="text-red-400 text-xs" title="Bearish delta spike (2x avg)">ðŸ”¥</span>}
                              </td>
                            </tr>
                          );
                        })}
                        </>
                      )}
                    </tbody>
                    <tfoot className="sticky bottom-0 bg-slate-800 border-t border-slate-600">
                      <tr>
                        <td className="text-gray-400 py-1 px-1 text-[10px]">Avg</td>
                        <td className="text-right py-1 px-1 font-mono">
                          <div className="flex flex-col text-[10px]">
                            <span className="text-green-400">
                              {deltaHistory.filter(h => h.isBull).length > 0
                                ? (deltaHistory.filter(h => h.isBull).reduce((sum, h) => sum + h.delta, 0) / deltaHistory.filter(h => h.isBull).length / 1000).toFixed(1) + 'k'
                                : '-'}
                            </span>
                            <span className="text-red-400">
                              {deltaHistory.filter(h => !h.isBull).length > 0
                                ? (deltaHistory.filter(h => !h.isBull).reduce((sum, h) => sum + h.delta, 0) / deltaHistory.filter(h => !h.isBull).length / 1000).toFixed(1) + 'k'
                                : '-'}
                            </span>
                          </div>
                        </td>
                        <td colSpan={2}></td>
                      </tr>
                    </tfoot>
                  </table>
                </div>
              </CardContent>
            </Card>

            {/* Indicator Toggles */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader>
                <CardTitle className="text-white text-sm">Indicators</CardTitle>
              </CardHeader>
              <CardContent className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">FVGs</Label>
                  <Switch checked={showFVG} onCheckedChange={setShowFVG} />
                </div>
                {showFVG && (
                  <div className="ml-4 space-y-1 border-l-2 border-slate-600 pl-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">High Value Only</Label>
                      <Switch checked={showHighValueOnly} onCheckedChange={setShowHighValueOnly} />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Volume Threshold</Label>
                      <input
                        type="number"
                        min="1"
                        max="3"
                        step="0.1"
                        value={fvgVolumeThreshold}
                        onChange={(e) => setFvgVolumeThreshold(parseFloat(e.target.value))}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                  </div>
                )}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">BOS</Label>
                  <Switch checked={showBOS} onCheckedChange={setShowBOS} />
                </div>
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">CHoCH</Label>
                  <Switch checked={showCHoCH} onCheckedChange={setShowCHoCH} />
                </div>
                
                {/* Swing Pivots */}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">Swing Pivots</Label>
                  <Switch checked={showSwingPivots} onCheckedChange={setShowSwingPivots} />
                </div>
                {showSwingPivots && (
                  <div className="ml-4 space-y-2 border-l-2 border-slate-600 pl-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Swing Length</Label>
                      <input
                        type="number"
                        min="1"
                        max="50"
                        value={swingPivotLengthInput}
                        onChange={(e) => {
                          setSwingPivotLengthInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 1 && val <= 50) {
                            setSwingPivotLength(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                  </div>
                )}
                
                {/* Liquidity Sweeps */}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">Liquidity Sweeps</Label>
                  <Switch checked={stratLiquidityGrab} onCheckedChange={setStratLiquidityGrab} />
                </div>
                {stratLiquidityGrab && (
                  <div className="ml-4 space-y-2 border-l-2 border-slate-600 pl-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Swing Length</Label>
                      <input
                        type="number"
                        min="5"
                        max="50"
                        value={chartLiquiditySweepSwingLengthInput}
                        onChange={(e) => setChartLiquiditySweepSwingLengthInput(e.target.value)}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                  </div>
                )}
                
                {/* Show Chart Labels */}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">Chart Labels</Label>
                  <Switch checked={showChartLabels} onCheckedChange={setShowChartLabels} />
                </div>
                
                {/* Auto Trendlines */}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">Auto Trendlines</Label>
                  <Switch checked={showAutoTrendlines} onCheckedChange={setShowAutoTrendlines} />
                </div>
                {showAutoTrendlines && (
                  <div className="ml-4 space-y-2 border-l-2 border-slate-600 pl-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Min Touches</Label>
                      <input
                        type="number"
                        min="3"
                        max="5"
                        value={trendlineMinTouchesInput}
                        onChange={(e) => {
                          setTrendlineMinTouchesInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 3 && val <= 5) {
                            setTrendlineMinTouches(val);
                          }
                        }}
                        className="w-20 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Tolerance (%)</Label>
                      <input
                        type="number"
                        min="0.1"
                        max="1.0"
                        step="0.1"
                        value={trendlineToleranceInput}
                        onChange={(e) => {
                          setTrendlineToleranceInput(e.target.value);
                          const val = parseFloat(e.target.value) / 100;
                          if (!isNaN(val) && val >= 0.001 && val <= 0.01) {
                            setTrendlineTolerance(val);
                          }
                        }}
                        className="w-20 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Pivot Length</Label>
                      <input
                        type="number"
                        min="5"
                        max="20"
                        value={trendlinePivotLengthInput}
                        onChange={(e) => {
                          setTrendlinePivotLengthInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 5 && val <= 20) {
                            setTrendlinePivotLength(val);
                          }
                        }}
                        className="w-20 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                  </div>
                )}
                
                {/* EMA Settings */}
                <div className="flex items-center justify-between">
                  <Label className="text-gray-300 text-sm">EMA</Label>
                  <Switch checked={showEMA} onCheckedChange={setShowEMA} />
                </div>
                {showEMA && (
                  <div className="ml-4 space-y-2 border-l-2 border-slate-600 pl-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Fast Period</Label>
                      <input
                        type="number"
                        min="5"
                        max="100"
                        value={emaFastInput}
                        onChange={(e) => {
                          setEmaFastInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 5 && val <= 100) {
                            setEmaFastPeriod(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Slow Period</Label>
                      <input
                        type="number"
                        min="5"
                        max="200"
                        value={emaSlowInput}
                        onChange={(e) => {
                          setEmaSlowInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 5 && val <= 200) {
                            setEmaSlowPeriod(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                  </div>
                )}
                
                <div className="pt-2 border-t border-slate-700">
                  <Label className="text-gray-300 text-xs font-semibold">Chart Display Settings</Label>
                  <p className="text-gray-500 text-[10px] mt-1">Controls what you see on the chart (independent from strategy settings)</p>
                  <div className="mt-2 space-y-2">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">BOS Swing Length</Label>
                      <input
                        type="number"
                        min="5"
                        max="30"
                        value={chartBosSwingLengthInput}
                        onChange={(e) => {
                          setChartBosSwingLengthInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 5 && val <= 30) {
                            setChartBosSwingLength(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">CHoCH Swing Length</Label>
                      <input
                        type="number"
                        min="5"
                        max="30"
                        value={chartChochSwingLengthInput}
                        onChange={(e) => {
                          setChartChochSwingLengthInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 5 && val <= 30) {
                            setChartChochSwingLength(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Confirm Candles</Label>
                      <input
                        type="number"
                        min="1"
                        max="5"
                        value={chartConfirmCandlesInput}
                        onChange={(e) => {
                          setChartConfirmCandlesInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 1 && val <= 5) {
                            setChartConfirmCandles(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Wick/Body Ratio (%)</Label>
                      <input
                        type="number"
                        min="50"
                        max="500"
                        step="10"
                        value={chartWickRatioInput}
                        onChange={(e) => {
                          setChartWickRatioInput(e.target.value);
                          const val = parseInt(e.target.value);
                          if (!isNaN(val) && val >= 50 && val <= 500) {
                            setChartWickRatio(val);
                          }
                        }}
                        className="w-14 bg-slate-700 text-white text-xs px-2 py-1 rounded border border-slate-600"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Use Wick Filter</Label>
                      <Switch checked={chartUseWickFilter} onCheckedChange={setChartUseWickFilter} />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Use Confirm Candles</Label>
                      <Switch checked={chartUseConfirmCandles} onCheckedChange={setChartUseConfirmCandles} />
                    </div>
                  </div>
                </div>
                <div className="pt-2 border-t border-slate-700">
                  <Label className="text-gray-300 text-xs font-semibold">VWAPs</Label>
                  <div className="mt-2 space-y-1">
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Daily</Label>
                      <Switch checked={showVWAPDaily} onCheckedChange={setShowVWAPDaily} />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Weekly</Label>
                      <Switch checked={showVWAPWeekly} onCheckedChange={setShowVWAPWeekly} />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">Monthly</Label>
                      <Switch checked={showVWAPMonthly} onCheckedChange={setShowVWAPMonthly} />
                    </div>
                    <div className="flex items-center justify-between">
                      <Label className="text-gray-400 text-xs">rVWAP(20)</Label>
                      <Switch checked={showVWAPRolling20} onCheckedChange={setShowVWAPRolling20} />
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Unlock AI Analysis CTA */}
        <Card className="bg-gradient-to-r from-purple-900/20 to-blue-900/20 border-purple-500/30 p-8 text-center">
          <div className="max-w-2xl mx-auto space-y-4">
            <h2 className="text-3xl font-bold text-white">Unlock AI-Powered Trade Analysis</h2>
            <p className="text-gray-300 text-lg">
              Upgrade to Tier 2 for instant trade alerts powered by Grok AI. Get real-time confluence analysis, 
              push notifications, and custom alert preferences.
            </p>
                        min="5"
                        max="20"
                        value={liqGrabSwingLengthInput}
                        onChange={(e) => setLiqGrabSwingLengthInput(e.target.value)}
                        className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                      />
                    </div>
                    <div>
                      <Label className="text-xs text-gray-400">Confirm Candles</Label>
                      <input
                        type="number"
                        min="1"
                        max="5"
                        value={liqGrabConfirmCandlesInput}
                        onChange={(e) => setLiqGrabConfirmCandlesInput(e.target.value)}
                        className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                      />
                    </div>
                    <div>
                      <Label className="text-xs text-gray-400">Wick Ratio %</Label>
                      <input
                        type="number"
                        min="50"
                        max="500"
                        step="10"
                        value={liqGrabWickRatioInput}
                        onChange={(e) => setLiqGrabWickRatioInput(e.target.value)}
                        className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                      />
                    </div>
                  </div>
                  <div className="flex items-center justify-between">
                    <Label className="text-xs text-gray-400">Use Wick Filter</Label>
                    <Switch checked={liqGrabUseWickFilter} onCheckedChange={setLiqGrabUseWickFilter} />
                  </div>
                  <div className="flex items-center justify-between">
                    <Label className="text-xs text-gray-400">Use Confirm Candles</Label>
                    <Switch checked={liqGrabUseConfirmCandles} onCheckedChange={setLiqGrabUseConfirmCandles} />
                  </div>
                  
                  {/* TP/SL Configuration */}
                  <div className="border-t border-slate-700 pt-3 space-y-3">
                    <Label className="text-white text-sm font-semibold">Take Profit & Stop Loss</Label>
                    
                    {/* Number of TPs */}
                    <div>
                      <Label className="text-xs text-gray-400">Number of Take Profits</Label>
                      <Select value={liqGrabTPSL.numTPs.toString()} onValueChange={(v) => setLiqGrabTPSL({...liqGrabTPSL, numTPs: parseInt(v) as 1 | 2 | 3})}>
                        <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="1">1 TP</SelectItem>
                          <SelectItem value="2">2 TPs</SelectItem>
                          <SelectItem value="3">3 TPs</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    
                    {/* TP1 Configuration */}
                    <div className="bg-slate-900/30 p-2 rounded space-y-2">
                      <Label className="text-xs text-green-400 font-semibold">TP1</Label>
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <Label className="text-xs text-gray-400">Type</Label>
                          <Select value={liqGrabTPSL.tp1.type} onValueChange={(v: TPType) => setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, type: v}})}>
                            <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="structure">Structure</SelectItem>
                              <SelectItem value="trailing">Trailing</SelectItem>
                              <SelectItem value="ema">EMA Exit</SelectItem>
                              <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>
                        <div>
                          <Label className="text-xs text-gray-400">Position %</Label>
                          <input
                            type="number"
                            min="1"
                            max="100"
                            value={liqGrabTPSL.tp1.positionPercent}
                            onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      </div>
                      {/* Conditional inputs for TP1 */}
                      {liqGrabTPSL.tp1.type === 'fixed_rr' && (
                        <div>
                          <Label className="text-xs text-gray-400">R:R Ratio</Label>
                          <input
                            type="number"
                            min="0.5"
                            max="10"
                            step="0.1"
                            value={liqGrabTPSL.tp1.fixedRR ?? ""}
                            onChange={(e) => {
                              const val = e.target.value === '' ? undefined : parseFloat(e.target.value);
                              setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, fixedRR: val}});
                            }}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {liqGrabTPSL.tp1.type === 'structure' && (
                        <div>
                          <Label className="text-xs text-gray-400">TP Swing Length</Label>
                          <input
                            type="number"
                            min="5"
                            max="50"
                            value={liqGrabTPSwingLengthInput}
                            onChange={(e) => setLiqGrabTPSwingLengthInput(e.target.value)}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {liqGrabTPSL.tp1.type === 'ema' && (
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <Label className="text-xs text-gray-400">Fast EMA</Label>
                            <input
                              type="number"
                              min="5"
                              max="200"
                              value={liqGrabTPSL.tp1.emaFast ?? 20}
                              onChange={(e) => {
                                const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, emaFast: val}});
                              }}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                          <div>
                            <Label className="text-xs text-gray-400">Slow EMA</Label>
                            <input
                              type="number"
                              min="20"
                              max="500"
                              value={liqGrabTPSL.tp1.emaSlow ?? 200}
                              onChange={(e) => {
                                const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, emaSlow: val}});
                              }}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        </div>
                      )}
                      {liqGrabTPSL.tp1.type === 'trailing' && (
                        <div>
                          <Label className="text-xs text-gray-400">Trailing Swing Length</Label>
                          <input
                            type="number"
                            min="1"
                            max="50"
                            value={liqGrabTPSwingLengthInput}
                            onChange={(e) => {
                              const val = e.target.value;
                              setLiqGrabTPSwingLengthInput(val);
                              const numVal = parseInt(val);
                              if (!isNaN(numVal) && numVal >= 1 && numVal <= 50) {
                                setLiqGrabTPSwingLength(numVal);
                                setLiqGrabTPSL({...liqGrabTPSL, tp1: {...liqGrabTPSL.tp1, trailingSwingLength: numVal}});
                              }
                            }}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                    </div>
                    
                    {/* TP2 Configuration - Only if numTPs >= 2 */}
                    {liqGrabTPSL.numTPs >= 2 && (
                      <div className="bg-slate-900/30 p-2 rounded space-y-2">
                        <Label className="text-xs text-green-400 font-semibold">TP2</Label>
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <Label className="text-xs text-gray-400">Type</Label>
                            <Select value={liqGrabTPSL.tp2?.type || 'structure'} onValueChange={(v: TPType) => setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {positionPercent: 30}), type: v}})}>
                              <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="structure">Structure</SelectItem>
                                <SelectItem value="trailing">Trailing</SelectItem>
                                <SelectItem value="ema">EMA Exit</SelectItem>
                                <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                              </SelectContent>
                            </Select>
                          </div>
                          <div>
                            <Label className="text-xs text-gray-400">Position %</Label>
                            <input
                              type="number"
                              min="1"
                              max="100"
                              value={liqGrabTPSL.tp2?.positionPercent ?? ""}
                              onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {type: 'structure'}), positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        </div>
                        {/* Conditional inputs for TP2 - similar pattern */}
                        {liqGrabTPSL.tp2?.type === 'fixed_rr' && (
                          <div>
                            <Label className="text-xs text-gray-400">R:R Ratio</Label>
                            <input
                              type="number"
                              min="0.5"
                              max="10"
                              step="0.1"
                              value={liqGrabTPSL.tp2?.fixedRR ?? ""}
                              onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {type: 'fixed_rr', positionPercent: 30}), fixedRR: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {liqGrabTPSL.tp2?.type === 'structure' && (
                          <div>
                            <Label className="text-xs text-gray-400">TP Swing Length</Label>
                            <input
                              type="number"
                              min="5"
                              max="50"
                              value={liqGrabTPSwingLengthInput}
                              onChange={(e) => setLiqGrabTPSwingLengthInput(e.target.value)}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {liqGrabTPSL.tp2?.type === 'ema' && (
                          <div className="grid grid-cols-2 gap-2">
                            <div>
                              <Label className="text-xs text-gray-400">Fast EMA</Label>
                              <input
                                type="number"
                                min="5"
                                max="200"
                                value={liqGrabTPSL.tp2?.emaFast ?? 20}
                                onChange={(e) => {
                                  const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                  setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {type: 'ema', positionPercent: 30}), emaFast: val}});
                                }}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                            <div>
                              <Label className="text-xs text-gray-400">Slow EMA</Label>
                              <input
                                type="number"
                                min="20"
                                max="500"
                                value={liqGrabTPSL.tp2?.emaSlow ?? 200}
                                onChange={(e) => {
                                  const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                  setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {type: 'ema', positionPercent: 30}), emaSlow: val}});
                                }}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                          </div>
                        )}
                        {liqGrabTPSL.tp2?.type === 'trailing' && (
                          <div>
                            <Label className="text-xs text-gray-400">Trailing Swing Length</Label>
                            <input
                              type="number"
                              min="1"
                              max="50"
                              value={liqGrabTPSL.tp2?.trailingSwingLength ?? ''}
                              onChange={(e) => {
                                const val = e.target.value;
                                const numVal = val === '' ? undefined : parseInt(val);
                                if (val === '' || (!isNaN(numVal!) && numVal! >= 1 && numVal! <= 50)) {
                                  setLiqGrabTPSL({...liqGrabTPSL, tp2: {...(liqGrabTPSL.tp2 || {type: 'trailing', positionPercent: 30}), trailingSwingLength: numVal}});
                                }
                              }}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* TP3 Configuration - Only if numTPs === 3 */}
                    {liqGrabTPSL.numTPs === 3 && (
                      <div className="bg-slate-900/30 p-2 rounded space-y-2">
                        <Label className="text-xs text-green-400 font-semibold">TP3</Label>
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <Label className="text-xs text-gray-400">Type</Label>
                            <Select value={liqGrabTPSL.tp3?.type || 'structure'} onValueChange={(v: TPType) => setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {positionPercent: 20}), type: v}})}>
                              <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="structure">Structure</SelectItem>
                                <SelectItem value="trailing">Trailing</SelectItem>
                                <SelectItem value="ema">EMA Exit</SelectItem>
                                <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                              </SelectContent>
                            </Select>
                          </div>
                          <div>
                            <Label className="text-xs text-gray-400">Position %</Label>
                            <input
                              type="number"
                              min="1"
                              max="100"
                              value={liqGrabTPSL.tp3?.positionPercent ?? ""}
                              onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {type: 'atr', positionPercent: 20}), positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        </div>
                        {/* Conditional inputs for TP3 */}
                        {liqGrabTPSL.tp3?.type === 'structure' && (
                          <div>
                            <Label className="text-xs text-gray-400">TP Swing Length</Label>
                            <input
                              type="number"
                              min="5"
                              max="50"
                              value={liqGrabTPSwingLengthInput}
                              onChange={(e) => setLiqGrabTPSwingLengthInput(e.target.value)}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {liqGrabTPSL.tp3?.type === 'trailing' && (
                          <div>
                            <Label className="text-xs text-gray-400">Trailing Swing Length</Label>
                            <input
                              type="number"
                              min="1"
                              max="50"
                              value={liqGrabTPSL.tp3?.trailingSwingLength ?? ''}
                              onChange={(e) => {
                                const val = e.target.value;
                                const numVal = val === '' ? undefined : parseInt(val);
                                if (val === '' || (!isNaN(numVal!) && numVal! >= 1 && numVal! <= 50)) {
                                  setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {type: 'trailing', positionPercent: 20}), trailingSwingLength: numVal}});
                                }
                              }}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {liqGrabTPSL.tp3?.type === 'ema' && (
                          <div className="grid grid-cols-2 gap-2">
                            <div>
                              <Label className="text-xs text-gray-400">Fast EMA</Label>
                              <input
                                type="number"
                                min="5"
                                max="200"
                                value={liqGrabTPSL.tp3?.emaFast ?? 20}
                                onChange={(e) => {
                                  const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                  setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {type: 'ema', positionPercent: 20}), emaFast: val}});
                                }}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                            <div>
                              <Label className="text-xs text-gray-400">Slow EMA</Label>
                              <input
                                type="number"
                                min="20"
                                max="500"
                                value={liqGrabTPSL.tp3?.emaSlow ?? 200}
                                onChange={(e) => {
                                  const val = e.target.value === '' ? undefined : parseInt(e.target.value);
                                  setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {type: 'ema', positionPercent: 20}), emaSlow: val}});
                                }}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                          </div>
                        )}
                        {liqGrabTPSL.tp3?.type === 'fixed_rr' && (
                          <div>
                            <Label className="text-xs text-gray-400">R:R Ratio</Label>
                            <input
                              type="number"
                              min="0.5"
                              max="10"
                              step="0.1"
                              value={liqGrabTPSL.tp3?.fixedRR ?? ""}
                              onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, tp3: {...(liqGrabTPSL.tp3 || {type: 'fixed_rr', positionPercent: 20}), fixedRR: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* Stop Loss Configuration */}
                    <div className="bg-red-900/10 p-2 rounded space-y-2 border border-red-900/30">
                      <Label className="text-xs text-red-400 font-semibold">Stop Loss</Label>
                      <div>
                        <Label className="text-xs text-gray-400">Type</Label>
                        <Select value={liqGrabTPSL.sl.type} onValueChange={(v: SLType) => setLiqGrabTPSL({...liqGrabTPSL, sl: {...liqGrabTPSL.sl, type: v}})}>
                          <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="atr">ATR</SelectItem>
                            <SelectItem value="structure">Structure (Swing)</SelectItem>
                            <SelectItem value="fixed">Fixed Distance</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      {/* Conditional inputs for SL */}
                      {liqGrabTPSL.sl.type === 'atr' && (
                        <div>
                          <Label className="text-xs text-gray-400">ATR Multiplier</Label>
                          <input
                            type="number"
                            min="0.5"
                            max="5"
                            step="0.1"
                            value={liqGrabTPSL.sl.atrMultiplier ?? ""}
                            onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, sl: {...liqGrabTPSL.sl, atrMultiplier: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {liqGrabTPSL.sl.type === 'structure' && (
                        <div>
                          <Label className="text-xs text-gray-400">SL Swing Length</Label>
                          <input
                            type="number"
                            min="1"
                            max="30"
                            value={liqGrabSLSwingLengthInput}
                            onChange={(e) => {
                              const val = e.target.value;
                              setLiqGrabSLSwingLengthInput(val);
                              const numVal = parseInt(val);
                              if (!isNaN(numVal) && numVal >= 1 && numVal <= 30) {
                                setLiqGrabSLSwingLength(numVal);
                                setLiqGrabTPSL({...liqGrabTPSL, sl: {...liqGrabTPSL.sl, swingLength: numVal}});
                              }
                            }}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {liqGrabTPSL.sl.type === 'fixed' && (
                        <div>
                          <Label className="text-xs text-gray-400">Fixed Distance (%)</Label>
                          <input
                            type="number"
                            min="0.1"
                            max="10"
                            step="0.1"
                            value={liqGrabTPSL.sl.fixedDistance ?? ""}
                            onChange={(e) => setLiqGrabTPSL({...liqGrabTPSL, sl: {...liqGrabTPSL.sl, fixedDistance: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                    </div>
                  </div>

                  {/* SAVE AS DEFAULT BUTTON */}
                  <div className="pt-2">
                    <Button
                      onClick={saveAsDefault}
                      className="w-full h-8 bg-green-600 hover:bg-green-700 text-white font-semibold"
                      data-testid="button-save-default"
                    >
                      ðŸ’¾ Save as Default
                    </Button>
                  </div>

                  {/* AUTO-BACKTEST MODE */}
                  <div className="border-t border-slate-700 pt-3 mt-3">
                    <div className="flex items-center justify-between mb-3">
                      <Label className="text-white text-sm font-semibold">ðŸ§ª Auto-Backtest Mode</Label>
                      <Switch 
                        checked={liqGrabAutoTestMode} 
                        onCheckedChange={setLiqGrabAutoTestMode}
                        data-testid="toggle-auto-backtest-mode"
                      />
                    </div>

                    {liqGrabAutoTestMode && (
                      <div className="space-y-3">
                        <p className="text-xs text-gray-400 mb-3">Configure which parameters to test and their ranges:</p>
                        
                        {/* STRATEGY PARAMETERS SECTION */}
                        <div className="bg-blue-900/10 p-3 rounded border border-blue-900/30 space-y-3">
                          <Label className="text-sm text-blue-400 font-semibold">Strategy Parameters</Label>
                          
                          {/* Trend Filters */}
                          <div>
                            <Label className="text-xs text-gray-400 mb-1 block">Trend Filters to Test</Label>
                            <div className="grid grid-cols-2 gap-2">
                              {(['ema', 'structure', 'both', 'none'] as const).map(filter => (
                                <label key={filter} className="flex items-center gap-2">
                                  <input 
                                    type="checkbox" 
                                    checked={testTrendFilters.includes(filter)}
                                    onChange={(e) => {
                                      if (e.target.checked) {
                                        setTestTrendFilters([...testTrendFilters, filter]);
                                      } else {
                                        setTestTrendFilters(testTrendFilters.filter(f => f !== filter));
                                      }
                                    }}
                                    className="w-4 h-4"
                                  />
                                  <span className="text-xs text-white capitalize">{filter}</span>
                                </label>
                              ))}
                            </div>
                          </div>

                          {/* Directions */}
                          <div>
                            <Label className="text-xs text-gray-400 mb-1 block">Directions to Test</Label>
                            <div className="grid grid-cols-3 gap-2">
                              {(['bull', 'bear', 'both'] as const).map(dir => (
                                <label key={dir} className="flex items-center gap-2">
                                  <input 
                                    type="checkbox" 
                                    checked={testDirections.includes(dir)}
                                    onChange={(e) => {
                                      if (e.target.checked) {
                                        setTestDirections([...testDirections, dir]);
                                      } else {
                                        setTestDirections(testDirections.filter(d => d !== dir));
                                      }
                                    }}
                                    className="w-4 h-4"
                                  />
                                  <span className="text-xs text-white capitalize">{dir === 'bull' ? 'Longs' : dir === 'bear' ? 'Shorts' : 'Both'}</span>
                                </label>
                              ))}
                            </div>
                          </div>

                          {/* Swing Length Range */}
                          <div>
                            <Label className="text-xs text-gray-400 mb-1 block">Swing Length</Label>
                            <div className="grid grid-cols-3 gap-2">
                              <div>
                                <input
                                  type="number"
                                  placeholder="Min"
                                  value={swingLengthRange.min}
                                  onChange={(e) => setSwingLengthRange({...swingLengthRange, min: parseInt(e.target.value)})}
                                  className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                                />
                              </div>
                              <div>
                                <input
                                  type="number"
                                  placeholder="Max"
                                  value={swingLengthRange.max}
                                  onChange={(e) => setSwingLengthRange({...swingLengthRange, max: parseInt(e.target.value)})}
                                  className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                                />
                              </div>
                              <div>
                                <input
                                  type="number"
                                  placeholder="Step"
                                  value={swingLengthRange.step}
                                  onChange={(e) => setSwingLengthRange({...swingLengthRange, step: parseInt(e.target.value)})}
                                  className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                                />
                              </div>
                            </div>
                          </div>

                          {/* Wick Ratio Range */}
                          <div>
                            <Label className="text-xs text-gray-400 mb-1 block">Wick Ratio %</Label>
                            <div className="grid grid-cols-3 gap-2">
                              <input
                                type="number"
                                placeholder="Min"
                                value={wickRatioRange.min}
                                onChange={(e) => setWickRatioRange({...wickRatioRange, min: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                              <input
                                type="number"
                                placeholder="Max"
                                value={wickRatioRange.max}
                                onChange={(e) => setWickRatioRange({...wickRatioRange, max: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                              <input
                                type="number"
                                placeholder="Step"
                                value={wickRatioRange.step}
                                onChange={(e) => setWickRatioRange({...wickRatioRange, step: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                          </div>

                          {/* Confirm Candles Range */}
                          <div>
                            <Label className="text-xs text-gray-400 mb-1 block">Confirmation Candles</Label>
                            <div className="grid grid-cols-3 gap-2">
                              <input
                                type="number"
                                placeholder="Min"
                                value={confirmCandlesRange.min}
                                onChange={(e) => setConfirmCandlesRange({...confirmCandlesRange, min: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                              <input
                                type="number"
                                placeholder="Max"
                                value={confirmCandlesRange.max}
                                onChange={(e) => setConfirmCandlesRange({...confirmCandlesRange, max: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                              <input
                                type="number"
                                placeholder="Step"
                                value={confirmCandlesRange.step}
                                onChange={(e) => setConfirmCandlesRange({...confirmCandlesRange, step: parseInt(e.target.value)})}
                                className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                              />
                            </div>
                          </div>

                          {/* Filter Toggles */}
                          <div className="grid grid-cols-2 gap-2">
                            <label className="flex items-center gap-2">
                              <input 
                                type="checkbox" 
                                checked={testUseWickFilter}
                                onChange={(e) => setTestUseWickFilter(e.target.checked)}
                                className="w-4 h-4"
                              />
                              <span className="text-xs text-white">Use Wick Filter</span>
                            </label>
                            <label className="flex items-center gap-2">
                              <input 
                                type="checkbox" 
                                checked={testUseConfirmCandles}
                                onChange={(e) => setTestUseConfirmCandles(e.target.checked)}
                                className="w-4 h-4"
                              />
                              <span className="text-xs text-white">Use Confirm Candles</span>
                            </label>
                          </div>
                        </div>

                        {/* TP/SL PARAMETERS SECTION */}
                        <div className="bg-green-900/10 p-3 rounded border border-green-900/30 space-y-3">
                          <Label className="text-sm text-green-400 font-semibold">TP/SL Parameters</Label>
                          
                          {/* Only show TP1 if numTPs >= 1 */}
                          {liqGrabTPSL.numTPs >= 1 && (
                            <div className="bg-slate-900/30 p-2 rounded space-y-2">
                              <Label className="text-xs text-green-400 font-semibold">TP1 Options</Label>
                              <div className="grid grid-cols-2 gap-2 mb-2">
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP1Structure} onChange={(e) => setTestTP1Structure(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Structure</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP1Trailing} onChange={(e) => setTestTP1Trailing(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Trailing</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP1EMA} onChange={(e) => setTestTP1EMA(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">EMA</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP1FixedRR} onChange={(e) => setTestTP1FixedRR(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Fixed R:R</span>
                                </label>
                              </div>
                              {testTP1Trailing && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Trailing Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp1TrailingSwingRange.min} onChange={(e) => setTp1TrailingSwingRange({...tp1TrailingSwingRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp1TrailingSwingRange.max} onChange={(e) => setTp1TrailingSwingRange({...tp1TrailingSwingRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp1TrailingSwingRange.step} onChange={(e) => setTp1TrailingSwingRange({...tp1TrailingSwingRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP1EMA && (
                                <div className="space-y-2">
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Fast Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp1EMAFastRange.min} onChange={(e) => setTp1EMAFastRange({...tp1EMAFastRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp1EMAFastRange.max} onChange={(e) => setTp1EMAFastRange({...tp1EMAFastRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp1EMAFastRange.step} onChange={(e) => setTp1EMAFastRange({...tp1EMAFastRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Slow Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp1EMASlowRange.min} onChange={(e) => setTp1EMASlowRange({...tp1EMASlowRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp1EMASlowRange.max} onChange={(e) => setTp1EMASlowRange({...tp1EMASlowRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp1EMASlowRange.step} onChange={(e) => setTp1EMASlowRange({...tp1EMASlowRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                </div>
                              )}
                              {testTP1FixedRR && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">R:R Ratio Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" step="0.1" placeholder="Min" value={tp1RRRange.min} onChange={(e) => setTp1RRRange({...tp1RRRange, min: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Max" value={tp1RRRange.max} onChange={(e) => setTp1RRRange({...tp1RRRange, max: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Step" value={tp1RRRange.step} onChange={(e) => setTp1RRRange({...tp1RRRange, step: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP1Structure && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp1SwingLengthRange.min} onChange={(e) => setTp1SwingLengthRange({...tp1SwingLengthRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp1SwingLengthRange.max} onChange={(e) => setTp1SwingLengthRange({...tp1SwingLengthRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp1SwingLengthRange.step} onChange={(e) => setTp1SwingLengthRange({...tp1SwingLengthRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                            </div>
                          )}

                          {/* Only show TP2 if numTPs >= 2 */}
                          {liqGrabTPSL.numTPs >= 2 && (
                            <div className="bg-slate-900/30 p-2 rounded space-y-2">
                              <Label className="text-xs text-green-400 font-semibold">TP2 Options</Label>
                              <div className="grid grid-cols-2 gap-2 mb-2">
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP2Structure} onChange={(e) => setTestTP2Structure(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Structure</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP2Trailing} onChange={(e) => setTestTP2Trailing(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Trailing</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP2EMA} onChange={(e) => setTestTP2EMA(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">EMA</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP2FixedRR} onChange={(e) => setTestTP2FixedRR(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Fixed R:R</span>
                                </label>
                              </div>
                              {testTP2Trailing && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Trailing Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp2TrailingSwingRange.min} onChange={(e) => setTp2TrailingSwingRange({...tp2TrailingSwingRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp2TrailingSwingRange.max} onChange={(e) => setTp2TrailingSwingRange({...tp2TrailingSwingRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp2TrailingSwingRange.step} onChange={(e) => setTp2TrailingSwingRange({...tp2TrailingSwingRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP2EMA && (
                                <div className="space-y-2">
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Fast Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp2EMAFastRange.min} onChange={(e) => setTp2EMAFastRange({...tp2EMAFastRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp2EMAFastRange.max} onChange={(e) => setTp2EMAFastRange({...tp2EMAFastRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp2EMAFastRange.step} onChange={(e) => setTp2EMAFastRange({...tp2EMAFastRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Slow Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp2EMASlowRange.min} onChange={(e) => setTp2EMASlowRange({...tp2EMASlowRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp2EMASlowRange.max} onChange={(e) => setTp2EMASlowRange({...tp2EMASlowRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp2EMASlowRange.step} onChange={(e) => setTp2EMASlowRange({...tp2EMASlowRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                </div>
                              )}
                              {testTP2FixedRR && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">R:R Ratio Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" step="0.1" placeholder="Min" value={tp2RRRange.min} onChange={(e) => setTp2RRRange({...tp2RRRange, min: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Max" value={tp2RRRange.max} onChange={(e) => setTp2RRRange({...tp2RRRange, max: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Step" value={tp2RRRange.step} onChange={(e) => setTp2RRRange({...tp2RRRange, step: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP2Structure && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp2SwingLengthRange.min} onChange={(e) => setTp2SwingLengthRange({...tp2SwingLengthRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp2SwingLengthRange.max} onChange={(e) => setTp2SwingLengthRange({...tp2SwingLengthRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp2SwingLengthRange.step} onChange={(e) => setTp2SwingLengthRange({...tp2SwingLengthRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                            </div>
                          )}

                          {/* Only show TP3 if numTPs >= 3 */}
                          {liqGrabTPSL.numTPs >= 3 && (
                            <div className="bg-slate-900/30 p-2 rounded space-y-2">
                              <Label className="text-xs text-green-400 font-semibold">TP3 Options</Label>
                              <div className="grid grid-cols-2 gap-2 mb-2">
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP3Structure} onChange={(e) => setTestTP3Structure(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Structure</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP3Trailing} onChange={(e) => setTestTP3Trailing(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Trailing</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP3EMA} onChange={(e) => setTestTP3EMA(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">EMA</span>
                                </label>
                                <label className="flex items-center gap-2">
                                  <input type="checkbox" checked={testTP3FixedRR} onChange={(e) => setTestTP3FixedRR(e.target.checked)} className="w-4 h-4" />
                                  <span className="text-xs text-white">Fixed R:R</span>
                                </label>
                              </div>
                              {testTP3Trailing && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Trailing Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp3TrailingSwingRange.min} onChange={(e) => setTp3TrailingSwingRange({...tp3TrailingSwingRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp3TrailingSwingRange.max} onChange={(e) => setTp3TrailingSwingRange({...tp3TrailingSwingRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp3TrailingSwingRange.step} onChange={(e) => setTp3TrailingSwingRange({...tp3TrailingSwingRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP3EMA && (
                                <div className="space-y-2">
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Fast Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp3EMAFastRange.min} onChange={(e) => setTp3EMAFastRange({...tp3EMAFastRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp3EMAFastRange.max} onChange={(e) => setTp3EMAFastRange({...tp3EMAFastRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp3EMAFastRange.step} onChange={(e) => setTp3EMAFastRange({...tp3EMAFastRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                  <div>
                                    <Label className="text-xs text-gray-400 mb-1 block">EMA Slow Range</Label>
                                    <div className="grid grid-cols-3 gap-2">
                                      <input type="number" placeholder="Min" value={tp3EMASlowRange.min} onChange={(e) => setTp3EMASlowRange({...tp3EMASlowRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Max" value={tp3EMASlowRange.max} onChange={(e) => setTp3EMASlowRange({...tp3EMASlowRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                      <input type="number" placeholder="Step" value={tp3EMASlowRange.step} onChange={(e) => setTp3EMASlowRange({...tp3EMASlowRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    </div>
                                  </div>
                                </div>
                              )}
                              {testTP3FixedRR && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">R:R Ratio Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" step="0.1" placeholder="Min" value={tp3RRRange.min} onChange={(e) => setTp3RRRange({...tp3RRRange, min: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Max" value={tp3RRRange.max} onChange={(e) => setTp3RRRange({...tp3RRRange, max: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" step="0.1" placeholder="Step" value={tp3RRRange.step} onChange={(e) => setTp3RRRange({...tp3RRRange, step: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                              {testTP3Structure && (
                                <div>
                                  <Label className="text-xs text-gray-400 mb-1 block">Swing Length Range</Label>
                                  <div className="grid grid-cols-3 gap-2">
                                    <input type="number" placeholder="Min" value={tp3SwingLengthRange.min} onChange={(e) => setTp3SwingLengthRange({...tp3SwingLengthRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Max" value={tp3SwingLengthRange.max} onChange={(e) => setTp3SwingLengthRange({...tp3SwingLengthRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                    <input type="number" placeholder="Step" value={tp3SwingLengthRange.step} onChange={(e) => setTp3SwingLengthRange({...tp3SwingLengthRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  </div>
                                </div>
                              )}
                            </div>
                          )}

                          {/* SL Options */}
                          <div className="bg-red-900/10 p-2 rounded border border-red-900/30 space-y-2">
                            <Label className="text-xs text-red-400 font-semibold">SL Options</Label>
                            <div className="grid grid-cols-3 gap-2 mb-2">
                              <label className="flex items-center gap-2">
                                <input type="checkbox" checked={testSLATR} onChange={(e) => setTestSLATR(e.target.checked)} className="w-4 h-4" />
                                <span className="text-xs text-white">ATR</span>
                              </label>
                              <label className="flex items-center gap-2">
                                <input type="checkbox" checked={testSLStructure} onChange={(e) => setTestSLStructure(e.target.checked)} className="w-4 h-4" />
                                <span className="text-xs text-white">Structure</span>
                              </label>
                              <label className="flex items-center gap-2">
                                <input type="checkbox" checked={testSLFixedDistance} onChange={(e) => setTestSLFixedDistance(e.target.checked)} className="w-4 h-4" />
                                <span className="text-xs text-white">Fixed %</span>
                              </label>
                            </div>
                            {testSLATR && (
                              <div>
                                <Label className="text-xs text-gray-400 mb-1 block">ATR Multiplier Range</Label>
                                <div className="grid grid-cols-3 gap-2">
                                  <input type="number" step="0.1" placeholder="Min" value={slATRRange.min} onChange={(e) => setSlATRRange({...slATRRange, min: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" step="0.1" placeholder="Max" value={slATRRange.max} onChange={(e) => setSlATRRange({...slATRRange, max: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" step="0.1" placeholder="Step" value={slATRRange.step} onChange={(e) => setSlATRRange({...slATRRange, step: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                </div>
                              </div>
                            )}
                            {testSLStructure && (
                              <div>
                                <Label className="text-xs text-gray-400 mb-1 block">Swing Length Range</Label>
                                <div className="grid grid-cols-3 gap-2">
                                  <input type="number" placeholder="Min" value={slSwingLengthRange.min} onChange={(e) => setSlSwingLengthRange({...slSwingLengthRange, min: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" placeholder="Max" value={slSwingLengthRange.max} onChange={(e) => setSlSwingLengthRange({...slSwingLengthRange, max: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" placeholder="Step" value={slSwingLengthRange.step} onChange={(e) => setSlSwingLengthRange({...slSwingLengthRange, step: parseInt(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                </div>
                              </div>
                            )}
                            {testSLFixedDistance && (
                              <div>
                                <Label className="text-xs text-gray-400 mb-1 block">Fixed Distance % Range</Label>
                                <div className="grid grid-cols-3 gap-2">
                                  <input type="number" step="0.1" placeholder="Min" value={slFixedDistanceRange.min} onChange={(e) => setSlFixedDistanceRange({...slFixedDistanceRange, min: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" step="0.1" placeholder="Max" value={slFixedDistanceRange.max} onChange={(e) => setSlFixedDistanceRange({...slFixedDistanceRange, max: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                  <input type="number" step="0.1" placeholder="Step" value={slFixedDistanceRange.step} onChange={(e) => setSlFixedDistanceRange({...slFixedDistanceRange, step: parseFloat(e.target.value)})} className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs" />
                                </div>
                              </div>
                            )}
                          </div>
                        </div>

                        {/* COMBINATION COUNTER */}
                        <div className="bg-purple-900/10 p-3 rounded border border-purple-900/30">
                          <div className="flex justify-between items-center">
                            <div>
                              <Label className="text-sm text-purple-400 font-semibold">Total Combinations</Label>
                              <p className="text-xs text-gray-400 mt-1">Estimated completion time: {estimatedTime}</p>
                            </div>
                            <div className="text-right">
                              <div className={`text-2xl font-bold ${totalCombinations > 1000 ? 'text-orange-400' : totalCombinations > 0 ? 'text-white' : 'text-gray-600'}`}>
                                {totalCombinations.toLocaleString()}
                              </div>
                              <p className="text-xs text-gray-400">tests</p>
                            </div>
                          </div>
                        </div>

                        {/* Run Auto-Backtest Button */}
                        <Button
                          onClick={runAutoBacktest}
                          disabled={liqGrabAutoTestRunning}
                          className="w-full bg-blue-600 hover:bg-blue-700 text-white"
                          data-testid="button-run-auto-backtest"
                        >
                          {liqGrabAutoTestRunning ? (
                            <>
                              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                              Testing... {liqGrabAutoTestProgress}%
                            </>
                          ) : (
                            'ðŸ§ª Run Auto-Backtest'
                          )}
                        </Button>

                        {/* Results Table */}
                        {liqGrabAutoTestResults.length > 0 && (
                          <div className="mt-4 border border-slate-700 rounded overflow-hidden">
                            <div className="bg-slate-900 p-2 border-b border-slate-700">
                              <h3 className="text-sm font-semibold text-white">
                                ðŸ“Š Top 10 Best Configurations ({liqGrabAutoTestResults.length} total tested)
                              </h3>
                            </div>
                            <div className="overflow-x-auto max-h-96">
                              <table className="w-full text-xs">
                                <thead className="bg-slate-800 sticky top-0">
                                  <tr>
                                    <th className="text-left p-2 text-gray-400">#</th>
                                    <th className="text-left p-2 text-gray-400">Configuration</th>
                                    <th 
                                      className={`text-right p-2 cursor-pointer hover:text-white ${liqGrabAutoTestSortBy === 'profit' ? 'text-green-400' : 'text-gray-400'}`}
                                      onClick={() => setLiqGrabAutoTestSortBy('profit')}
                                      data-testid="sort-profit"
                                    >
                                      Profit {liqGrabAutoTestSortBy === 'profit' && 'â–¼'}
                                    </th>
                                    <th 
                                      className={`text-right p-2 cursor-pointer hover:text-white ${liqGrabAutoTestSortBy === 'winRate' ? 'text-green-400' : 'text-gray-400'}`}
                                      onClick={() => setLiqGrabAutoTestSortBy('winRate')}
                                      data-testid="sort-winrate"
                                    >
                                      Win % {liqGrabAutoTestSortBy === 'winRate' && 'â–¼'}
                                    </th>
                                    <th 
                                      className={`text-right p-2 cursor-pointer hover:text-white ${liqGrabAutoTestSortBy === 'trades' ? 'text-green-400' : 'text-gray-400'}`}
                                      onClick={() => setLiqGrabAutoTestSortBy('trades')}
                                      data-testid="sort-trades"
                                    >
                                      Trades {liqGrabAutoTestSortBy === 'trades' && 'â–¼'}
                                    </th>
                                    <th 
                                      className={`text-right p-2 cursor-pointer hover:text-white ${liqGrabAutoTestSortBy === 'avgRR' ? 'text-green-400' : 'text-gray-400'}`}
                                      onClick={() => setLiqGrabAutoTestSortBy('avgRR')}
                                      data-testid="sort-avgrr"
                                    >
                                      Avg RR {liqGrabAutoTestSortBy === 'avgRR' && 'â–¼'}
                                    </th>
                                    <th className="text-center p-2 text-gray-400">Action</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {sortedAutoBacktestResults.slice(0, 10).map((result, idx) => (
                                    <tr 
                                      key={idx} 
                                      className={`border-b border-slate-800 hover:bg-slate-800/50 ${idx === 0 ? 'bg-green-900/20' : ''}`}
                                      data-testid={`result-row-${idx}`}
                                    >
                                      <td className="p-2 text-gray-300">{idx + 1}</td>
                                      <td className="p-2 text-gray-300 text-xs max-w-xs truncate" title={result.configDescription}>
                                        {result.configDescription}
                                      </td>
                                      <td className={`p-2 text-right font-semibold ${result.results.totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        ${result.results.totalPL.toFixed(2)}
                                      </td>
                                      <td className="p-2 text-right text-gray-300">
                                        {result.results.winRate.toFixed(1)}%
                                      </td>
                                      <td className="p-2 text-right text-gray-300">
                                        {result.results.totalTrades}
                                      </td>
                                      <td className="p-2 text-right text-gray-300">
                                        {result.results.avgRR.toFixed(2)}
                                      </td>
                                      <td className="p-2 text-center">
                                        <Button
                                          size="sm"
                                          onClick={() => applyAutoBacktestConfig(result)}
                                          className="h-6 px-2 text-xs bg-blue-600 hover:bg-blue-700"
                                          data-testid={`button-apply-config-${idx}`}
                                        >
                                          Apply
                                        </Button>
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </CardContent>
              )}
            </Card>

            {/* BOS STRUCTURE STRATEGY */}
            <Card className="bg-slate-800 border-slate-700">
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-white text-sm">ðŸ“ˆ BOS Trend Follow</CardTitle>
                  <Switch checked={stratBOSTrend} onCheckedChange={setStratBOSTrend} />
                </div>
              </CardHeader>
              {stratBOSTrend && (
                <CardContent className="space-y-2 pt-0 border-t border-slate-700">
                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <Label className="text-xs text-gray-400">Trend Filter</Label>
                      <Select value={bosTrendFilter} onValueChange={(v: 'ema' | 'structure' | 'both' | 'none') => setBosTrendFilter(v)}>
                        <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="ema">EMA</SelectItem>
                          <SelectItem value="structure">Structure</SelectItem>
                          <SelectItem value="both">Both</SelectItem>
                          <SelectItem value="none">None</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    <div>
                      <Label className="text-xs text-gray-400">Direction</Label>
                      <Select value={bosDirectionFilter} onValueChange={(v: 'bull' | 'bear' | 'both') => setBosDirectionFilter(v)}>
                        <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="bull">Longs</SelectItem>
                          <SelectItem value="bear">Shorts</SelectItem>
                          <SelectItem value="both">Both</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  <div>
                    <Label className="text-xs text-gray-400">Swing Length</Label>
                    <input
                      type="number"
                      min="5"
                      max="20"
                      value={bosSwingLengthInput}
                      onChange={(e) => setBosSwingLengthInput(e.target.value)}
                      className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                    />
                  </div>
                  
                  {/* TP/SL Configuration */}
                  <div className="border-t border-slate-700 pt-3 space-y-3 mt-3">
                    <Label className="text-white text-sm font-semibold">Take Profit & Stop Loss</Label>
                    
                    {/* Number of TPs */}
                    <div>
                      <Label className="text-xs text-gray-400">Number of Take Profits</Label>
                      <Select value={bosTPSL.numTPs.toString()} onValueChange={(v) => setBosTPSL({...bosTPSL, numTPs: parseInt(v) as 1 | 2 | 3})}>
                        <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="1">1 TP</SelectItem>
                          <SelectItem value="2">2 TPs</SelectItem>
                          <SelectItem value="3">3 TPs</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    
                    {/* TP1 Configuration */}
                    <div className="bg-slate-900/30 p-2 rounded space-y-2">
                      <Label className="text-xs text-green-400 font-semibold">TP1</Label>
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <Label className="text-xs text-gray-400">Type</Label>
                          <Select value={bosTPSL.tp1.type} onValueChange={(v: TPType) => setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, type: v}})}>
                            <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="atr">ATR</SelectItem>
                              <SelectItem value="structure">Structure</SelectItem>
                              <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                              <SelectItem value="vwap">VWAP Exit</SelectItem>
                              <SelectItem value="ema">EMA Exit</SelectItem>
                              <SelectItem value="trailing">Trailing</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>
                        <div>
                          <Label className="text-xs text-gray-400">Position %</Label>
                          <input
                            type="number"
                            min="1"
                            max="100"
                            value={bosTPSL.tp1.positionPercent}
                            onChange={(e) => setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      </div>
                      {bosTPSL.tp1.type === 'atr' && (
                        <div>
                          <Label className="text-xs text-gray-400">ATR Multiplier</Label>
                          <input
                            type="number"
                            min="0.5"
                            max="5"
                            step="0.1"
                            value={bosTPSL.tp1.atrMultiplier ?? ""}
                            onChange={(e) => {
                              const val = parseFloat(e.target.value);
                              setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, atrMultiplier: isNaN(val) || e.target.value === "" ? undefined : val}});
                            }}
                            onBlur={(e) => {
                              if (!bosTPSL.tp1.atrMultiplier) setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, atrMultiplier: 1.5}});
                            }}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {bosTPSL.tp1.type === 'fixed_rr' && (
                        <div>
                          <Label className="text-xs text-gray-400">R:R Ratio</Label>
                          <input
                            type="number"
                            min="0.5"
                            max="10"
                            step="0.1"
                            value={bosTPSL.tp1.fixedRR ?? ""}
                            onChange={(e) => {
                              const val = parseFloat(e.target.value);
                              setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, fixedRR: isNaN(val) || e.target.value === "" ? undefined : val}});
                            }}
                            onBlur={(e) => {
                              if (!bosTPSL.tp1.fixedRR) setBosTPSL({...bosTPSL, tp1: {...bosTPSL.tp1, fixedRR: 2.0}});
                            }}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {bosTPSL.tp1.type === 'structure' && (
                        <div>
                          <Label className="text-xs text-gray-400">TP Swing Length</Label>
                          <input
                            type="number"
                            min="5"
                            max="50"
                            value={bosTPSwingLengthInput}
                            onChange={(e) => setBosTPSwingLengthInput(e.target.value)}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                    </div>
                    
                    {/* TP2 Configuration */}
                    {bosTPSL.numTPs >= 2 && (
                      <div className="bg-slate-900/30 p-2 rounded space-y-2">
                        <Label className="text-xs text-green-400 font-semibold">TP2</Label>
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <Label className="text-xs text-gray-400">Type</Label>
                            <Select value={bosTPSL.tp2?.type || 'structure'} onValueChange={(v: TPType) => setBosTPSL({...bosTPSL, tp2: {...(bosTPSL.tp2 || {positionPercent: 30}), type: v}})}>
                              <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="atr">ATR</SelectItem>
                                <SelectItem value="structure">Structure</SelectItem>
                                <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                                <SelectItem value="vwap">VWAP</SelectItem>
                                <SelectItem value="ema">EMA Exit</SelectItem>
                              </SelectContent>
                            </Select>
                          </div>
                          <div>
                            <Label className="text-xs text-gray-400">Position %</Label>
                            <input
                              type="number"
                              min="1"
                              max="100"
                              value={bosTPSL.tp2?.positionPercent ?? ""}
                              onChange={(e) => setBosTPSL({...bosTPSL, tp2: {...(bosTPSL.tp2 || {type: 'structure'}), positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        </div>
                        {bosTPSL.tp2?.type === 'atr' && (
                          <div>
                            <Label className="text-xs text-gray-400">ATR Multiplier</Label>
                            <input
                              type="number"
                              min="0.5"
                              max="5"
                              step="0.1"
                              value={bosTPSL.tp2?.atrMultiplier ?? ""}
                              onChange={(e) => setBosTPSL({...bosTPSL, tp2: {...(bosTPSL.tp2 || {type: 'atr', positionPercent: 30}), atrMultiplier: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {bosTPSL.tp2?.type === 'fixed_rr' && (
                          <div>
                            <Label className="text-xs text-gray-400">R:R Ratio</Label>
                            <input
                              type="number"
                              min="0.5"
                              max="10"
                              step="0.1"
                              value={bosTPSL.tp2?.fixedRR ?? ""}
                              onChange={(e) => setBosTPSL({...bosTPSL, tp2: {...(bosTPSL.tp2 || {type: 'fixed_rr', positionPercent: 30}), fixedRR: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                        {bosTPSL.tp2?.type === 'structure' && (
                          <div>
                            <Label className="text-xs text-gray-400">TP Swing Length</Label>
                            <input
                              type="number"
                              min="5"
                              max="50"
                              value={bosTPSwingLengthInput}
                              onChange={(e) => setBosTPSwingLengthInput(e.target.value)}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* TP3 Configuration */}
                    {bosTPSL.numTPs === 3 && (
                      <div className="bg-slate-900/30 p-2 rounded space-y-2">
                        <Label className="text-xs text-green-400 font-semibold">TP3</Label>
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <Label className="text-xs text-gray-400">Type</Label>
                            <Select value={bosTPSL.tp3?.type || 'projection'} onValueChange={(v: TPType) => setBosTPSL({...bosTPSL, tp3: {...(bosTPSL.tp3 || {positionPercent: 20}), type: v}})}>
                              <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="atr">ATR</SelectItem>
                                <SelectItem value="structure">Structure</SelectItem>
                                <SelectItem value="fixed_rr">Fixed R:R</SelectItem>
                                <SelectItem value="vwap">VWAP</SelectItem>
                                <SelectItem value="ema">EMA Exit</SelectItem>
                              </SelectContent>
                            </Select>
                          </div>
                          <div>
                            <Label className="text-xs text-gray-400">Position %</Label>
                            <input
                              type="number"
                              min="1"
                              max="100"
                              value={bosTPSL.tp3?.positionPercent ?? ""}
                              onChange={(e) => setBosTPSL({...bosTPSL, tp3: {...(bosTPSL.tp3 || {type: 'atr', positionPercent: 20}), positionPercent: (e.target.value === "" ? undefined : parseInt(e.target.value))}})}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        </div>
                        {bosTPSL.tp3?.type === 'structure' && (
                          <div>
                            <Label className="text-xs text-gray-400">TP Swing Length</Label>
                            <input
                              type="number"
                              min="5"
                              max="50"
                              value={bosTPSwingLengthInput}
                              onChange={(e) => setBosTPSwingLengthInput(e.target.value)}
                              className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                            />
                          </div>
                        )}
                      </div>
                    )}
                    
                    {/* Stop Loss Configuration */}
                    <div className="bg-red-900/10 p-2 rounded space-y-2 border border-red-900/30">
                      <Label className="text-xs text-red-400 font-semibold">Stop Loss</Label>
                      <div>
                        <Label className="text-xs text-gray-400">Type</Label>
                        <Select value={bosTPSL.sl.type} onValueChange={(v: SLType) => setBosTPSL({...bosTPSL, sl: {...bosTPSL.sl, type: v}})}>
                          <SelectTrigger className="h-7 bg-slate-900 text-white border-slate-600 text-xs">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="atr">ATR</SelectItem>
                            <SelectItem value="structure">Structure (Swing)</SelectItem>
                            <SelectItem value="fixed">Fixed Distance</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      {bosTPSL.sl.type === 'atr' && (
                        <div>
                          <Label className="text-xs text-gray-400">ATR Multiplier</Label>
                          <input
                            type="number"
                            min="0.5"
                            max="5"
                            step="0.1"
                            value={bosTPSL.sl.atrMultiplier ?? ""}
                            onChange={(e) => setBosTPSL({...bosTPSL, sl: {...bosTPSL.sl, atrMultiplier: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {bosTPSL.sl.type === 'structure' && (
                        <div>
                          <Label className="text-xs text-gray-400">SL Swing Length</Label>
                          <input
                            type="number"
                            min="1"
                            max="30"
                            value={bosSLSwingLengthInput}
                            onChange={(e) => setBosSLSwingLengthInput(e.target.value)}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                      {bosTPSL.sl.type === 'fixed' && (
                        <div>
                          <Label className="text-xs text-gray-400">Fixed Distance (%)</Label>
                          <input
                            type="number"
                            min="0.1"
                            max="10"
                            step="0.1"
                            value={bosTPSL.sl.fixedDistance ?? ""}
                            onChange={(e) => setBosTPSL({...bosTPSL, sl: {...bosTPSL.sl, fixedDistance: (e.target.value === "" ? undefined : parseFloat(e.target.value))}})}
                            className="w-full h-7 px-2 bg-slate-900 text-white border border-slate-600 rounded text-xs"
                          />
                        </div>
                      )}
                    </div>
                  </div>
                </CardContent>
              )}
            </Card>
          </div>
        </div>

        {/* Unlock AI Analysis CTA */}
        <Card className="bg-gradient-to-r from-purple-900/20 to-blue-900/20 border-purple-500/30 p-8 text-center">
          <div className="max-w-2xl mx-auto space-y-4">
            <h2 className="text-3xl font-bold text-white">Unlock AI-Powered Trade Analysis</h2>
            <p className="text-gray-300 text-lg">
              Upgrade to Tier 2 for instant trade alerts powered by Grok AI. Get real-time confluence analysis, 
              push notifications, and custom alert preferences.
            </p>
            <div className="flex items-center justify-center gap-6 text-sm text-gray-400">
              <div className="flex items-center gap-2">
                <Zap className="w-5 h-5 text-yellow-400" />
                <span>AI Trade Alerts</span>
              </div>
              <div className="flex items-center gap-2">
                <Bell className="w-5 h-5 text-blue-400" />
                <span>Push Notifications</span>
              </div>
              <div className="flex items-center gap-2">
                <Activity className="w-5 h-5 text-green-400" />
                <span>Custom Filters</span>
              </div>
            </div>
            <Button
              onClick={() => window.location.href = '/cryptoai'}
              className="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white px-8 py-6 text-lg font-semibold"
              data-testid="button-unlock-ai"
            >
              Unlock AI Analysis - $10/month
            </Button>
          </div>
        </Card>
      </div>
    </div>
  );
}
